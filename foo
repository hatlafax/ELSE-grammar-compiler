c++ -> ['./grammars/CPP23.g4']

Working in language c++.

== ./grammars/CPP23.g4 ==
-------------------------
  enterIdentifier: CPP23
  exitIdentifier: CPP23
  enterRuleSpec: typedef-name:identifier|simple-template-id;
    enterRuleBlock: identifier|simple-template-id
      enterRuleAltList: identifier|simple-template-id
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
        enterLabeledAlt: simple-template-id
          enterAlternative: simple-template-id
            enterElement: simple-template-id
              => element -> {simple-template-id}
              enterAtom: simple-template-id
                enterRuleref: simple-template-id
                exitRuleref: simple-template-id
              exitAtom: simple-template-id
            exitElement: simple-template-id
          exitAlternative: simple-template-id
        => elements -> ['{simple-template-id}']
            => alternative -> {simple-template-id}
        exitLabeledAlt: simple-template-id
      exitRuleAltList: identifier|simple-template-id
    exitRuleBlock: identifier|simple-template-id
  exitRuleSpec: typedef-name:identifier|simple-template-id;

  enterRuleSpec: namespace-name:identifier|namespace-alias;
    enterRuleBlock: identifier|namespace-alias
      enterRuleAltList: identifier|namespace-alias
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
        enterLabeledAlt: namespace-alias
          enterAlternative: namespace-alias
            enterElement: namespace-alias
              => element -> {namespace-alias}
              enterAtom: namespace-alias
                enterRuleref: namespace-alias
                exitRuleref: namespace-alias
              exitAtom: namespace-alias
            exitElement: namespace-alias
          exitAlternative: namespace-alias
        => elements -> ['{namespace-alias}']
            => alternative -> {namespace-alias}
        exitLabeledAlt: namespace-alias
      exitRuleAltList: identifier|namespace-alias
    exitRuleBlock: identifier|namespace-alias
  exitRuleSpec: namespace-name:identifier|namespace-alias;

  enterRuleSpec: namespace-alias:identifier;
    enterRuleBlock: identifier
      enterRuleAltList: identifier
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
      exitRuleAltList: identifier
    exitRuleBlock: identifier
  exitRuleSpec: namespace-alias:identifier;

  enterRuleSpec: class-name:identifier|simple-template-id;
    enterRuleBlock: identifier|simple-template-id
      enterRuleAltList: identifier|simple-template-id
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
        enterLabeledAlt: simple-template-id
          enterAlternative: simple-template-id
            enterElement: simple-template-id
              => element -> {simple-template-id}
              enterAtom: simple-template-id
                enterRuleref: simple-template-id
                exitRuleref: simple-template-id
              exitAtom: simple-template-id
            exitElement: simple-template-id
          exitAlternative: simple-template-id
        => elements -> ['{simple-template-id}']
            => alternative -> {simple-template-id}
        exitLabeledAlt: simple-template-id
      exitRuleAltList: identifier|simple-template-id
    exitRuleBlock: identifier|simple-template-id
  exitRuleSpec: class-name:identifier|simple-template-id;

  enterRuleSpec: enum-name:identifier;
    enterRuleBlock: identifier
      enterRuleAltList: identifier
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
      exitRuleAltList: identifier
    exitRuleBlock: identifier
  exitRuleSpec: enum-name:identifier;

  enterRuleSpec: template-name:identifier;
    enterRuleBlock: identifier
      enterRuleAltList: identifier
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
      exitRuleAltList: identifier
    exitRuleBlock: identifier
  exitRuleSpec: template-name:identifier;

  enterRuleSpec: n-char:'<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>';
    enterRuleBlock: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
      enterRuleAltList: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
        enterLabeledAlt: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
          enterAlternative: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
            enterElement: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
              => element -> <<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>
              enterAtom: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
                enterTerminal: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
                exitTerminal: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
              exitAtom: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
            exitElement: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
          exitAlternative: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
        => elements -> ['<<<Enter a n-char sequence, that is translation characters except of { or \\\\n.>>>']
            => alternative -> <<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>
        exitLabeledAlt: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
      exitRuleAltList: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
    exitRuleBlock: '<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
  exitRuleSpec: n-char:'<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>';

  enterRuleSpec: named-universal-character:'\\N{'n-char'}';
    enterRuleBlock: '\\N{'n-char'}'
      enterRuleAltList: '\\N{'n-char'}'
        enterLabeledAlt: '\\N{'n-char'}'
          enterAlternative: '\\N{'n-char'}'
            enterElement: '\\N{'
              => element -> \\N{
              enterAtom: '\\N{'
                enterTerminal: '\\N{'
                exitTerminal: '\\N{'
              exitAtom: '\\N{'
            exitElement: '\\N{'
            enterElement: n-char
              => element -> {n-char}
              enterAtom: n-char
                enterRuleref: n-char
                exitRuleref: n-char
              exitAtom: n-char
            exitElement: n-char
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: '\\N{'n-char'}'
        => elements -> ['\\\\N{', '{n-char}', '}']
            => alternative -> \\N{ {n-char} }
        exitLabeledAlt: '\\N{'n-char'}'
      exitRuleAltList: '\\N{'n-char'}'
    exitRuleBlock: '\\N{'n-char'}'
  exitRuleSpec: named-universal-character:'\\N{'n-char'}';

  enterRuleSpec: hexadecimal-digit:'<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>';
    enterRuleBlock: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
      enterRuleAltList: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
        enterLabeledAlt: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
          enterAlternative: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
            enterElement: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
              => element -> <<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>
              enterAtom: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
                enterTerminal: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
                exitTerminal: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
              exitAtom: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
            exitElement: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
          exitAlternative: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
        => elements -> ['<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>']
            => alternative -> <<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>
        exitLabeledAlt: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
      exitRuleAltList: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
    exitRuleBlock: '<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
  exitRuleSpec: hexadecimal-digit:'<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>';

  enterRuleSpec: hex-quad:'<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>';
    enterRuleBlock: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
      enterRuleAltList: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
        enterLabeledAlt: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
          enterAlternative: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
            enterElement: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
              => element -> <<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>
              enterAtom: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
                enterTerminal: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
                exitTerminal: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
              exitAtom: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
            exitElement: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
          exitAlternative: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
        => elements -> ['<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>']
            => alternative -> <<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>
        exitLabeledAlt: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
      exitRuleAltList: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
    exitRuleBlock: '<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
  exitRuleSpec: hex-quad:'<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>';

  enterRuleSpec: hex-quad-quad:'<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>';
    enterRuleBlock: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
      enterRuleAltList: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
        enterLabeledAlt: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
          enterAlternative: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
            enterElement: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
              => element -> <<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>
              enterAtom: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
                enterTerminal: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
                exitTerminal: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
              exitAtom: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
            exitElement: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
          exitAlternative: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
        => elements -> ['<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>']
            => alternative -> <<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>
        exitLabeledAlt: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
      exitRuleAltList: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
    exitRuleBlock: '<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
  exitRuleSpec: hex-quad-quad:'<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>';

  enterRuleSpec: universal-character-name:'\\u'hex-quad|'\\U'hex-quad-quad|'\\u{'hexadecimal-digit'}'|named-universal-character;
    enterRuleBlock: '\\u'hex-quad|'\\U'hex-quad-quad|'\\u{'hexadecimal-digit'}'|named-universal-character
      enterRuleAltList: '\\u'hex-quad|'\\U'hex-quad-quad|'\\u{'hexadecimal-digit'}'|named-universal-character
        enterLabeledAlt: '\\u'hex-quad
          enterAlternative: '\\u'hex-quad
            enterElement: '\\u'
              => element -> \\u
              enterAtom: '\\u'
                enterTerminal: '\\u'
                exitTerminal: '\\u'
              exitAtom: '\\u'
            exitElement: '\\u'
            enterElement: hex-quad
              => element -> {hex-quad}
              enterAtom: hex-quad
                enterRuleref: hex-quad
                exitRuleref: hex-quad
              exitAtom: hex-quad
            exitElement: hex-quad
          exitAlternative: '\\u'hex-quad
        => elements -> ['\\\\u', '{hex-quad}']
            => alternative -> \\u {hex-quad}
        exitLabeledAlt: '\\u'hex-quad
        enterLabeledAlt: '\\U'hex-quad-quad
          enterAlternative: '\\U'hex-quad-quad
            enterElement: '\\U'
              => element -> \\U
              enterAtom: '\\U'
                enterTerminal: '\\U'
                exitTerminal: '\\U'
              exitAtom: '\\U'
            exitElement: '\\U'
            enterElement: hex-quad-quad
              => element -> {hex-quad-quad}
              enterAtom: hex-quad-quad
                enterRuleref: hex-quad-quad
                exitRuleref: hex-quad-quad
              exitAtom: hex-quad-quad
            exitElement: hex-quad-quad
          exitAlternative: '\\U'hex-quad-quad
        => elements -> ['\\\\U', '{hex-quad-quad}']
            => alternative -> \\U {hex-quad-quad}
        exitLabeledAlt: '\\U'hex-quad-quad
        enterLabeledAlt: '\\u{'hexadecimal-digit'}'
          enterAlternative: '\\u{'hexadecimal-digit'}'
            enterElement: '\\u{'
              => element -> \\u{
              enterAtom: '\\u{'
                enterTerminal: '\\u{'
                exitTerminal: '\\u{'
              exitAtom: '\\u{'
            exitElement: '\\u{'
            enterElement: hexadecimal-digit
              => element -> {hexadecimal-digit}
              enterAtom: hexadecimal-digit
                enterRuleref: hexadecimal-digit
                exitRuleref: hexadecimal-digit
              exitAtom: hexadecimal-digit
            exitElement: hexadecimal-digit
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: '\\u{'hexadecimal-digit'}'
        => elements -> ['\\\\u{', '{hexadecimal-digit}', '}']
            => alternative -> \\u{ {hexadecimal-digit} }
        exitLabeledAlt: '\\u{'hexadecimal-digit'}'
        enterLabeledAlt: named-universal-character
          enterAlternative: named-universal-character
            enterElement: named-universal-character
              => element -> {named-universal-character}
              enterAtom: named-universal-character
                enterRuleref: named-universal-character
                exitRuleref: named-universal-character
              exitAtom: named-universal-character
            exitElement: named-universal-character
          exitAlternative: named-universal-character
        => elements -> ['{named-universal-character}']
            => alternative -> {named-universal-character}
        exitLabeledAlt: named-universal-character
      exitRuleAltList: '\\u'hex-quad|'\\U'hex-quad-quad|'\\u{'hexadecimal-digit'}'|named-universal-character
    exitRuleBlock: '\\u'hex-quad|'\\U'hex-quad-quad|'\\u{'hexadecimal-digit'}'|named-universal-character
  exitRuleSpec: universal-character-name:'\\u'hex-quad|'\\U'hex-quad-quad|'\\u{'hexadecimal-digit'}'|named-universal-character;

  enterRuleSpec: non-whitespace-character-literal:'<<<Each non-whitespace character that cannot be one of the above.>>>';
    enterRuleBlock: '<<<Each non-whitespace character that cannot be one of the above.>>>'
      enterRuleAltList: '<<<Each non-whitespace character that cannot be one of the above.>>>'
        enterLabeledAlt: '<<<Each non-whitespace character that cannot be one of the above.>>>'
          enterAlternative: '<<<Each non-whitespace character that cannot be one of the above.>>>'
            enterElement: '<<<Each non-whitespace character that cannot be one of the above.>>>'
              => element -> <<<Each non-whitespace character that cannot be one of the above.>>>
              enterAtom: '<<<Each non-whitespace character that cannot be one of the above.>>>'
                enterTerminal: '<<<Each non-whitespace character that cannot be one of the above.>>>'
                exitTerminal: '<<<Each non-whitespace character that cannot be one of the above.>>>'
              exitAtom: '<<<Each non-whitespace character that cannot be one of the above.>>>'
            exitElement: '<<<Each non-whitespace character that cannot be one of the above.>>>'
          exitAlternative: '<<<Each non-whitespace character that cannot be one of the above.>>>'
        => elements -> ['<<<Each non-whitespace character that cannot be one of the above.>>>']
            => alternative -> <<<Each non-whitespace character that cannot be one of the above.>>>
        exitLabeledAlt: '<<<Each non-whitespace character that cannot be one of the above.>>>'
      exitRuleAltList: '<<<Each non-whitespace character that cannot be one of the above.>>>'
    exitRuleBlock: '<<<Each non-whitespace character that cannot be one of the above.>>>'
  exitRuleSpec: non-whitespace-character-literal:'<<<Each non-whitespace character that cannot be one of the above.>>>';

  enterRuleSpec: preprocessing-token:header-name|import-keyword|module-keyword|export-keyword|identifier|pp-number|character-literal|user-defined-character-literal|string-literal|user-defined-string-literal|preprocessing-op-or-punc|non-whitespace-character-literal;
    enterRuleBlock: header-name|import-keyword|module-keyword|export-keyword|identifier|pp-number|character-literal|user-defined-character-literal|string-literal|user-defined-string-literal|preprocessing-op-or-punc|non-whitespace-character-literal
      enterRuleAltList: header-name|import-keyword|module-keyword|export-keyword|identifier|pp-number|character-literal|user-defined-character-literal|string-literal|user-defined-string-literal|preprocessing-op-or-punc|non-whitespace-character-literal
        enterLabeledAlt: header-name
          enterAlternative: header-name
            enterElement: header-name
              => element -> {header-name}
              enterAtom: header-name
                enterRuleref: header-name
                exitRuleref: header-name
              exitAtom: header-name
            exitElement: header-name
          exitAlternative: header-name
        => elements -> ['{header-name}']
            => alternative -> {header-name}
        exitLabeledAlt: header-name
        enterLabeledAlt: import-keyword
          enterAlternative: import-keyword
            enterElement: import-keyword
              => element -> {import-keyword}
              enterAtom: import-keyword
                enterRuleref: import-keyword
                exitRuleref: import-keyword
              exitAtom: import-keyword
            exitElement: import-keyword
          exitAlternative: import-keyword
        => elements -> ['{import-keyword}']
            => alternative -> {import-keyword}
        exitLabeledAlt: import-keyword
        enterLabeledAlt: module-keyword
          enterAlternative: module-keyword
            enterElement: module-keyword
              => element -> {module-keyword}
              enterAtom: module-keyword
                enterRuleref: module-keyword
                exitRuleref: module-keyword
              exitAtom: module-keyword
            exitElement: module-keyword
          exitAlternative: module-keyword
        => elements -> ['{module-keyword}']
            => alternative -> {module-keyword}
        exitLabeledAlt: module-keyword
        enterLabeledAlt: export-keyword
          enterAlternative: export-keyword
            enterElement: export-keyword
              => element -> {export-keyword}
              enterAtom: export-keyword
                enterRuleref: export-keyword
                exitRuleref: export-keyword
              exitAtom: export-keyword
            exitElement: export-keyword
          exitAlternative: export-keyword
        => elements -> ['{export-keyword}']
            => alternative -> {export-keyword}
        exitLabeledAlt: export-keyword
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
        enterLabeledAlt: pp-number
          enterAlternative: pp-number
            enterElement: pp-number
              => element -> {pp-number}
              enterAtom: pp-number
                enterRuleref: pp-number
                exitRuleref: pp-number
              exitAtom: pp-number
            exitElement: pp-number
          exitAlternative: pp-number
        => elements -> ['{pp-number}']
            => alternative -> {pp-number}
        exitLabeledAlt: pp-number
        enterLabeledAlt: character-literal
          enterAlternative: character-literal
            enterElement: character-literal
              => element -> {character-literal}
              enterAtom: character-literal
                enterRuleref: character-literal
                exitRuleref: character-literal
              exitAtom: character-literal
            exitElement: character-literal
          exitAlternative: character-literal
        => elements -> ['{character-literal}']
            => alternative -> {character-literal}
        exitLabeledAlt: character-literal
        enterLabeledAlt: user-defined-character-literal
          enterAlternative: user-defined-character-literal
            enterElement: user-defined-character-literal
              => element -> {user-defined-character-literal}
              enterAtom: user-defined-character-literal
                enterRuleref: user-defined-character-literal
                exitRuleref: user-defined-character-literal
              exitAtom: user-defined-character-literal
            exitElement: user-defined-character-literal
          exitAlternative: user-defined-character-literal
        => elements -> ['{user-defined-character-literal}']
            => alternative -> {user-defined-character-literal}
        exitLabeledAlt: user-defined-character-literal
        enterLabeledAlt: string-literal
          enterAlternative: string-literal
            enterElement: string-literal
              => element -> {string-literal}
              enterAtom: string-literal
                enterRuleref: string-literal
                exitRuleref: string-literal
              exitAtom: string-literal
            exitElement: string-literal
          exitAlternative: string-literal
        => elements -> ['{string-literal}']
            => alternative -> {string-literal}
        exitLabeledAlt: string-literal
        enterLabeledAlt: user-defined-string-literal
          enterAlternative: user-defined-string-literal
            enterElement: user-defined-string-literal
              => element -> {user-defined-string-literal}
              enterAtom: user-defined-string-literal
                enterRuleref: user-defined-string-literal
                exitRuleref: user-defined-string-literal
              exitAtom: user-defined-string-literal
            exitElement: user-defined-string-literal
          exitAlternative: user-defined-string-literal
        => elements -> ['{user-defined-string-literal}']
            => alternative -> {user-defined-string-literal}
        exitLabeledAlt: user-defined-string-literal
        enterLabeledAlt: preprocessing-op-or-punc
          enterAlternative: preprocessing-op-or-punc
            enterElement: preprocessing-op-or-punc
              => element -> {preprocessing-op-or-punc}
              enterAtom: preprocessing-op-or-punc
                enterRuleref: preprocessing-op-or-punc
                exitRuleref: preprocessing-op-or-punc
              exitAtom: preprocessing-op-or-punc
            exitElement: preprocessing-op-or-punc
          exitAlternative: preprocessing-op-or-punc
        => elements -> ['{preprocessing-op-or-punc}']
            => alternative -> {preprocessing-op-or-punc}
        exitLabeledAlt: preprocessing-op-or-punc
        enterLabeledAlt: non-whitespace-character-literal
          enterAlternative: non-whitespace-character-literal
            enterElement: non-whitespace-character-literal
              => element -> {non-whitespace-character-literal}
              enterAtom: non-whitespace-character-literal
                enterRuleref: non-whitespace-character-literal
                exitRuleref: non-whitespace-character-literal
              exitAtom: non-whitespace-character-literal
            exitElement: non-whitespace-character-literal
          exitAlternative: non-whitespace-character-literal
        => elements -> ['{non-whitespace-character-literal}']
            => alternative -> {non-whitespace-character-literal}
        exitLabeledAlt: non-whitespace-character-literal
      exitRuleAltList: header-name|import-keyword|module-keyword|export-keyword|identifier|pp-number|character-literal|user-defined-character-literal|string-literal|user-defined-string-literal|preprocessing-op-or-punc|non-whitespace-character-literal
    exitRuleBlock: header-name|import-keyword|module-keyword|export-keyword|identifier|pp-number|character-literal|user-defined-character-literal|string-literal|user-defined-string-literal|preprocessing-op-or-punc|non-whitespace-character-literal
  exitRuleSpec: preprocessing-token:header-name|import-keyword|module-keyword|export-keyword|identifier|pp-number|character-literal|user-defined-character-literal|string-literal|user-defined-string-literal|preprocessing-op-or-punc|non-whitespace-character-literal;

  enterRuleSpec: token:identifier|keyword|literal|operator-or-punctuator;
    enterRuleBlock: identifier|keyword|literal|operator-or-punctuator
      enterRuleAltList: identifier|keyword|literal|operator-or-punctuator
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
        enterLabeledAlt: keyword
          enterAlternative: keyword
            enterElement: keyword
              => element -> {keyword}
              enterAtom: keyword
                enterRuleref: keyword
                exitRuleref: keyword
              exitAtom: keyword
            exitElement: keyword
          exitAlternative: keyword
        => elements -> ['{keyword}']
            => alternative -> {keyword}
        exitLabeledAlt: keyword
        enterLabeledAlt: literal
          enterAlternative: literal
            enterElement: literal
              => element -> {literal}
              enterAtom: literal
                enterRuleref: literal
                exitRuleref: literal
              exitAtom: literal
            exitElement: literal
          exitAlternative: literal
        => elements -> ['{literal}']
            => alternative -> {literal}
        exitLabeledAlt: literal
        enterLabeledAlt: operator-or-punctuator
          enterAlternative: operator-or-punctuator
            enterElement: operator-or-punctuator
              => element -> {operator-or-punctuator}
              enterAtom: operator-or-punctuator
                enterRuleref: operator-or-punctuator
                exitRuleref: operator-or-punctuator
              exitAtom: operator-or-punctuator
            exitElement: operator-or-punctuator
          exitAlternative: operator-or-punctuator
        => elements -> ['{operator-or-punctuator}']
            => alternative -> {operator-or-punctuator}
        exitLabeledAlt: operator-or-punctuator
      exitRuleAltList: identifier|keyword|literal|operator-or-punctuator
    exitRuleBlock: identifier|keyword|literal|operator-or-punctuator
  exitRuleSpec: token:identifier|keyword|literal|operator-or-punctuator;

  enterRuleSpec: h-char:'<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>';
    enterRuleBlock: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
      enterRuleAltList: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
        enterLabeledAlt: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
          enterAlternative: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
            enterElement: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
              => element -> <<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>
              enterAtom: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
                enterTerminal: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
                exitTerminal: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
              exitAtom: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
            exitElement: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
          exitAlternative: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
        => elements -> ['<<<Enter a h-char sequence, i.e. source characters except \\\\n and > characters.>>>']
            => alternative -> <<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>
        exitLabeledAlt: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
      exitRuleAltList: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
    exitRuleBlock: '<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
  exitRuleSpec: h-char:'<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>';

  enterRuleSpec: q-char:'<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>';
    enterRuleBlock: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
      enterRuleAltList: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
        enterLabeledAlt: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
          enterAlternative: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
            enterElement: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
              => element -> <<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>
              enterAtom: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
                enterTerminal: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
                exitTerminal: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
              exitAtom: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
            exitElement: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
          exitAlternative: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
        => elements -> ['<<<Enter a q-char sequence, i.e. source characters except \\\\n and quotation mark " characters.>>>']
            => alternative -> <<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>
        exitLabeledAlt: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
      exitRuleAltList: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
    exitRuleBlock: '<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
  exitRuleSpec: q-char:'<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>';

  enterRuleSpec: header-name:'<'h-char'>'|'"'q-char'"';
    enterRuleBlock: '<'h-char'>'|'"'q-char'"'
      enterRuleAltList: '<'h-char'>'|'"'q-char'"'
        enterLabeledAlt: '<'h-char'>'
          enterAlternative: '<'h-char'>'
            enterElement: '<'
              => element -> <
              enterAtom: '<'
                enterTerminal: '<'
                exitTerminal: '<'
              exitAtom: '<'
            exitElement: '<'
            enterElement: h-char
              => element -> {h-char}
              enterAtom: h-char
                enterRuleref: h-char
                exitRuleref: h-char
              exitAtom: h-char
            exitElement: h-char
            enterElement: '>'
              => element -> >
              enterAtom: '>'
                enterTerminal: '>'
                exitTerminal: '>'
              exitAtom: '>'
            exitElement: '>'
          exitAlternative: '<'h-char'>'
        => elements -> ['<', '{h-char}', '>']
            => alternative -> < {h-char} >
        exitLabeledAlt: '<'h-char'>'
        enterLabeledAlt: '"'q-char'"'
          enterAlternative: '"'q-char'"'
            enterElement: '"'
              => element -> "
              enterAtom: '"'
                enterTerminal: '"'
                exitTerminal: '"'
              exitAtom: '"'
            exitElement: '"'
            enterElement: q-char
              => element -> {q-char}
              enterAtom: q-char
                enterRuleref: q-char
                exitRuleref: q-char
              exitAtom: q-char
            exitElement: q-char
            enterElement: '"'
              => element -> "
              enterAtom: '"'
                enterTerminal: '"'
                exitTerminal: '"'
              exitAtom: '"'
            exitElement: '"'
          exitAlternative: '"'q-char'"'
        => elements -> ['"', '{q-char}', '"']
            => alternative -> " {q-char} "
        exitLabeledAlt: '"'q-char'"'
      exitRuleAltList: '<'h-char'>'|'"'q-char'"'
    exitRuleBlock: '<'h-char'>'|'"'q-char'"'
  exitRuleSpec: header-name:'<'h-char'>'|'"'q-char'"';

  enterRuleSpec: pp-number:digit|'.'digit|pp-numberdigit|pp-numberidentifier-nondigit|pp-number'\''digit|pp-number'\''nondigit|pp-number'e'sign|pp-number'E'sign|pp-number'p'sign|pp-number'P'sign|pp-number'.';
    enterRuleBlock: digit|'.'digit|pp-numberdigit|pp-numberidentifier-nondigit|pp-number'\''digit|pp-number'\''nondigit|pp-number'e'sign|pp-number'E'sign|pp-number'p'sign|pp-number'P'sign|pp-number'.'
      enterRuleAltList: digit|'.'digit|pp-numberdigit|pp-numberidentifier-nondigit|pp-number'\''digit|pp-number'\''nondigit|pp-number'e'sign|pp-number'E'sign|pp-number'p'sign|pp-number'P'sign|pp-number'.'
        enterLabeledAlt: digit
          enterAlternative: digit
            enterElement: digit
              => element -> {digit}
              enterAtom: digit
                enterRuleref: digit
                exitRuleref: digit
              exitAtom: digit
            exitElement: digit
          exitAlternative: digit
        => elements -> ['{digit}']
            => alternative -> {digit}
        exitLabeledAlt: digit
        enterLabeledAlt: '.'digit
          enterAlternative: '.'digit
            enterElement: '.'
              => element -> .
              enterAtom: '.'
                enterTerminal: '.'
                exitTerminal: '.'
              exitAtom: '.'
            exitElement: '.'
            enterElement: digit
              => element -> {digit}
              enterAtom: digit
                enterRuleref: digit
                exitRuleref: digit
              exitAtom: digit
            exitElement: digit
          exitAlternative: '.'digit
        => elements -> ['.', '{digit}']
            => alternative -> . {digit}
        exitLabeledAlt: '.'digit
        enterLabeledAlt: pp-numberdigit
          enterAlternative: pp-numberdigit
            enterElement: pp-number
              => element -> {pp-number}
              enterAtom: pp-number
                enterRuleref: pp-number
                exitRuleref: pp-number
              exitAtom: pp-number
            exitElement: pp-number
            enterElement: digit
              => element -> {digit}
              enterAtom: digit
                enterRuleref: digit
                exitRuleref: digit
              exitAtom: digit
            exitElement: digit
          exitAlternative: pp-numberdigit
        => elements -> ['{pp-number}', '{digit}']
            => alternative -> {pp-number} {digit}
        exitLabeledAlt: pp-numberdigit
        enterLabeledAlt: pp-numberidentifier-nondigit
          enterAlternative: pp-numberidentifier-nondigit
            enterElement: pp-number
              => element -> {pp-number}
              enterAtom: pp-number
                enterRuleref: pp-number
                exitRuleref: pp-number
              exitAtom: pp-number
            exitElement: pp-number
            enterElement: identifier-nondigit
              => element -> {identifier-nondigit}
              enterAtom: identifier-nondigit
                enterRuleref: identifier-nondigit
                exitRuleref: identifier-nondigit
              exitAtom: identifier-nondigit
            exitElement: identifier-nondigit
          exitAlternative: pp-numberidentifier-nondigit
        => elements -> ['{pp-number}', '{identifier-nondigit}']
            => alternative -> {pp-number} {identifier-nondigit}
        exitLabeledAlt: pp-numberidentifier-nondigit
        enterLabeledAlt: pp-number'\''digit
          enterAlternative: pp-number'\''digit
            enterElement: pp-number
              => element -> {pp-number}
              enterAtom: pp-number
                enterRuleref: pp-number
                exitRuleref: pp-number
              exitAtom: pp-number
            exitElement: pp-number
            enterElement: '\''
              => element -> \'
              enterAtom: '\''
                enterTerminal: '\''
                exitTerminal: '\''
              exitAtom: '\''
            exitElement: '\''
            enterElement: digit
              => element -> {digit}
              enterAtom: digit
                enterRuleref: digit
                exitRuleref: digit
              exitAtom: digit
            exitElement: digit
          exitAlternative: pp-number'\''digit
        => elements -> ['{pp-number}', "\\'", '{digit}']
            => alternative -> {pp-number} \' {digit}
        exitLabeledAlt: pp-number'\''digit
        enterLabeledAlt: pp-number'\''nondigit
          enterAlternative: pp-number'\''nondigit
            enterElement: pp-number
              => element -> {pp-number}
              enterAtom: pp-number
                enterRuleref: pp-number
                exitRuleref: pp-number
              exitAtom: pp-number
            exitElement: pp-number
            enterElement: '\''
              => element -> \'
              enterAtom: '\''
                enterTerminal: '\''
                exitTerminal: '\''
              exitAtom: '\''
            exitElement: '\''
            enterElement: nondigit
              => element -> {nondigit}
              enterAtom: nondigit
                enterRuleref: nondigit
                exitRuleref: nondigit
              exitAtom: nondigit
            exitElement: nondigit
          exitAlternative: pp-number'\''nondigit
        => elements -> ['{pp-number}', "\\'", '{nondigit}']
            => alternative -> {pp-number} \' {nondigit}
        exitLabeledAlt: pp-number'\''nondigit
        enterLabeledAlt: pp-number'e'sign
          enterAlternative: pp-number'e'sign
            enterElement: pp-number
              => element -> {pp-number}
              enterAtom: pp-number
                enterRuleref: pp-number
                exitRuleref: pp-number
              exitAtom: pp-number
            exitElement: pp-number
            enterElement: 'e'
              => element -> e
              enterAtom: 'e'
                enterTerminal: 'e'
                exitTerminal: 'e'
              exitAtom: 'e'
            exitElement: 'e'
            enterElement: sign
              => element -> {sign}
              enterAtom: sign
                enterRuleref: sign
                exitRuleref: sign
              exitAtom: sign
            exitElement: sign
          exitAlternative: pp-number'e'sign
        => elements -> ['{pp-number}', 'e', '{sign}']
            => alternative -> {pp-number} e {sign}
        exitLabeledAlt: pp-number'e'sign
        enterLabeledAlt: pp-number'E'sign
          enterAlternative: pp-number'E'sign
            enterElement: pp-number
              => element -> {pp-number}
              enterAtom: pp-number
                enterRuleref: pp-number
                exitRuleref: pp-number
              exitAtom: pp-number
            exitElement: pp-number
            enterElement: 'E'
              => element -> E
              enterAtom: 'E'
                enterTerminal: 'E'
                exitTerminal: 'E'
              exitAtom: 'E'
            exitElement: 'E'
            enterElement: sign
              => element -> {sign}
              enterAtom: sign
                enterRuleref: sign
                exitRuleref: sign
              exitAtom: sign
            exitElement: sign
          exitAlternative: pp-number'E'sign
        => elements -> ['{pp-number}', 'E', '{sign}']
            => alternative -> {pp-number} E {sign}
        exitLabeledAlt: pp-number'E'sign
        enterLabeledAlt: pp-number'p'sign
          enterAlternative: pp-number'p'sign
            enterElement: pp-number
              => element -> {pp-number}
              enterAtom: pp-number
                enterRuleref: pp-number
                exitRuleref: pp-number
              exitAtom: pp-number
            exitElement: pp-number
            enterElement: 'p'
              => element -> p
              enterAtom: 'p'
                enterTerminal: 'p'
                exitTerminal: 'p'
              exitAtom: 'p'
            exitElement: 'p'
            enterElement: sign
              => element -> {sign}
              enterAtom: sign
                enterRuleref: sign
                exitRuleref: sign
              exitAtom: sign
            exitElement: sign
          exitAlternative: pp-number'p'sign
        => elements -> ['{pp-number}', 'p', '{sign}']
            => alternative -> {pp-number} p {sign}
        exitLabeledAlt: pp-number'p'sign
        enterLabeledAlt: pp-number'P'sign
          enterAlternative: pp-number'P'sign
            enterElement: pp-number
              => element -> {pp-number}
              enterAtom: pp-number
                enterRuleref: pp-number
                exitRuleref: pp-number
              exitAtom: pp-number
            exitElement: pp-number
            enterElement: 'P'
              => element -> P
              enterAtom: 'P'
                enterTerminal: 'P'
                exitTerminal: 'P'
              exitAtom: 'P'
            exitElement: 'P'
            enterElement: sign
              => element -> {sign}
              enterAtom: sign
                enterRuleref: sign
                exitRuleref: sign
              exitAtom: sign
            exitElement: sign
          exitAlternative: pp-number'P'sign
        => elements -> ['{pp-number}', 'P', '{sign}']
            => alternative -> {pp-number} P {sign}
        exitLabeledAlt: pp-number'P'sign
        enterLabeledAlt: pp-number'.'
          enterAlternative: pp-number'.'
            enterElement: pp-number
              => element -> {pp-number}
              enterAtom: pp-number
                enterRuleref: pp-number
                exitRuleref: pp-number
              exitAtom: pp-number
            exitElement: pp-number
            enterElement: '.'
              => element -> .
              enterAtom: '.'
                enterTerminal: '.'
                exitTerminal: '.'
              exitAtom: '.'
            exitElement: '.'
          exitAlternative: pp-number'.'
        => elements -> ['{pp-number}', '.']
            => alternative -> {pp-number} .
        exitLabeledAlt: pp-number'.'
      exitRuleAltList: digit|'.'digit|pp-numberdigit|pp-numberidentifier-nondigit|pp-number'\''digit|pp-number'\''nondigit|pp-number'e'sign|pp-number'E'sign|pp-number'p'sign|pp-number'P'sign|pp-number'.'
    exitRuleBlock: digit|'.'digit|pp-numberdigit|pp-numberidentifier-nondigit|pp-number'\''digit|pp-number'\''nondigit|pp-number'e'sign|pp-number'E'sign|pp-number'p'sign|pp-number'P'sign|pp-number'.'
  exitRuleSpec: pp-number:digit|'.'digit|pp-numberdigit|pp-numberidentifier-nondigit|pp-number'\''digit|pp-number'\''nondigit|pp-number'e'sign|pp-number'E'sign|pp-number'p'sign|pp-number'P'sign|pp-number'.';

  enterRuleSpec: identifier:identifier-start|identifieridentifier-continue;
    enterRuleBlock: identifier-start|identifieridentifier-continue
      enterRuleAltList: identifier-start|identifieridentifier-continue
        enterLabeledAlt: identifier-start
          enterAlternative: identifier-start
            enterElement: identifier-start
              => element -> {identifier-start}
              enterAtom: identifier-start
                enterRuleref: identifier-start
                exitRuleref: identifier-start
              exitAtom: identifier-start
            exitElement: identifier-start
          exitAlternative: identifier-start
        => elements -> ['{identifier-start}']
            => alternative -> {identifier-start}
        exitLabeledAlt: identifier-start
        enterLabeledAlt: identifieridentifier-continue
          enterAlternative: identifieridentifier-continue
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: identifier-continue
              => element -> {identifier-continue}
              enterAtom: identifier-continue
                enterRuleref: identifier-continue
                exitRuleref: identifier-continue
              exitAtom: identifier-continue
            exitElement: identifier-continue
          exitAlternative: identifieridentifier-continue
        => elements -> ['{identifier}', '{identifier-continue}']
            => alternative -> {identifier} {identifier-continue}
        exitLabeledAlt: identifieridentifier-continue
      exitRuleAltList: identifier-start|identifieridentifier-continue
    exitRuleBlock: identifier-start|identifieridentifier-continue
  exitRuleSpec: identifier:identifier-start|identifieridentifier-continue;

  enterRuleSpec: translation-character-xid-start:'<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>';
    enterRuleBlock: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
      enterRuleAltList: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
        enterLabeledAlt: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
          enterAlternative: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
            enterElement: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
              => element -> <<<Enter an element of the translation character set with the Unicode property XID-Start.>>>
              enterAtom: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
                enterTerminal: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
                exitTerminal: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
              exitAtom: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
            exitElement: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
          exitAlternative: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
        => elements -> ['<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>']
            => alternative -> <<<Enter an element of the translation character set with the Unicode property XID-Start.>>>
        exitLabeledAlt: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
      exitRuleAltList: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
    exitRuleBlock: '<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
  exitRuleSpec: translation-character-xid-start:'<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>';

  enterRuleSpec: translation-character-xid-continue:'<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>';
    enterRuleBlock: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
      enterRuleAltList: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
        enterLabeledAlt: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
          enterAlternative: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
            enterElement: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
              => element -> <<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>
              enterAtom: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
                enterTerminal: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
                exitTerminal: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
              exitAtom: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
            exitElement: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
          exitAlternative: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
        => elements -> ['<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>']
            => alternative -> <<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>
        exitLabeledAlt: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
      exitRuleAltList: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
    exitRuleBlock: '<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
  exitRuleSpec: translation-character-xid-continue:'<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>';

  enterRuleSpec: identifier-start:nondigit|translation-character-xid-start;
    enterRuleBlock: nondigit|translation-character-xid-start
      enterRuleAltList: nondigit|translation-character-xid-start
        enterLabeledAlt: nondigit
          enterAlternative: nondigit
            enterElement: nondigit
              => element -> {nondigit}
              enterAtom: nondigit
                enterRuleref: nondigit
                exitRuleref: nondigit
              exitAtom: nondigit
            exitElement: nondigit
          exitAlternative: nondigit
        => elements -> ['{nondigit}']
            => alternative -> {nondigit}
        exitLabeledAlt: nondigit
        enterLabeledAlt: translation-character-xid-start
          enterAlternative: translation-character-xid-start
            enterElement: translation-character-xid-start
              => element -> {translation-character-xid-start}
              enterAtom: translation-character-xid-start
                enterRuleref: translation-character-xid-start
                exitRuleref: translation-character-xid-start
              exitAtom: translation-character-xid-start
            exitElement: translation-character-xid-start
          exitAlternative: translation-character-xid-start
        => elements -> ['{translation-character-xid-start}']
            => alternative -> {translation-character-xid-start}
        exitLabeledAlt: translation-character-xid-start
      exitRuleAltList: nondigit|translation-character-xid-start
    exitRuleBlock: nondigit|translation-character-xid-start
  exitRuleSpec: identifier-start:nondigit|translation-character-xid-start;

  enterRuleSpec: identifier-continue:digit|nondigit|translation-character-xid-continue;
    enterRuleBlock: digit|nondigit|translation-character-xid-continue
      enterRuleAltList: digit|nondigit|translation-character-xid-continue
        enterLabeledAlt: digit
          enterAlternative: digit
            enterElement: digit
              => element -> {digit}
              enterAtom: digit
                enterRuleref: digit
                exitRuleref: digit
              exitAtom: digit
            exitElement: digit
          exitAlternative: digit
        => elements -> ['{digit}']
            => alternative -> {digit}
        exitLabeledAlt: digit
        enterLabeledAlt: nondigit
          enterAlternative: nondigit
            enterElement: nondigit
              => element -> {nondigit}
              enterAtom: nondigit
                enterRuleref: nondigit
                exitRuleref: nondigit
              exitAtom: nondigit
            exitElement: nondigit
          exitAlternative: nondigit
        => elements -> ['{nondigit}']
            => alternative -> {nondigit}
        exitLabeledAlt: nondigit
        enterLabeledAlt: translation-character-xid-continue
          enterAlternative: translation-character-xid-continue
            enterElement: translation-character-xid-continue
              => element -> {translation-character-xid-continue}
              enterAtom: translation-character-xid-continue
                enterRuleref: translation-character-xid-continue
                exitRuleref: translation-character-xid-continue
              exitAtom: translation-character-xid-continue
            exitElement: translation-character-xid-continue
          exitAlternative: translation-character-xid-continue
        => elements -> ['{translation-character-xid-continue}']
            => alternative -> {translation-character-xid-continue}
        exitLabeledAlt: translation-character-xid-continue
      exitRuleAltList: digit|nondigit|translation-character-xid-continue
    exitRuleBlock: digit|nondigit|translation-character-xid-continue
  exitRuleSpec: identifier-continue:digit|nondigit|translation-character-xid-continue;

  enterRuleSpec: nondigit:'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'_';
    enterRuleBlock: 'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'_'
      enterRuleAltList: 'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'_'
        enterLabeledAlt: 'a'
          enterAlternative: 'a'
            enterElement: 'a'
              => element -> a
              enterAtom: 'a'
                enterTerminal: 'a'
                exitTerminal: 'a'
              exitAtom: 'a'
            exitElement: 'a'
          exitAlternative: 'a'
        => elements -> ['a']
            => alternative -> a
        exitLabeledAlt: 'a'
        enterLabeledAlt: 'b'
          enterAlternative: 'b'
            enterElement: 'b'
              => element -> b
              enterAtom: 'b'
                enterTerminal: 'b'
                exitTerminal: 'b'
              exitAtom: 'b'
            exitElement: 'b'
          exitAlternative: 'b'
        => elements -> ['b']
            => alternative -> b
        exitLabeledAlt: 'b'
        enterLabeledAlt: 'c'
          enterAlternative: 'c'
            enterElement: 'c'
              => element -> c
              enterAtom: 'c'
                enterTerminal: 'c'
                exitTerminal: 'c'
              exitAtom: 'c'
            exitElement: 'c'
          exitAlternative: 'c'
        => elements -> ['c']
            => alternative -> c
        exitLabeledAlt: 'c'
        enterLabeledAlt: 'd'
          enterAlternative: 'd'
            enterElement: 'd'
              => element -> d
              enterAtom: 'd'
                enterTerminal: 'd'
                exitTerminal: 'd'
              exitAtom: 'd'
            exitElement: 'd'
          exitAlternative: 'd'
        => elements -> ['d']
            => alternative -> d
        exitLabeledAlt: 'd'
        enterLabeledAlt: 'e'
          enterAlternative: 'e'
            enterElement: 'e'
              => element -> e
              enterAtom: 'e'
                enterTerminal: 'e'
                exitTerminal: 'e'
              exitAtom: 'e'
            exitElement: 'e'
          exitAlternative: 'e'
        => elements -> ['e']
            => alternative -> e
        exitLabeledAlt: 'e'
        enterLabeledAlt: 'f'
          enterAlternative: 'f'
            enterElement: 'f'
              => element -> f
              enterAtom: 'f'
                enterTerminal: 'f'
                exitTerminal: 'f'
              exitAtom: 'f'
            exitElement: 'f'
          exitAlternative: 'f'
        => elements -> ['f']
            => alternative -> f
        exitLabeledAlt: 'f'
        enterLabeledAlt: 'g'
          enterAlternative: 'g'
            enterElement: 'g'
              => element -> g
              enterAtom: 'g'
                enterTerminal: 'g'
                exitTerminal: 'g'
              exitAtom: 'g'
            exitElement: 'g'
          exitAlternative: 'g'
        => elements -> ['g']
            => alternative -> g
        exitLabeledAlt: 'g'
        enterLabeledAlt: 'h'
          enterAlternative: 'h'
            enterElement: 'h'
              => element -> h
              enterAtom: 'h'
                enterTerminal: 'h'
                exitTerminal: 'h'
              exitAtom: 'h'
            exitElement: 'h'
          exitAlternative: 'h'
        => elements -> ['h']
            => alternative -> h
        exitLabeledAlt: 'h'
        enterLabeledAlt: 'i'
          enterAlternative: 'i'
            enterElement: 'i'
              => element -> i
              enterAtom: 'i'
                enterTerminal: 'i'
                exitTerminal: 'i'
              exitAtom: 'i'
            exitElement: 'i'
          exitAlternative: 'i'
        => elements -> ['i']
            => alternative -> i
        exitLabeledAlt: 'i'
        enterLabeledAlt: 'j'
          enterAlternative: 'j'
            enterElement: 'j'
              => element -> j
              enterAtom: 'j'
                enterTerminal: 'j'
                exitTerminal: 'j'
              exitAtom: 'j'
            exitElement: 'j'
          exitAlternative: 'j'
        => elements -> ['j']
            => alternative -> j
        exitLabeledAlt: 'j'
        enterLabeledAlt: 'k'
          enterAlternative: 'k'
            enterElement: 'k'
              => element -> k
              enterAtom: 'k'
                enterTerminal: 'k'
                exitTerminal: 'k'
              exitAtom: 'k'
            exitElement: 'k'
          exitAlternative: 'k'
        => elements -> ['k']
            => alternative -> k
        exitLabeledAlt: 'k'
        enterLabeledAlt: 'l'
          enterAlternative: 'l'
            enterElement: 'l'
              => element -> l
              enterAtom: 'l'
                enterTerminal: 'l'
                exitTerminal: 'l'
              exitAtom: 'l'
            exitElement: 'l'
          exitAlternative: 'l'
        => elements -> ['l']
            => alternative -> l
        exitLabeledAlt: 'l'
        enterLabeledAlt: 'm'
          enterAlternative: 'm'
            enterElement: 'm'
              => element -> m
              enterAtom: 'm'
                enterTerminal: 'm'
                exitTerminal: 'm'
              exitAtom: 'm'
            exitElement: 'm'
          exitAlternative: 'm'
        => elements -> ['m']
            => alternative -> m
        exitLabeledAlt: 'm'
        enterLabeledAlt: 'n'
          enterAlternative: 'n'
            enterElement: 'n'
              => element -> n
              enterAtom: 'n'
                enterTerminal: 'n'
                exitTerminal: 'n'
              exitAtom: 'n'
            exitElement: 'n'
          exitAlternative: 'n'
        => elements -> ['n']
            => alternative -> n
        exitLabeledAlt: 'n'
        enterLabeledAlt: 'o'
          enterAlternative: 'o'
            enterElement: 'o'
              => element -> o
              enterAtom: 'o'
                enterTerminal: 'o'
                exitTerminal: 'o'
              exitAtom: 'o'
            exitElement: 'o'
          exitAlternative: 'o'
        => elements -> ['o']
            => alternative -> o
        exitLabeledAlt: 'o'
        enterLabeledAlt: 'p'
          enterAlternative: 'p'
            enterElement: 'p'
              => element -> p
              enterAtom: 'p'
                enterTerminal: 'p'
                exitTerminal: 'p'
              exitAtom: 'p'
            exitElement: 'p'
          exitAlternative: 'p'
        => elements -> ['p']
            => alternative -> p
        exitLabeledAlt: 'p'
        enterLabeledAlt: 'q'
          enterAlternative: 'q'
            enterElement: 'q'
              => element -> q
              enterAtom: 'q'
                enterTerminal: 'q'
                exitTerminal: 'q'
              exitAtom: 'q'
            exitElement: 'q'
          exitAlternative: 'q'
        => elements -> ['q']
            => alternative -> q
        exitLabeledAlt: 'q'
        enterLabeledAlt: 'r'
          enterAlternative: 'r'
            enterElement: 'r'
              => element -> r
              enterAtom: 'r'
                enterTerminal: 'r'
                exitTerminal: 'r'
              exitAtom: 'r'
            exitElement: 'r'
          exitAlternative: 'r'
        => elements -> ['r']
            => alternative -> r
        exitLabeledAlt: 'r'
        enterLabeledAlt: 's'
          enterAlternative: 's'
            enterElement: 's'
              => element -> s
              enterAtom: 's'
                enterTerminal: 's'
                exitTerminal: 's'
              exitAtom: 's'
            exitElement: 's'
          exitAlternative: 's'
        => elements -> ['s']
            => alternative -> s
        exitLabeledAlt: 's'
        enterLabeledAlt: 't'
          enterAlternative: 't'
            enterElement: 't'
              => element -> t
              enterAtom: 't'
                enterTerminal: 't'
                exitTerminal: 't'
              exitAtom: 't'
            exitElement: 't'
          exitAlternative: 't'
        => elements -> ['t']
            => alternative -> t
        exitLabeledAlt: 't'
        enterLabeledAlt: 'u'
          enterAlternative: 'u'
            enterElement: 'u'
              => element -> u
              enterAtom: 'u'
                enterTerminal: 'u'
                exitTerminal: 'u'
              exitAtom: 'u'
            exitElement: 'u'
          exitAlternative: 'u'
        => elements -> ['u']
            => alternative -> u
        exitLabeledAlt: 'u'
        enterLabeledAlt: 'v'
          enterAlternative: 'v'
            enterElement: 'v'
              => element -> v
              enterAtom: 'v'
                enterTerminal: 'v'
                exitTerminal: 'v'
              exitAtom: 'v'
            exitElement: 'v'
          exitAlternative: 'v'
        => elements -> ['v']
            => alternative -> v
        exitLabeledAlt: 'v'
        enterLabeledAlt: 'w'
          enterAlternative: 'w'
            enterElement: 'w'
              => element -> w
              enterAtom: 'w'
                enterTerminal: 'w'
                exitTerminal: 'w'
              exitAtom: 'w'
            exitElement: 'w'
          exitAlternative: 'w'
        => elements -> ['w']
            => alternative -> w
        exitLabeledAlt: 'w'
        enterLabeledAlt: 'x'
          enterAlternative: 'x'
            enterElement: 'x'
              => element -> x
              enterAtom: 'x'
                enterTerminal: 'x'
                exitTerminal: 'x'
              exitAtom: 'x'
            exitElement: 'x'
          exitAlternative: 'x'
        => elements -> ['x']
            => alternative -> x
        exitLabeledAlt: 'x'
        enterLabeledAlt: 'y'
          enterAlternative: 'y'
            enterElement: 'y'
              => element -> y
              enterAtom: 'y'
                enterTerminal: 'y'
                exitTerminal: 'y'
              exitAtom: 'y'
            exitElement: 'y'
          exitAlternative: 'y'
        => elements -> ['y']
            => alternative -> y
        exitLabeledAlt: 'y'
        enterLabeledAlt: 'z'
          enterAlternative: 'z'
            enterElement: 'z'
              => element -> z
              enterAtom: 'z'
                enterTerminal: 'z'
                exitTerminal: 'z'
              exitAtom: 'z'
            exitElement: 'z'
          exitAlternative: 'z'
        => elements -> ['z']
            => alternative -> z
        exitLabeledAlt: 'z'
        enterLabeledAlt: 'A'
          enterAlternative: 'A'
            enterElement: 'A'
              => element -> A
              enterAtom: 'A'
                enterTerminal: 'A'
                exitTerminal: 'A'
              exitAtom: 'A'
            exitElement: 'A'
          exitAlternative: 'A'
        => elements -> ['A']
            => alternative -> A
        exitLabeledAlt: 'A'
        enterLabeledAlt: 'B'
          enterAlternative: 'B'
            enterElement: 'B'
              => element -> B
              enterAtom: 'B'
                enterTerminal: 'B'
                exitTerminal: 'B'
              exitAtom: 'B'
            exitElement: 'B'
          exitAlternative: 'B'
        => elements -> ['B']
            => alternative -> B
        exitLabeledAlt: 'B'
        enterLabeledAlt: 'C'
          enterAlternative: 'C'
            enterElement: 'C'
              => element -> C
              enterAtom: 'C'
                enterTerminal: 'C'
                exitTerminal: 'C'
              exitAtom: 'C'
            exitElement: 'C'
          exitAlternative: 'C'
        => elements -> ['C']
            => alternative -> C
        exitLabeledAlt: 'C'
        enterLabeledAlt: 'D'
          enterAlternative: 'D'
            enterElement: 'D'
              => element -> D
              enterAtom: 'D'
                enterTerminal: 'D'
                exitTerminal: 'D'
              exitAtom: 'D'
            exitElement: 'D'
          exitAlternative: 'D'
        => elements -> ['D']
            => alternative -> D
        exitLabeledAlt: 'D'
        enterLabeledAlt: 'E'
          enterAlternative: 'E'
            enterElement: 'E'
              => element -> E
              enterAtom: 'E'
                enterTerminal: 'E'
                exitTerminal: 'E'
              exitAtom: 'E'
            exitElement: 'E'
          exitAlternative: 'E'
        => elements -> ['E']
            => alternative -> E
        exitLabeledAlt: 'E'
        enterLabeledAlt: 'F'
          enterAlternative: 'F'
            enterElement: 'F'
              => element -> F
              enterAtom: 'F'
                enterTerminal: 'F'
                exitTerminal: 'F'
              exitAtom: 'F'
            exitElement: 'F'
          exitAlternative: 'F'
        => elements -> ['F']
            => alternative -> F
        exitLabeledAlt: 'F'
        enterLabeledAlt: 'G'
          enterAlternative: 'G'
            enterElement: 'G'
              => element -> G
              enterAtom: 'G'
                enterTerminal: 'G'
                exitTerminal: 'G'
              exitAtom: 'G'
            exitElement: 'G'
          exitAlternative: 'G'
        => elements -> ['G']
            => alternative -> G
        exitLabeledAlt: 'G'
        enterLabeledAlt: 'H'
          enterAlternative: 'H'
            enterElement: 'H'
              => element -> H
              enterAtom: 'H'
                enterTerminal: 'H'
                exitTerminal: 'H'
              exitAtom: 'H'
            exitElement: 'H'
          exitAlternative: 'H'
        => elements -> ['H']
            => alternative -> H
        exitLabeledAlt: 'H'
        enterLabeledAlt: 'I'
          enterAlternative: 'I'
            enterElement: 'I'
              => element -> I
              enterAtom: 'I'
                enterTerminal: 'I'
                exitTerminal: 'I'
              exitAtom: 'I'
            exitElement: 'I'
          exitAlternative: 'I'
        => elements -> ['I']
            => alternative -> I
        exitLabeledAlt: 'I'
        enterLabeledAlt: 'J'
          enterAlternative: 'J'
            enterElement: 'J'
              => element -> J
              enterAtom: 'J'
                enterTerminal: 'J'
                exitTerminal: 'J'
              exitAtom: 'J'
            exitElement: 'J'
          exitAlternative: 'J'
        => elements -> ['J']
            => alternative -> J
        exitLabeledAlt: 'J'
        enterLabeledAlt: 'K'
          enterAlternative: 'K'
            enterElement: 'K'
              => element -> K
              enterAtom: 'K'
                enterTerminal: 'K'
                exitTerminal: 'K'
              exitAtom: 'K'
            exitElement: 'K'
          exitAlternative: 'K'
        => elements -> ['K']
            => alternative -> K
        exitLabeledAlt: 'K'
        enterLabeledAlt: 'L'
          enterAlternative: 'L'
            enterElement: 'L'
              => element -> L
              enterAtom: 'L'
                enterTerminal: 'L'
                exitTerminal: 'L'
              exitAtom: 'L'
            exitElement: 'L'
          exitAlternative: 'L'
        => elements -> ['L']
            => alternative -> L
        exitLabeledAlt: 'L'
        enterLabeledAlt: 'M'
          enterAlternative: 'M'
            enterElement: 'M'
              => element -> M
              enterAtom: 'M'
                enterTerminal: 'M'
                exitTerminal: 'M'
              exitAtom: 'M'
            exitElement: 'M'
          exitAlternative: 'M'
        => elements -> ['M']
            => alternative -> M
        exitLabeledAlt: 'M'
        enterLabeledAlt: 'N'
          enterAlternative: 'N'
            enterElement: 'N'
              => element -> N
              enterAtom: 'N'
                enterTerminal: 'N'
                exitTerminal: 'N'
              exitAtom: 'N'
            exitElement: 'N'
          exitAlternative: 'N'
        => elements -> ['N']
            => alternative -> N
        exitLabeledAlt: 'N'
        enterLabeledAlt: 'O'
          enterAlternative: 'O'
            enterElement: 'O'
              => element -> O
              enterAtom: 'O'
                enterTerminal: 'O'
                exitTerminal: 'O'
              exitAtom: 'O'
            exitElement: 'O'
          exitAlternative: 'O'
        => elements -> ['O']
            => alternative -> O
        exitLabeledAlt: 'O'
        enterLabeledAlt: 'P'
          enterAlternative: 'P'
            enterElement: 'P'
              => element -> P
              enterAtom: 'P'
                enterTerminal: 'P'
                exitTerminal: 'P'
              exitAtom: 'P'
            exitElement: 'P'
          exitAlternative: 'P'
        => elements -> ['P']
            => alternative -> P
        exitLabeledAlt: 'P'
        enterLabeledAlt: 'Q'
          enterAlternative: 'Q'
            enterElement: 'Q'
              => element -> Q
              enterAtom: 'Q'
                enterTerminal: 'Q'
                exitTerminal: 'Q'
              exitAtom: 'Q'
            exitElement: 'Q'
          exitAlternative: 'Q'
        => elements -> ['Q']
            => alternative -> Q
        exitLabeledAlt: 'Q'
        enterLabeledAlt: 'R'
          enterAlternative: 'R'
            enterElement: 'R'
              => element -> R
              enterAtom: 'R'
                enterTerminal: 'R'
                exitTerminal: 'R'
              exitAtom: 'R'
            exitElement: 'R'
          exitAlternative: 'R'
        => elements -> ['R']
            => alternative -> R
        exitLabeledAlt: 'R'
        enterLabeledAlt: 'S'
          enterAlternative: 'S'
            enterElement: 'S'
              => element -> S
              enterAtom: 'S'
                enterTerminal: 'S'
                exitTerminal: 'S'
              exitAtom: 'S'
            exitElement: 'S'
          exitAlternative: 'S'
        => elements -> ['S']
            => alternative -> S
        exitLabeledAlt: 'S'
        enterLabeledAlt: 'T'
          enterAlternative: 'T'
            enterElement: 'T'
              => element -> T
              enterAtom: 'T'
                enterTerminal: 'T'
                exitTerminal: 'T'
              exitAtom: 'T'
            exitElement: 'T'
          exitAlternative: 'T'
        => elements -> ['T']
            => alternative -> T
        exitLabeledAlt: 'T'
        enterLabeledAlt: 'U'
          enterAlternative: 'U'
            enterElement: 'U'
              => element -> U
              enterAtom: 'U'
                enterTerminal: 'U'
                exitTerminal: 'U'
              exitAtom: 'U'
            exitElement: 'U'
          exitAlternative: 'U'
        => elements -> ['U']
            => alternative -> U
        exitLabeledAlt: 'U'
        enterLabeledAlt: 'V'
          enterAlternative: 'V'
            enterElement: 'V'
              => element -> V
              enterAtom: 'V'
                enterTerminal: 'V'
                exitTerminal: 'V'
              exitAtom: 'V'
            exitElement: 'V'
          exitAlternative: 'V'
        => elements -> ['V']
            => alternative -> V
        exitLabeledAlt: 'V'
        enterLabeledAlt: 'W'
          enterAlternative: 'W'
            enterElement: 'W'
              => element -> W
              enterAtom: 'W'
                enterTerminal: 'W'
                exitTerminal: 'W'
              exitAtom: 'W'
            exitElement: 'W'
          exitAlternative: 'W'
        => elements -> ['W']
            => alternative -> W
        exitLabeledAlt: 'W'
        enterLabeledAlt: 'X'
          enterAlternative: 'X'
            enterElement: 'X'
              => element -> X
              enterAtom: 'X'
                enterTerminal: 'X'
                exitTerminal: 'X'
              exitAtom: 'X'
            exitElement: 'X'
          exitAlternative: 'X'
        => elements -> ['X']
            => alternative -> X
        exitLabeledAlt: 'X'
        enterLabeledAlt: 'Y'
          enterAlternative: 'Y'
            enterElement: 'Y'
              => element -> Y
              enterAtom: 'Y'
                enterTerminal: 'Y'
                exitTerminal: 'Y'
              exitAtom: 'Y'
            exitElement: 'Y'
          exitAlternative: 'Y'
        => elements -> ['Y']
            => alternative -> Y
        exitLabeledAlt: 'Y'
        enterLabeledAlt: 'Z'
          enterAlternative: 'Z'
            enterElement: 'Z'
              => element -> Z
              enterAtom: 'Z'
                enterTerminal: 'Z'
                exitTerminal: 'Z'
              exitAtom: 'Z'
            exitElement: 'Z'
          exitAlternative: 'Z'
        => elements -> ['Z']
            => alternative -> Z
        exitLabeledAlt: 'Z'
        enterLabeledAlt: '_'
          enterAlternative: '_'
            enterElement: '_'
              => element -> _
              enterAtom: '_'
                enterTerminal: '_'
                exitTerminal: '_'
              exitAtom: '_'
            exitElement: '_'
          exitAlternative: '_'
        => elements -> ['_']
            => alternative -> _
        exitLabeledAlt: '_'
      exitRuleAltList: 'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'_'
    exitRuleBlock: 'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'_'
  exitRuleSpec: nondigit:'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'_';

  enterRuleSpec: digit:'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9';
    enterRuleBlock: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
      enterRuleAltList: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
        enterLabeledAlt: '0'
          enterAlternative: '0'
            enterElement: '0'
              => element -> 0
              enterAtom: '0'
                enterTerminal: '0'
                exitTerminal: '0'
              exitAtom: '0'
            exitElement: '0'
          exitAlternative: '0'
        => elements -> ['0']
            => alternative -> 0
        exitLabeledAlt: '0'
        enterLabeledAlt: '1'
          enterAlternative: '1'
            enterElement: '1'
              => element -> 1
              enterAtom: '1'
                enterTerminal: '1'
                exitTerminal: '1'
              exitAtom: '1'
            exitElement: '1'
          exitAlternative: '1'
        => elements -> ['1']
            => alternative -> 1
        exitLabeledAlt: '1'
        enterLabeledAlt: '2'
          enterAlternative: '2'
            enterElement: '2'
              => element -> 2
              enterAtom: '2'
                enterTerminal: '2'
                exitTerminal: '2'
              exitAtom: '2'
            exitElement: '2'
          exitAlternative: '2'
        => elements -> ['2']
            => alternative -> 2
        exitLabeledAlt: '2'
        enterLabeledAlt: '3'
          enterAlternative: '3'
            enterElement: '3'
              => element -> 3
              enterAtom: '3'
                enterTerminal: '3'
                exitTerminal: '3'
              exitAtom: '3'
            exitElement: '3'
          exitAlternative: '3'
        => elements -> ['3']
            => alternative -> 3
        exitLabeledAlt: '3'
        enterLabeledAlt: '4'
          enterAlternative: '4'
            enterElement: '4'
              => element -> 4
              enterAtom: '4'
                enterTerminal: '4'
                exitTerminal: '4'
              exitAtom: '4'
            exitElement: '4'
          exitAlternative: '4'
        => elements -> ['4']
            => alternative -> 4
        exitLabeledAlt: '4'
        enterLabeledAlt: '5'
          enterAlternative: '5'
            enterElement: '5'
              => element -> 5
              enterAtom: '5'
                enterTerminal: '5'
                exitTerminal: '5'
              exitAtom: '5'
            exitElement: '5'
          exitAlternative: '5'
        => elements -> ['5']
            => alternative -> 5
        exitLabeledAlt: '5'
        enterLabeledAlt: '6'
          enterAlternative: '6'
            enterElement: '6'
              => element -> 6
              enterAtom: '6'
                enterTerminal: '6'
                exitTerminal: '6'
              exitAtom: '6'
            exitElement: '6'
          exitAlternative: '6'
        => elements -> ['6']
            => alternative -> 6
        exitLabeledAlt: '6'
        enterLabeledAlt: '7'
          enterAlternative: '7'
            enterElement: '7'
              => element -> 7
              enterAtom: '7'
                enterTerminal: '7'
                exitTerminal: '7'
              exitAtom: '7'
            exitElement: '7'
          exitAlternative: '7'
        => elements -> ['7']
            => alternative -> 7
        exitLabeledAlt: '7'
        enterLabeledAlt: '8'
          enterAlternative: '8'
            enterElement: '8'
              => element -> 8
              enterAtom: '8'
                enterTerminal: '8'
                exitTerminal: '8'
              exitAtom: '8'
            exitElement: '8'
          exitAlternative: '8'
        => elements -> ['8']
            => alternative -> 8
        exitLabeledAlt: '8'
        enterLabeledAlt: '9'
          enterAlternative: '9'
            enterElement: '9'
              => element -> 9
              enterAtom: '9'
                enterTerminal: '9'
                exitTerminal: '9'
              exitAtom: '9'
            exitElement: '9'
          exitAlternative: '9'
        => elements -> ['9']
            => alternative -> 9
        exitLabeledAlt: '9'
      exitRuleAltList: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
    exitRuleBlock: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
  exitRuleSpec: digit:'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9';

  enterRuleSpec: keyword:'alignas'|'alignof'|'asm'|'auto'|'bool'|'break'|'case'|'catch'|'char'|'char8_t'|'char16_t'|'char32_t'|'class'|'concept'|'const'|'consteval'|'constexpr'|'constinit'|'const_cast'|'continue'|'co_await'|'co_return'|'co_yield'|'decltype'|'default'|'delete'|'do'|'double'|'dynamic_cast'|'else'|'enum'|'explicit'|'export'|'extern'|'false'|'float'|'for'|'friend'|'goto'|'if'|'inline'|'int'|'long'|'mutable'|'namespace'|'new'|'noexcept'|'nullptr'|'operator'|'private'|'protected'|'public'|'register'|'reinterpret_cast'|'requires'|'return'|'short'|'signed'|'sizeof'|'static'|'static_assert'|'static_cast'|'struct'|'switch'|'template'|'this'|'thread_local'|'throw'|'true'|'try'|'typedef'|'typeid'|'typename'|'union'|'unsigned'|'using'|'virtual'|'void'|'volatile'|'wchar_t'|'while'|import-keyword|module-keyword|export-keyword;
    enterRuleBlock: 'alignas'|'alignof'|'asm'|'auto'|'bool'|'break'|'case'|'catch'|'char'|'char8_t'|'char16_t'|'char32_t'|'class'|'concept'|'const'|'consteval'|'constexpr'|'constinit'|'const_cast'|'continue'|'co_await'|'co_return'|'co_yield'|'decltype'|'default'|'delete'|'do'|'double'|'dynamic_cast'|'else'|'enum'|'explicit'|'export'|'extern'|'false'|'float'|'for'|'friend'|'goto'|'if'|'inline'|'int'|'long'|'mutable'|'namespace'|'new'|'noexcept'|'nullptr'|'operator'|'private'|'protected'|'public'|'register'|'reinterpret_cast'|'requires'|'return'|'short'|'signed'|'sizeof'|'static'|'static_assert'|'static_cast'|'struct'|'switch'|'template'|'this'|'thread_local'|'throw'|'true'|'try'|'typedef'|'typeid'|'typename'|'union'|'unsigned'|'using'|'virtual'|'void'|'volatile'|'wchar_t'|'while'|import-keyword|module-keyword|export-keyword
      enterRuleAltList: 'alignas'|'alignof'|'asm'|'auto'|'bool'|'break'|'case'|'catch'|'char'|'char8_t'|'char16_t'|'char32_t'|'class'|'concept'|'const'|'consteval'|'constexpr'|'constinit'|'const_cast'|'continue'|'co_await'|'co_return'|'co_yield'|'decltype'|'default'|'delete'|'do'|'double'|'dynamic_cast'|'else'|'enum'|'explicit'|'export'|'extern'|'false'|'float'|'for'|'friend'|'goto'|'if'|'inline'|'int'|'long'|'mutable'|'namespace'|'new'|'noexcept'|'nullptr'|'operator'|'private'|'protected'|'public'|'register'|'reinterpret_cast'|'requires'|'return'|'short'|'signed'|'sizeof'|'static'|'static_assert'|'static_cast'|'struct'|'switch'|'template'|'this'|'thread_local'|'throw'|'true'|'try'|'typedef'|'typeid'|'typename'|'union'|'unsigned'|'using'|'virtual'|'void'|'volatile'|'wchar_t'|'while'|import-keyword|module-keyword|export-keyword
        enterLabeledAlt: 'alignas'
          enterAlternative: 'alignas'
            enterElement: 'alignas'
              => element -> alignas
              enterAtom: 'alignas'
                enterTerminal: 'alignas'
                exitTerminal: 'alignas'
              exitAtom: 'alignas'
            exitElement: 'alignas'
          exitAlternative: 'alignas'
        => elements -> ['alignas']
            => alternative -> alignas
        exitLabeledAlt: 'alignas'
        enterLabeledAlt: 'alignof'
          enterAlternative: 'alignof'
            enterElement: 'alignof'
              => element -> alignof
              enterAtom: 'alignof'
                enterTerminal: 'alignof'
                exitTerminal: 'alignof'
              exitAtom: 'alignof'
            exitElement: 'alignof'
          exitAlternative: 'alignof'
        => elements -> ['alignof']
            => alternative -> alignof
        exitLabeledAlt: 'alignof'
        enterLabeledAlt: 'asm'
          enterAlternative: 'asm'
            enterElement: 'asm'
              => element -> asm
              enterAtom: 'asm'
                enterTerminal: 'asm'
                exitTerminal: 'asm'
              exitAtom: 'asm'
            exitElement: 'asm'
          exitAlternative: 'asm'
        => elements -> ['asm']
            => alternative -> asm
        exitLabeledAlt: 'asm'
        enterLabeledAlt: 'auto'
          enterAlternative: 'auto'
            enterElement: 'auto'
              => element -> auto
              enterAtom: 'auto'
                enterTerminal: 'auto'
                exitTerminal: 'auto'
              exitAtom: 'auto'
            exitElement: 'auto'
          exitAlternative: 'auto'
        => elements -> ['auto']
            => alternative -> auto
        exitLabeledAlt: 'auto'
        enterLabeledAlt: 'bool'
          enterAlternative: 'bool'
            enterElement: 'bool'
              => element -> bool
              enterAtom: 'bool'
                enterTerminal: 'bool'
                exitTerminal: 'bool'
              exitAtom: 'bool'
            exitElement: 'bool'
          exitAlternative: 'bool'
        => elements -> ['bool']
            => alternative -> bool
        exitLabeledAlt: 'bool'
        enterLabeledAlt: 'break'
          enterAlternative: 'break'
            enterElement: 'break'
              => element -> break
              enterAtom: 'break'
                enterTerminal: 'break'
                exitTerminal: 'break'
              exitAtom: 'break'
            exitElement: 'break'
          exitAlternative: 'break'
        => elements -> ['break']
            => alternative -> break
        exitLabeledAlt: 'break'
        enterLabeledAlt: 'case'
          enterAlternative: 'case'
            enterElement: 'case'
              => element -> case
              enterAtom: 'case'
                enterTerminal: 'case'
                exitTerminal: 'case'
              exitAtom: 'case'
            exitElement: 'case'
          exitAlternative: 'case'
        => elements -> ['case']
            => alternative -> case
        exitLabeledAlt: 'case'
        enterLabeledAlt: 'catch'
          enterAlternative: 'catch'
            enterElement: 'catch'
              => element -> catch
              enterAtom: 'catch'
                enterTerminal: 'catch'
                exitTerminal: 'catch'
              exitAtom: 'catch'
            exitElement: 'catch'
          exitAlternative: 'catch'
        => elements -> ['catch']
            => alternative -> catch
        exitLabeledAlt: 'catch'
        enterLabeledAlt: 'char'
          enterAlternative: 'char'
            enterElement: 'char'
              => element -> char
              enterAtom: 'char'
                enterTerminal: 'char'
                exitTerminal: 'char'
              exitAtom: 'char'
            exitElement: 'char'
          exitAlternative: 'char'
        => elements -> ['char']
            => alternative -> char
        exitLabeledAlt: 'char'
        enterLabeledAlt: 'char8_t'
          enterAlternative: 'char8_t'
            enterElement: 'char8_t'
              => element -> char8_t
              enterAtom: 'char8_t'
                enterTerminal: 'char8_t'
                exitTerminal: 'char8_t'
              exitAtom: 'char8_t'
            exitElement: 'char8_t'
          exitAlternative: 'char8_t'
        => elements -> ['char8_t']
            => alternative -> char8_t
        exitLabeledAlt: 'char8_t'
        enterLabeledAlt: 'char16_t'
          enterAlternative: 'char16_t'
            enterElement: 'char16_t'
              => element -> char16_t
              enterAtom: 'char16_t'
                enterTerminal: 'char16_t'
                exitTerminal: 'char16_t'
              exitAtom: 'char16_t'
            exitElement: 'char16_t'
          exitAlternative: 'char16_t'
        => elements -> ['char16_t']
            => alternative -> char16_t
        exitLabeledAlt: 'char16_t'
        enterLabeledAlt: 'char32_t'
          enterAlternative: 'char32_t'
            enterElement: 'char32_t'
              => element -> char32_t
              enterAtom: 'char32_t'
                enterTerminal: 'char32_t'
                exitTerminal: 'char32_t'
              exitAtom: 'char32_t'
            exitElement: 'char32_t'
          exitAlternative: 'char32_t'
        => elements -> ['char32_t']
            => alternative -> char32_t
        exitLabeledAlt: 'char32_t'
        enterLabeledAlt: 'class'
          enterAlternative: 'class'
            enterElement: 'class'
              => element -> class
              enterAtom: 'class'
                enterTerminal: 'class'
                exitTerminal: 'class'
              exitAtom: 'class'
            exitElement: 'class'
          exitAlternative: 'class'
        => elements -> ['class']
            => alternative -> class
        exitLabeledAlt: 'class'
        enterLabeledAlt: 'concept'
          enterAlternative: 'concept'
            enterElement: 'concept'
              => element -> concept
              enterAtom: 'concept'
                enterTerminal: 'concept'
                exitTerminal: 'concept'
              exitAtom: 'concept'
            exitElement: 'concept'
          exitAlternative: 'concept'
        => elements -> ['concept']
            => alternative -> concept
        exitLabeledAlt: 'concept'
        enterLabeledAlt: 'const'
          enterAlternative: 'const'
            enterElement: 'const'
              => element -> const
              enterAtom: 'const'
                enterTerminal: 'const'
                exitTerminal: 'const'
              exitAtom: 'const'
            exitElement: 'const'
          exitAlternative: 'const'
        => elements -> ['const']
            => alternative -> const
        exitLabeledAlt: 'const'
        enterLabeledAlt: 'consteval'
          enterAlternative: 'consteval'
            enterElement: 'consteval'
              => element -> consteval
              enterAtom: 'consteval'
                enterTerminal: 'consteval'
                exitTerminal: 'consteval'
              exitAtom: 'consteval'
            exitElement: 'consteval'
          exitAlternative: 'consteval'
        => elements -> ['consteval']
            => alternative -> consteval
        exitLabeledAlt: 'consteval'
        enterLabeledAlt: 'constexpr'
          enterAlternative: 'constexpr'
            enterElement: 'constexpr'
              => element -> constexpr
              enterAtom: 'constexpr'
                enterTerminal: 'constexpr'
                exitTerminal: 'constexpr'
              exitAtom: 'constexpr'
            exitElement: 'constexpr'
          exitAlternative: 'constexpr'
        => elements -> ['constexpr']
            => alternative -> constexpr
        exitLabeledAlt: 'constexpr'
        enterLabeledAlt: 'constinit'
          enterAlternative: 'constinit'
            enterElement: 'constinit'
              => element -> constinit
              enterAtom: 'constinit'
                enterTerminal: 'constinit'
                exitTerminal: 'constinit'
              exitAtom: 'constinit'
            exitElement: 'constinit'
          exitAlternative: 'constinit'
        => elements -> ['constinit']
            => alternative -> constinit
        exitLabeledAlt: 'constinit'
        enterLabeledAlt: 'const_cast'
          enterAlternative: 'const_cast'
            enterElement: 'const_cast'
              => element -> const_cast
              enterAtom: 'const_cast'
                enterTerminal: 'const_cast'
                exitTerminal: 'const_cast'
              exitAtom: 'const_cast'
            exitElement: 'const_cast'
          exitAlternative: 'const_cast'
        => elements -> ['const_cast']
            => alternative -> const_cast
        exitLabeledAlt: 'const_cast'
        enterLabeledAlt: 'continue'
          enterAlternative: 'continue'
            enterElement: 'continue'
              => element -> continue
              enterAtom: 'continue'
                enterTerminal: 'continue'
                exitTerminal: 'continue'
              exitAtom: 'continue'
            exitElement: 'continue'
          exitAlternative: 'continue'
        => elements -> ['continue']
            => alternative -> continue
        exitLabeledAlt: 'continue'
        enterLabeledAlt: 'co_await'
          enterAlternative: 'co_await'
            enterElement: 'co_await'
              => element -> co_await
              enterAtom: 'co_await'
                enterTerminal: 'co_await'
                exitTerminal: 'co_await'
              exitAtom: 'co_await'
            exitElement: 'co_await'
          exitAlternative: 'co_await'
        => elements -> ['co_await']
            => alternative -> co_await
        exitLabeledAlt: 'co_await'
        enterLabeledAlt: 'co_return'
          enterAlternative: 'co_return'
            enterElement: 'co_return'
              => element -> co_return
              enterAtom: 'co_return'
                enterTerminal: 'co_return'
                exitTerminal: 'co_return'
              exitAtom: 'co_return'
            exitElement: 'co_return'
          exitAlternative: 'co_return'
        => elements -> ['co_return']
            => alternative -> co_return
        exitLabeledAlt: 'co_return'
        enterLabeledAlt: 'co_yield'
          enterAlternative: 'co_yield'
            enterElement: 'co_yield'
              => element -> co_yield
              enterAtom: 'co_yield'
                enterTerminal: 'co_yield'
                exitTerminal: 'co_yield'
              exitAtom: 'co_yield'
            exitElement: 'co_yield'
          exitAlternative: 'co_yield'
        => elements -> ['co_yield']
            => alternative -> co_yield
        exitLabeledAlt: 'co_yield'
        enterLabeledAlt: 'decltype'
          enterAlternative: 'decltype'
            enterElement: 'decltype'
              => element -> decltype
              enterAtom: 'decltype'
                enterTerminal: 'decltype'
                exitTerminal: 'decltype'
              exitAtom: 'decltype'
            exitElement: 'decltype'
          exitAlternative: 'decltype'
        => elements -> ['decltype']
            => alternative -> decltype
        exitLabeledAlt: 'decltype'
        enterLabeledAlt: 'default'
          enterAlternative: 'default'
            enterElement: 'default'
              => element -> default
              enterAtom: 'default'
                enterTerminal: 'default'
                exitTerminal: 'default'
              exitAtom: 'default'
            exitElement: 'default'
          exitAlternative: 'default'
        => elements -> ['default']
            => alternative -> default
        exitLabeledAlt: 'default'
        enterLabeledAlt: 'delete'
          enterAlternative: 'delete'
            enterElement: 'delete'
              => element -> delete
              enterAtom: 'delete'
                enterTerminal: 'delete'
                exitTerminal: 'delete'
              exitAtom: 'delete'
            exitElement: 'delete'
          exitAlternative: 'delete'
        => elements -> ['delete']
            => alternative -> delete
        exitLabeledAlt: 'delete'
        enterLabeledAlt: 'do'
          enterAlternative: 'do'
            enterElement: 'do'
              => element -> do
              enterAtom: 'do'
                enterTerminal: 'do'
                exitTerminal: 'do'
              exitAtom: 'do'
            exitElement: 'do'
          exitAlternative: 'do'
        => elements -> ['do']
            => alternative -> do
        exitLabeledAlt: 'do'
        enterLabeledAlt: 'double'
          enterAlternative: 'double'
            enterElement: 'double'
              => element -> double
              enterAtom: 'double'
                enterTerminal: 'double'
                exitTerminal: 'double'
              exitAtom: 'double'
            exitElement: 'double'
          exitAlternative: 'double'
        => elements -> ['double']
            => alternative -> double
        exitLabeledAlt: 'double'
        enterLabeledAlt: 'dynamic_cast'
          enterAlternative: 'dynamic_cast'
            enterElement: 'dynamic_cast'
              => element -> dynamic_cast
              enterAtom: 'dynamic_cast'
                enterTerminal: 'dynamic_cast'
                exitTerminal: 'dynamic_cast'
              exitAtom: 'dynamic_cast'
            exitElement: 'dynamic_cast'
          exitAlternative: 'dynamic_cast'
        => elements -> ['dynamic_cast']
            => alternative -> dynamic_cast
        exitLabeledAlt: 'dynamic_cast'
        enterLabeledAlt: 'else'
          enterAlternative: 'else'
            enterElement: 'else'
              => element -> else
              enterAtom: 'else'
                enterTerminal: 'else'
                exitTerminal: 'else'
              exitAtom: 'else'
            exitElement: 'else'
          exitAlternative: 'else'
        => elements -> ['else']
            => alternative -> else
        exitLabeledAlt: 'else'
        enterLabeledAlt: 'enum'
          enterAlternative: 'enum'
            enterElement: 'enum'
              => element -> enum
              enterAtom: 'enum'
                enterTerminal: 'enum'
                exitTerminal: 'enum'
              exitAtom: 'enum'
            exitElement: 'enum'
          exitAlternative: 'enum'
        => elements -> ['enum']
            => alternative -> enum
        exitLabeledAlt: 'enum'
        enterLabeledAlt: 'explicit'
          enterAlternative: 'explicit'
            enterElement: 'explicit'
              => element -> explicit
              enterAtom: 'explicit'
                enterTerminal: 'explicit'
                exitTerminal: 'explicit'
              exitAtom: 'explicit'
            exitElement: 'explicit'
          exitAlternative: 'explicit'
        => elements -> ['explicit']
            => alternative -> explicit
        exitLabeledAlt: 'explicit'
        enterLabeledAlt: 'export'
          enterAlternative: 'export'
            enterElement: 'export'
              => element -> export
              enterAtom: 'export'
                enterTerminal: 'export'
                exitTerminal: 'export'
              exitAtom: 'export'
            exitElement: 'export'
          exitAlternative: 'export'
        => elements -> ['export']
            => alternative -> export
        exitLabeledAlt: 'export'
        enterLabeledAlt: 'extern'
          enterAlternative: 'extern'
            enterElement: 'extern'
              => element -> extern
              enterAtom: 'extern'
                enterTerminal: 'extern'
                exitTerminal: 'extern'
              exitAtom: 'extern'
            exitElement: 'extern'
          exitAlternative: 'extern'
        => elements -> ['extern']
            => alternative -> extern
        exitLabeledAlt: 'extern'
        enterLabeledAlt: 'false'
          enterAlternative: 'false'
            enterElement: 'false'
              => element -> false
              enterAtom: 'false'
                enterTerminal: 'false'
                exitTerminal: 'false'
              exitAtom: 'false'
            exitElement: 'false'
          exitAlternative: 'false'
        => elements -> ['false']
            => alternative -> false
        exitLabeledAlt: 'false'
        enterLabeledAlt: 'float'
          enterAlternative: 'float'
            enterElement: 'float'
              => element -> float
              enterAtom: 'float'
                enterTerminal: 'float'
                exitTerminal: 'float'
              exitAtom: 'float'
            exitElement: 'float'
          exitAlternative: 'float'
        => elements -> ['float']
            => alternative -> float
        exitLabeledAlt: 'float'
        enterLabeledAlt: 'for'
          enterAlternative: 'for'
            enterElement: 'for'
              => element -> for
              enterAtom: 'for'
                enterTerminal: 'for'
                exitTerminal: 'for'
              exitAtom: 'for'
            exitElement: 'for'
          exitAlternative: 'for'
        => elements -> ['for']
            => alternative -> for
        exitLabeledAlt: 'for'
        enterLabeledAlt: 'friend'
          enterAlternative: 'friend'
            enterElement: 'friend'
              => element -> friend
              enterAtom: 'friend'
                enterTerminal: 'friend'
                exitTerminal: 'friend'
              exitAtom: 'friend'
            exitElement: 'friend'
          exitAlternative: 'friend'
        => elements -> ['friend']
            => alternative -> friend
        exitLabeledAlt: 'friend'
        enterLabeledAlt: 'goto'
          enterAlternative: 'goto'
            enterElement: 'goto'
              => element -> goto
              enterAtom: 'goto'
                enterTerminal: 'goto'
                exitTerminal: 'goto'
              exitAtom: 'goto'
            exitElement: 'goto'
          exitAlternative: 'goto'
        => elements -> ['goto']
            => alternative -> goto
        exitLabeledAlt: 'goto'
        enterLabeledAlt: 'if'
          enterAlternative: 'if'
            enterElement: 'if'
              => element -> if
              enterAtom: 'if'
                enterTerminal: 'if'
                exitTerminal: 'if'
              exitAtom: 'if'
            exitElement: 'if'
          exitAlternative: 'if'
        => elements -> ['if']
            => alternative -> if
        exitLabeledAlt: 'if'
        enterLabeledAlt: 'inline'
          enterAlternative: 'inline'
            enterElement: 'inline'
              => element -> inline
              enterAtom: 'inline'
                enterTerminal: 'inline'
                exitTerminal: 'inline'
              exitAtom: 'inline'
            exitElement: 'inline'
          exitAlternative: 'inline'
        => elements -> ['inline']
            => alternative -> inline
        exitLabeledAlt: 'inline'
        enterLabeledAlt: 'int'
          enterAlternative: 'int'
            enterElement: 'int'
              => element -> int
              enterAtom: 'int'
                enterTerminal: 'int'
                exitTerminal: 'int'
              exitAtom: 'int'
            exitElement: 'int'
          exitAlternative: 'int'
        => elements -> ['int']
            => alternative -> int
        exitLabeledAlt: 'int'
        enterLabeledAlt: 'long'
          enterAlternative: 'long'
            enterElement: 'long'
              => element -> long
              enterAtom: 'long'
                enterTerminal: 'long'
                exitTerminal: 'long'
              exitAtom: 'long'
            exitElement: 'long'
          exitAlternative: 'long'
        => elements -> ['long']
            => alternative -> long
        exitLabeledAlt: 'long'
        enterLabeledAlt: 'mutable'
          enterAlternative: 'mutable'
            enterElement: 'mutable'
              => element -> mutable
              enterAtom: 'mutable'
                enterTerminal: 'mutable'
                exitTerminal: 'mutable'
              exitAtom: 'mutable'
            exitElement: 'mutable'
          exitAlternative: 'mutable'
        => elements -> ['mutable']
            => alternative -> mutable
        exitLabeledAlt: 'mutable'
        enterLabeledAlt: 'namespace'
          enterAlternative: 'namespace'
            enterElement: 'namespace'
              => element -> namespace
              enterAtom: 'namespace'
                enterTerminal: 'namespace'
                exitTerminal: 'namespace'
              exitAtom: 'namespace'
            exitElement: 'namespace'
          exitAlternative: 'namespace'
        => elements -> ['namespace']
            => alternative -> namespace
        exitLabeledAlt: 'namespace'
        enterLabeledAlt: 'new'
          enterAlternative: 'new'
            enterElement: 'new'
              => element -> new
              enterAtom: 'new'
                enterTerminal: 'new'
                exitTerminal: 'new'
              exitAtom: 'new'
            exitElement: 'new'
          exitAlternative: 'new'
        => elements -> ['new']
            => alternative -> new
        exitLabeledAlt: 'new'
        enterLabeledAlt: 'noexcept'
          enterAlternative: 'noexcept'
            enterElement: 'noexcept'
              => element -> noexcept
              enterAtom: 'noexcept'
                enterTerminal: 'noexcept'
                exitTerminal: 'noexcept'
              exitAtom: 'noexcept'
            exitElement: 'noexcept'
          exitAlternative: 'noexcept'
        => elements -> ['noexcept']
            => alternative -> noexcept
        exitLabeledAlt: 'noexcept'
        enterLabeledAlt: 'nullptr'
          enterAlternative: 'nullptr'
            enterElement: 'nullptr'
              => element -> nullptr
              enterAtom: 'nullptr'
                enterTerminal: 'nullptr'
                exitTerminal: 'nullptr'
              exitAtom: 'nullptr'
            exitElement: 'nullptr'
          exitAlternative: 'nullptr'
        => elements -> ['nullptr']
            => alternative -> nullptr
        exitLabeledAlt: 'nullptr'
        enterLabeledAlt: 'operator'
          enterAlternative: 'operator'
            enterElement: 'operator'
              => element -> operator
              enterAtom: 'operator'
                enterTerminal: 'operator'
                exitTerminal: 'operator'
              exitAtom: 'operator'
            exitElement: 'operator'
          exitAlternative: 'operator'
        => elements -> ['operator']
            => alternative -> operator
        exitLabeledAlt: 'operator'
        enterLabeledAlt: 'private'
          enterAlternative: 'private'
            enterElement: 'private'
              => element -> private
              enterAtom: 'private'
                enterTerminal: 'private'
                exitTerminal: 'private'
              exitAtom: 'private'
            exitElement: 'private'
          exitAlternative: 'private'
        => elements -> ['private']
            => alternative -> private
        exitLabeledAlt: 'private'
        enterLabeledAlt: 'protected'
          enterAlternative: 'protected'
            enterElement: 'protected'
              => element -> protected
              enterAtom: 'protected'
                enterTerminal: 'protected'
                exitTerminal: 'protected'
              exitAtom: 'protected'
            exitElement: 'protected'
          exitAlternative: 'protected'
        => elements -> ['protected']
            => alternative -> protected
        exitLabeledAlt: 'protected'
        enterLabeledAlt: 'public'
          enterAlternative: 'public'
            enterElement: 'public'
              => element -> public
              enterAtom: 'public'
                enterTerminal: 'public'
                exitTerminal: 'public'
              exitAtom: 'public'
            exitElement: 'public'
          exitAlternative: 'public'
        => elements -> ['public']
            => alternative -> public
        exitLabeledAlt: 'public'
        enterLabeledAlt: 'register'
          enterAlternative: 'register'
            enterElement: 'register'
              => element -> register
              enterAtom: 'register'
                enterTerminal: 'register'
                exitTerminal: 'register'
              exitAtom: 'register'
            exitElement: 'register'
          exitAlternative: 'register'
        => elements -> ['register']
            => alternative -> register
        exitLabeledAlt: 'register'
        enterLabeledAlt: 'reinterpret_cast'
          enterAlternative: 'reinterpret_cast'
            enterElement: 'reinterpret_cast'
              => element -> reinterpret_cast
              enterAtom: 'reinterpret_cast'
                enterTerminal: 'reinterpret_cast'
                exitTerminal: 'reinterpret_cast'
              exitAtom: 'reinterpret_cast'
            exitElement: 'reinterpret_cast'
          exitAlternative: 'reinterpret_cast'
        => elements -> ['reinterpret_cast']
            => alternative -> reinterpret_cast
        exitLabeledAlt: 'reinterpret_cast'
        enterLabeledAlt: 'requires'
          enterAlternative: 'requires'
            enterElement: 'requires'
              => element -> requires
              enterAtom: 'requires'
                enterTerminal: 'requires'
                exitTerminal: 'requires'
              exitAtom: 'requires'
            exitElement: 'requires'
          exitAlternative: 'requires'
        => elements -> ['requires']
            => alternative -> requires
        exitLabeledAlt: 'requires'
        enterLabeledAlt: 'return'
          enterAlternative: 'return'
            enterElement: 'return'
              => element -> return
              enterAtom: 'return'
                enterTerminal: 'return'
                exitTerminal: 'return'
              exitAtom: 'return'
            exitElement: 'return'
          exitAlternative: 'return'
        => elements -> ['return']
            => alternative -> return
        exitLabeledAlt: 'return'
        enterLabeledAlt: 'short'
          enterAlternative: 'short'
            enterElement: 'short'
              => element -> short
              enterAtom: 'short'
                enterTerminal: 'short'
                exitTerminal: 'short'
              exitAtom: 'short'
            exitElement: 'short'
          exitAlternative: 'short'
        => elements -> ['short']
            => alternative -> short
        exitLabeledAlt: 'short'
        enterLabeledAlt: 'signed'
          enterAlternative: 'signed'
            enterElement: 'signed'
              => element -> signed
              enterAtom: 'signed'
                enterTerminal: 'signed'
                exitTerminal: 'signed'
              exitAtom: 'signed'
            exitElement: 'signed'
          exitAlternative: 'signed'
        => elements -> ['signed']
            => alternative -> signed
        exitLabeledAlt: 'signed'
        enterLabeledAlt: 'sizeof'
          enterAlternative: 'sizeof'
            enterElement: 'sizeof'
              => element -> sizeof
              enterAtom: 'sizeof'
                enterTerminal: 'sizeof'
                exitTerminal: 'sizeof'
              exitAtom: 'sizeof'
            exitElement: 'sizeof'
          exitAlternative: 'sizeof'
        => elements -> ['sizeof']
            => alternative -> sizeof
        exitLabeledAlt: 'sizeof'
        enterLabeledAlt: 'static'
          enterAlternative: 'static'
            enterElement: 'static'
              => element -> static
              enterAtom: 'static'
                enterTerminal: 'static'
                exitTerminal: 'static'
              exitAtom: 'static'
            exitElement: 'static'
          exitAlternative: 'static'
        => elements -> ['static']
            => alternative -> static
        exitLabeledAlt: 'static'
        enterLabeledAlt: 'static_assert'
          enterAlternative: 'static_assert'
            enterElement: 'static_assert'
              => element -> static_assert
              enterAtom: 'static_assert'
                enterTerminal: 'static_assert'
                exitTerminal: 'static_assert'
              exitAtom: 'static_assert'
            exitElement: 'static_assert'
          exitAlternative: 'static_assert'
        => elements -> ['static_assert']
            => alternative -> static_assert
        exitLabeledAlt: 'static_assert'
        enterLabeledAlt: 'static_cast'
          enterAlternative: 'static_cast'
            enterElement: 'static_cast'
              => element -> static_cast
              enterAtom: 'static_cast'
                enterTerminal: 'static_cast'
                exitTerminal: 'static_cast'
              exitAtom: 'static_cast'
            exitElement: 'static_cast'
          exitAlternative: 'static_cast'
        => elements -> ['static_cast']
            => alternative -> static_cast
        exitLabeledAlt: 'static_cast'
        enterLabeledAlt: 'struct'
          enterAlternative: 'struct'
            enterElement: 'struct'
              => element -> struct
              enterAtom: 'struct'
                enterTerminal: 'struct'
                exitTerminal: 'struct'
              exitAtom: 'struct'
            exitElement: 'struct'
          exitAlternative: 'struct'
        => elements -> ['struct']
            => alternative -> struct
        exitLabeledAlt: 'struct'
        enterLabeledAlt: 'switch'
          enterAlternative: 'switch'
            enterElement: 'switch'
              => element -> switch
              enterAtom: 'switch'
                enterTerminal: 'switch'
                exitTerminal: 'switch'
              exitAtom: 'switch'
            exitElement: 'switch'
          exitAlternative: 'switch'
        => elements -> ['switch']
            => alternative -> switch
        exitLabeledAlt: 'switch'
        enterLabeledAlt: 'template'
          enterAlternative: 'template'
            enterElement: 'template'
              => element -> template
              enterAtom: 'template'
                enterTerminal: 'template'
                exitTerminal: 'template'
              exitAtom: 'template'
            exitElement: 'template'
          exitAlternative: 'template'
        => elements -> ['template']
            => alternative -> template
        exitLabeledAlt: 'template'
        enterLabeledAlt: 'this'
          enterAlternative: 'this'
            enterElement: 'this'
              => element -> this
              enterAtom: 'this'
                enterTerminal: 'this'
                exitTerminal: 'this'
              exitAtom: 'this'
            exitElement: 'this'
          exitAlternative: 'this'
        => elements -> ['this']
            => alternative -> this
        exitLabeledAlt: 'this'
        enterLabeledAlt: 'thread_local'
          enterAlternative: 'thread_local'
            enterElement: 'thread_local'
              => element -> thread_local
              enterAtom: 'thread_local'
                enterTerminal: 'thread_local'
                exitTerminal: 'thread_local'
              exitAtom: 'thread_local'
            exitElement: 'thread_local'
          exitAlternative: 'thread_local'
        => elements -> ['thread_local']
            => alternative -> thread_local
        exitLabeledAlt: 'thread_local'
        enterLabeledAlt: 'throw'
          enterAlternative: 'throw'
            enterElement: 'throw'
              => element -> throw
              enterAtom: 'throw'
                enterTerminal: 'throw'
                exitTerminal: 'throw'
              exitAtom: 'throw'
            exitElement: 'throw'
          exitAlternative: 'throw'
        => elements -> ['throw']
            => alternative -> throw
        exitLabeledAlt: 'throw'
        enterLabeledAlt: 'true'
          enterAlternative: 'true'
            enterElement: 'true'
              => element -> true
              enterAtom: 'true'
                enterTerminal: 'true'
                exitTerminal: 'true'
              exitAtom: 'true'
            exitElement: 'true'
          exitAlternative: 'true'
        => elements -> ['true']
            => alternative -> true
        exitLabeledAlt: 'true'
        enterLabeledAlt: 'try'
          enterAlternative: 'try'
            enterElement: 'try'
              => element -> try
              enterAtom: 'try'
                enterTerminal: 'try'
                exitTerminal: 'try'
              exitAtom: 'try'
            exitElement: 'try'
          exitAlternative: 'try'
        => elements -> ['try']
            => alternative -> try
        exitLabeledAlt: 'try'
        enterLabeledAlt: 'typedef'
          enterAlternative: 'typedef'
            enterElement: 'typedef'
              => element -> typedef
              enterAtom: 'typedef'
                enterTerminal: 'typedef'
                exitTerminal: 'typedef'
              exitAtom: 'typedef'
            exitElement: 'typedef'
          exitAlternative: 'typedef'
        => elements -> ['typedef']
            => alternative -> typedef
        exitLabeledAlt: 'typedef'
        enterLabeledAlt: 'typeid'
          enterAlternative: 'typeid'
            enterElement: 'typeid'
              => element -> typeid
              enterAtom: 'typeid'
                enterTerminal: 'typeid'
                exitTerminal: 'typeid'
              exitAtom: 'typeid'
            exitElement: 'typeid'
          exitAlternative: 'typeid'
        => elements -> ['typeid']
            => alternative -> typeid
        exitLabeledAlt: 'typeid'
        enterLabeledAlt: 'typename'
          enterAlternative: 'typename'
            enterElement: 'typename'
              => element -> typename
              enterAtom: 'typename'
                enterTerminal: 'typename'
                exitTerminal: 'typename'
              exitAtom: 'typename'
            exitElement: 'typename'
          exitAlternative: 'typename'
        => elements -> ['typename']
            => alternative -> typename
        exitLabeledAlt: 'typename'
        enterLabeledAlt: 'union'
          enterAlternative: 'union'
            enterElement: 'union'
              => element -> union
              enterAtom: 'union'
                enterTerminal: 'union'
                exitTerminal: 'union'
              exitAtom: 'union'
            exitElement: 'union'
          exitAlternative: 'union'
        => elements -> ['union']
            => alternative -> union
        exitLabeledAlt: 'union'
        enterLabeledAlt: 'unsigned'
          enterAlternative: 'unsigned'
            enterElement: 'unsigned'
              => element -> unsigned
              enterAtom: 'unsigned'
                enterTerminal: 'unsigned'
                exitTerminal: 'unsigned'
              exitAtom: 'unsigned'
            exitElement: 'unsigned'
          exitAlternative: 'unsigned'
        => elements -> ['unsigned']
            => alternative -> unsigned
        exitLabeledAlt: 'unsigned'
        enterLabeledAlt: 'using'
          enterAlternative: 'using'
            enterElement: 'using'
              => element -> using
              enterAtom: 'using'
                enterTerminal: 'using'
                exitTerminal: 'using'
              exitAtom: 'using'
            exitElement: 'using'
          exitAlternative: 'using'
        => elements -> ['using']
            => alternative -> using
        exitLabeledAlt: 'using'
        enterLabeledAlt: 'virtual'
          enterAlternative: 'virtual'
            enterElement: 'virtual'
              => element -> virtual
              enterAtom: 'virtual'
                enterTerminal: 'virtual'
                exitTerminal: 'virtual'
              exitAtom: 'virtual'
            exitElement: 'virtual'
          exitAlternative: 'virtual'
        => elements -> ['virtual']
            => alternative -> virtual
        exitLabeledAlt: 'virtual'
        enterLabeledAlt: 'void'
          enterAlternative: 'void'
            enterElement: 'void'
              => element -> void
              enterAtom: 'void'
                enterTerminal: 'void'
                exitTerminal: 'void'
              exitAtom: 'void'
            exitElement: 'void'
          exitAlternative: 'void'
        => elements -> ['void']
            => alternative -> void
        exitLabeledAlt: 'void'
        enterLabeledAlt: 'volatile'
          enterAlternative: 'volatile'
            enterElement: 'volatile'
              => element -> volatile
              enterAtom: 'volatile'
                enterTerminal: 'volatile'
                exitTerminal: 'volatile'
              exitAtom: 'volatile'
            exitElement: 'volatile'
          exitAlternative: 'volatile'
        => elements -> ['volatile']
            => alternative -> volatile
        exitLabeledAlt: 'volatile'
        enterLabeledAlt: 'wchar_t'
          enterAlternative: 'wchar_t'
            enterElement: 'wchar_t'
              => element -> wchar_t
              enterAtom: 'wchar_t'
                enterTerminal: 'wchar_t'
                exitTerminal: 'wchar_t'
              exitAtom: 'wchar_t'
            exitElement: 'wchar_t'
          exitAlternative: 'wchar_t'
        => elements -> ['wchar_t']
            => alternative -> wchar_t
        exitLabeledAlt: 'wchar_t'
        enterLabeledAlt: 'while'
          enterAlternative: 'while'
            enterElement: 'while'
              => element -> while
              enterAtom: 'while'
                enterTerminal: 'while'
                exitTerminal: 'while'
              exitAtom: 'while'
            exitElement: 'while'
          exitAlternative: 'while'
        => elements -> ['while']
            => alternative -> while
        exitLabeledAlt: 'while'
        enterLabeledAlt: import-keyword
          enterAlternative: import-keyword
            enterElement: import-keyword
              => element -> {import-keyword}
              enterAtom: import-keyword
                enterRuleref: import-keyword
                exitRuleref: import-keyword
              exitAtom: import-keyword
            exitElement: import-keyword
          exitAlternative: import-keyword
        => elements -> ['{import-keyword}']
            => alternative -> {import-keyword}
        exitLabeledAlt: import-keyword
        enterLabeledAlt: module-keyword
          enterAlternative: module-keyword
            enterElement: module-keyword
              => element -> {module-keyword}
              enterAtom: module-keyword
                enterRuleref: module-keyword
                exitRuleref: module-keyword
              exitAtom: module-keyword
            exitElement: module-keyword
          exitAlternative: module-keyword
        => elements -> ['{module-keyword}']
            => alternative -> {module-keyword}
        exitLabeledAlt: module-keyword
        enterLabeledAlt: export-keyword
          enterAlternative: export-keyword
            enterElement: export-keyword
              => element -> {export-keyword}
              enterAtom: export-keyword
                enterRuleref: export-keyword
                exitRuleref: export-keyword
              exitAtom: export-keyword
            exitElement: export-keyword
          exitAlternative: export-keyword
        => elements -> ['{export-keyword}']
            => alternative -> {export-keyword}
        exitLabeledAlt: export-keyword
      exitRuleAltList: 'alignas'|'alignof'|'asm'|'auto'|'bool'|'break'|'case'|'catch'|'char'|'char8_t'|'char16_t'|'char32_t'|'class'|'concept'|'const'|'consteval'|'constexpr'|'constinit'|'const_cast'|'continue'|'co_await'|'co_return'|'co_yield'|'decltype'|'default'|'delete'|'do'|'double'|'dynamic_cast'|'else'|'enum'|'explicit'|'export'|'extern'|'false'|'float'|'for'|'friend'|'goto'|'if'|'inline'|'int'|'long'|'mutable'|'namespace'|'new'|'noexcept'|'nullptr'|'operator'|'private'|'protected'|'public'|'register'|'reinterpret_cast'|'requires'|'return'|'short'|'signed'|'sizeof'|'static'|'static_assert'|'static_cast'|'struct'|'switch'|'template'|'this'|'thread_local'|'throw'|'true'|'try'|'typedef'|'typeid'|'typename'|'union'|'unsigned'|'using'|'virtual'|'void'|'volatile'|'wchar_t'|'while'|import-keyword|module-keyword|export-keyword
    exitRuleBlock: 'alignas'|'alignof'|'asm'|'auto'|'bool'|'break'|'case'|'catch'|'char'|'char8_t'|'char16_t'|'char32_t'|'class'|'concept'|'const'|'consteval'|'constexpr'|'constinit'|'const_cast'|'continue'|'co_await'|'co_return'|'co_yield'|'decltype'|'default'|'delete'|'do'|'double'|'dynamic_cast'|'else'|'enum'|'explicit'|'export'|'extern'|'false'|'float'|'for'|'friend'|'goto'|'if'|'inline'|'int'|'long'|'mutable'|'namespace'|'new'|'noexcept'|'nullptr'|'operator'|'private'|'protected'|'public'|'register'|'reinterpret_cast'|'requires'|'return'|'short'|'signed'|'sizeof'|'static'|'static_assert'|'static_cast'|'struct'|'switch'|'template'|'this'|'thread_local'|'throw'|'true'|'try'|'typedef'|'typeid'|'typename'|'union'|'unsigned'|'using'|'virtual'|'void'|'volatile'|'wchar_t'|'while'|import-keyword|module-keyword|export-keyword
  exitRuleSpec: keyword:'alignas'|'alignof'|'asm'|'auto'|'bool'|'break'|'case'|'catch'|'char'|'char8_t'|'char16_t'|'char32_t'|'class'|'concept'|'const'|'consteval'|'constexpr'|'constinit'|'const_cast'|'continue'|'co_await'|'co_return'|'co_yield'|'decltype'|'default'|'delete'|'do'|'double'|'dynamic_cast'|'else'|'enum'|'explicit'|'export'|'extern'|'false'|'float'|'for'|'friend'|'goto'|'if'|'inline'|'int'|'long'|'mutable'|'namespace'|'new'|'noexcept'|'nullptr'|'operator'|'private'|'protected'|'public'|'register'|'reinterpret_cast'|'requires'|'return'|'short'|'signed'|'sizeof'|'static'|'static_assert'|'static_cast'|'struct'|'switch'|'template'|'this'|'thread_local'|'throw'|'true'|'try'|'typedef'|'typeid'|'typename'|'union'|'unsigned'|'using'|'virtual'|'void'|'volatile'|'wchar_t'|'while'|import-keyword|module-keyword|export-keyword;

  enterRuleSpec: preprocessing-op-or-punc:preprocessing-operator|operator-or-punctuator;
    enterRuleBlock: preprocessing-operator|operator-or-punctuator
      enterRuleAltList: preprocessing-operator|operator-or-punctuator
        enterLabeledAlt: preprocessing-operator
          enterAlternative: preprocessing-operator
            enterElement: preprocessing-operator
              => element -> {preprocessing-operator}
              enterAtom: preprocessing-operator
                enterRuleref: preprocessing-operator
                exitRuleref: preprocessing-operator
              exitAtom: preprocessing-operator
            exitElement: preprocessing-operator
          exitAlternative: preprocessing-operator
        => elements -> ['{preprocessing-operator}']
            => alternative -> {preprocessing-operator}
        exitLabeledAlt: preprocessing-operator
        enterLabeledAlt: operator-or-punctuator
          enterAlternative: operator-or-punctuator
            enterElement: operator-or-punctuator
              => element -> {operator-or-punctuator}
              enterAtom: operator-or-punctuator
                enterRuleref: operator-or-punctuator
                exitRuleref: operator-or-punctuator
              exitAtom: operator-or-punctuator
            exitElement: operator-or-punctuator
          exitAlternative: operator-or-punctuator
        => elements -> ['{operator-or-punctuator}']
            => alternative -> {operator-or-punctuator}
        exitLabeledAlt: operator-or-punctuator
      exitRuleAltList: preprocessing-operator|operator-or-punctuator
    exitRuleBlock: preprocessing-operator|operator-or-punctuator
  exitRuleSpec: preprocessing-op-or-punc:preprocessing-operator|operator-or-punctuator;

  enterRuleSpec: preprocessing-operator:'#'|'##'|'%:'|'%:%:';
    enterRuleBlock: '#'|'##'|'%:'|'%:%:'
      enterRuleAltList: '#'|'##'|'%:'|'%:%:'
        enterLabeledAlt: '#'
          enterAlternative: '#'
            enterElement: '#'
              => element -> #
              enterAtom: '#'
                enterTerminal: '#'
                exitTerminal: '#'
              exitAtom: '#'
            exitElement: '#'
          exitAlternative: '#'
        => elements -> ['#']
            => alternative -> #
        exitLabeledAlt: '#'
        enterLabeledAlt: '##'
          enterAlternative: '##'
            enterElement: '##'
              => element -> ##
              enterAtom: '##'
                enterTerminal: '##'
                exitTerminal: '##'
              exitAtom: '##'
            exitElement: '##'
          exitAlternative: '##'
        => elements -> ['##']
            => alternative -> ##
        exitLabeledAlt: '##'
        enterLabeledAlt: '%:'
          enterAlternative: '%:'
            enterElement: '%:'
              => element -> %:
              enterAtom: '%:'
                enterTerminal: '%:'
                exitTerminal: '%:'
              exitAtom: '%:'
            exitElement: '%:'
          exitAlternative: '%:'
        => elements -> ['%:']
            => alternative -> %:
        exitLabeledAlt: '%:'
        enterLabeledAlt: '%:%:'
          enterAlternative: '%:%:'
            enterElement: '%:%:'
              => element -> %:%:
              enterAtom: '%:%:'
                enterTerminal: '%:%:'
                exitTerminal: '%:%:'
              exitAtom: '%:%:'
            exitElement: '%:%:'
          exitAlternative: '%:%:'
        => elements -> ['%:%:']
            => alternative -> %:%:
        exitLabeledAlt: '%:%:'
      exitRuleAltList: '#'|'##'|'%:'|'%:%:'
    exitRuleBlock: '#'|'##'|'%:'|'%:%:'
  exitRuleSpec: preprocessing-operator:'#'|'##'|'%:'|'%:%:';

  enterRuleSpec: operator-or-punctuator:'{'|'}'|'['|']'|'('|')'|'<:'|':>'|'<%'|'%>'|';'|':'|'...'|'?'|'::'|'.'|'.*'|'->'|'->*'|'~'|'!'|'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'='|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'=='|'!='|'<'|'>'|'<='|'>='|'<=>'|'&&'|'||'|'<<'|'>>'|'<<='|'>>='|'++'|'--'|','|'and'|'or'|'xor'|'not'|'bitand'|'bitor'|'compl'|'and_eq'|'or_eq'|'xor_eq'|'not_eq';
    enterRuleBlock: '{'|'}'|'['|']'|'('|')'|'<:'|':>'|'<%'|'%>'|';'|':'|'...'|'?'|'::'|'.'|'.*'|'->'|'->*'|'~'|'!'|'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'='|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'=='|'!='|'<'|'>'|'<='|'>='|'<=>'|'&&'|'||'|'<<'|'>>'|'<<='|'>>='|'++'|'--'|','|'and'|'or'|'xor'|'not'|'bitand'|'bitor'|'compl'|'and_eq'|'or_eq'|'xor_eq'|'not_eq'
      enterRuleAltList: '{'|'}'|'['|']'|'('|')'|'<:'|':>'|'<%'|'%>'|';'|':'|'...'|'?'|'::'|'.'|'.*'|'->'|'->*'|'~'|'!'|'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'='|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'=='|'!='|'<'|'>'|'<='|'>='|'<=>'|'&&'|'||'|'<<'|'>>'|'<<='|'>>='|'++'|'--'|','|'and'|'or'|'xor'|'not'|'bitand'|'bitor'|'compl'|'and_eq'|'or_eq'|'xor_eq'|'not_eq'
        enterLabeledAlt: '{'
          enterAlternative: '{'
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
          exitAlternative: '{'
        => elements -> ['{']
            => alternative -> {
        exitLabeledAlt: '{'
        enterLabeledAlt: '}'
          enterAlternative: '}'
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: '}'
        => elements -> ['}']
            => alternative -> }
        exitLabeledAlt: '}'
        enterLabeledAlt: '['
          enterAlternative: '['
            enterElement: '['
              => element -> [
              enterAtom: '['
                enterTerminal: '['
                exitTerminal: '['
              exitAtom: '['
            exitElement: '['
          exitAlternative: '['
        => elements -> ['[']
            => alternative -> [
        exitLabeledAlt: '['
        enterLabeledAlt: ']'
          enterAlternative: ']'
            enterElement: ']'
              => element -> ]
              enterAtom: ']'
                enterTerminal: ']'
                exitTerminal: ']'
              exitAtom: ']'
            exitElement: ']'
          exitAlternative: ']'
        => elements -> [']']
            => alternative -> ]
        exitLabeledAlt: ']'
        enterLabeledAlt: '('
          enterAlternative: '('
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
          exitAlternative: '('
        => elements -> ['(']
            => alternative -> (
        exitLabeledAlt: '('
        enterLabeledAlt: ')'
          enterAlternative: ')'
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: ')'
        => elements -> [')']
            => alternative -> )
        exitLabeledAlt: ')'
        enterLabeledAlt: '<:'
          enterAlternative: '<:'
            enterElement: '<:'
              => element -> <:
              enterAtom: '<:'
                enterTerminal: '<:'
                exitTerminal: '<:'
              exitAtom: '<:'
            exitElement: '<:'
          exitAlternative: '<:'
        => elements -> ['<:']
            => alternative -> <:
        exitLabeledAlt: '<:'
        enterLabeledAlt: ':>'
          enterAlternative: ':>'
            enterElement: ':>'
              => element -> :>
              enterAtom: ':>'
                enterTerminal: ':>'
                exitTerminal: ':>'
              exitAtom: ':>'
            exitElement: ':>'
          exitAlternative: ':>'
        => elements -> [':>']
            => alternative -> :>
        exitLabeledAlt: ':>'
        enterLabeledAlt: '<%'
          enterAlternative: '<%'
            enterElement: '<%'
              => element -> <%
              enterAtom: '<%'
                enterTerminal: '<%'
                exitTerminal: '<%'
              exitAtom: '<%'
            exitElement: '<%'
          exitAlternative: '<%'
        => elements -> ['<%']
            => alternative -> <%
        exitLabeledAlt: '<%'
        enterLabeledAlt: '%>'
          enterAlternative: '%>'
            enterElement: '%>'
              => element -> %>
              enterAtom: '%>'
                enterTerminal: '%>'
                exitTerminal: '%>'
              exitAtom: '%>'
            exitElement: '%>'
          exitAlternative: '%>'
        => elements -> ['%>']
            => alternative -> %>
        exitLabeledAlt: '%>'
        enterLabeledAlt: ';'
          enterAlternative: ';'
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: ';'
        => elements -> [';']
            => alternative -> ;
        exitLabeledAlt: ';'
        enterLabeledAlt: ':'
          enterAlternative: ':'
            enterElement: ':'
              => element -> :
              enterAtom: ':'
                enterTerminal: ':'
                exitTerminal: ':'
              exitAtom: ':'
            exitElement: ':'
          exitAlternative: ':'
        => elements -> [':']
            => alternative -> :
        exitLabeledAlt: ':'
        enterLabeledAlt: '...'
          enterAlternative: '...'
            enterElement: '...'
              => element -> ...
              enterAtom: '...'
                enterTerminal: '...'
                exitTerminal: '...'
              exitAtom: '...'
            exitElement: '...'
          exitAlternative: '...'
        => elements -> ['...']
            => alternative -> ...
        exitLabeledAlt: '...'
        enterLabeledAlt: '?'
          enterAlternative: '?'
            enterElement: '?'
              => element -> ?
              enterAtom: '?'
                enterTerminal: '?'
                exitTerminal: '?'
              exitAtom: '?'
            exitElement: '?'
          exitAlternative: '?'
        => elements -> ['?']
            => alternative -> ?
        exitLabeledAlt: '?'
        enterLabeledAlt: '::'
          enterAlternative: '::'
            enterElement: '::'
              => element -> ::
              enterAtom: '::'
                enterTerminal: '::'
                exitTerminal: '::'
              exitAtom: '::'
            exitElement: '::'
          exitAlternative: '::'
        => elements -> ['::']
            => alternative -> ::
        exitLabeledAlt: '::'
        enterLabeledAlt: '.'
          enterAlternative: '.'
            enterElement: '.'
              => element -> .
              enterAtom: '.'
                enterTerminal: '.'
                exitTerminal: '.'
              exitAtom: '.'
            exitElement: '.'
          exitAlternative: '.'
        => elements -> ['.']
            => alternative -> .
        exitLabeledAlt: '.'
        enterLabeledAlt: '.*'
          enterAlternative: '.*'
            enterElement: '.*'
              => element -> .*
              enterAtom: '.*'
                enterTerminal: '.*'
                exitTerminal: '.*'
              exitAtom: '.*'
            exitElement: '.*'
          exitAlternative: '.*'
        => elements -> ['.*']
            => alternative -> .*
        exitLabeledAlt: '.*'
        enterLabeledAlt: '->'
          enterAlternative: '->'
            enterElement: '->'
              => element -> ->
              enterAtom: '->'
                enterTerminal: '->'
                exitTerminal: '->'
              exitAtom: '->'
            exitElement: '->'
          exitAlternative: '->'
        => elements -> ['->']
            => alternative -> ->
        exitLabeledAlt: '->'
        enterLabeledAlt: '->*'
          enterAlternative: '->*'
            enterElement: '->*'
              => element -> ->*
              enterAtom: '->*'
                enterTerminal: '->*'
                exitTerminal: '->*'
              exitAtom: '->*'
            exitElement: '->*'
          exitAlternative: '->*'
        => elements -> ['->*']
            => alternative -> ->*
        exitLabeledAlt: '->*'
        enterLabeledAlt: '~'
          enterAlternative: '~'
            enterElement: '~'
              => element -> ~
              enterAtom: '~'
                enterTerminal: '~'
                exitTerminal: '~'
              exitAtom: '~'
            exitElement: '~'
          exitAlternative: '~'
        => elements -> ['~']
            => alternative -> ~
        exitLabeledAlt: '~'
        enterLabeledAlt: '!'
          enterAlternative: '!'
            enterElement: '!'
              => element -> !
              enterAtom: '!'
                enterTerminal: '!'
                exitTerminal: '!'
              exitAtom: '!'
            exitElement: '!'
          exitAlternative: '!'
        => elements -> ['!']
            => alternative -> !
        exitLabeledAlt: '!'
        enterLabeledAlt: '+'
          enterAlternative: '+'
            enterElement: '+'
              => element -> +
              enterAtom: '+'
                enterTerminal: '+'
                exitTerminal: '+'
              exitAtom: '+'
            exitElement: '+'
          exitAlternative: '+'
        => elements -> ['+']
            => alternative -> +
        exitLabeledAlt: '+'
        enterLabeledAlt: '-'
          enterAlternative: '-'
            enterElement: '-'
              => element -> -
              enterAtom: '-'
                enterTerminal: '-'
                exitTerminal: '-'
              exitAtom: '-'
            exitElement: '-'
          exitAlternative: '-'
        => elements -> ['-']
            => alternative -> -
        exitLabeledAlt: '-'
        enterLabeledAlt: '*'
          enterAlternative: '*'
            enterElement: '*'
              => element -> *
              enterAtom: '*'
                enterTerminal: '*'
                exitTerminal: '*'
              exitAtom: '*'
            exitElement: '*'
          exitAlternative: '*'
        => elements -> ['*']
            => alternative -> *
        exitLabeledAlt: '*'
        enterLabeledAlt: '/'
          enterAlternative: '/'
            enterElement: '/'
              => element -> /
              enterAtom: '/'
                enterTerminal: '/'
                exitTerminal: '/'
              exitAtom: '/'
            exitElement: '/'
          exitAlternative: '/'
        => elements -> ['/']
            => alternative -> /
        exitLabeledAlt: '/'
        enterLabeledAlt: '%'
          enterAlternative: '%'
            enterElement: '%'
              => element -> %
              enterAtom: '%'
                enterTerminal: '%'
                exitTerminal: '%'
              exitAtom: '%'
            exitElement: '%'
          exitAlternative: '%'
        => elements -> ['%']
            => alternative -> %
        exitLabeledAlt: '%'
        enterLabeledAlt: '^'
          enterAlternative: '^'
            enterElement: '^'
              => element -> ^
              enterAtom: '^'
                enterTerminal: '^'
                exitTerminal: '^'
              exitAtom: '^'
            exitElement: '^'
          exitAlternative: '^'
        => elements -> ['^']
            => alternative -> ^
        exitLabeledAlt: '^'
        enterLabeledAlt: '&'
          enterAlternative: '&'
            enterElement: '&'
              => element -> &
              enterAtom: '&'
                enterTerminal: '&'
                exitTerminal: '&'
              exitAtom: '&'
            exitElement: '&'
          exitAlternative: '&'
        => elements -> ['&']
            => alternative -> &
        exitLabeledAlt: '&'
        enterLabeledAlt: '|'
          enterAlternative: '|'
            enterElement: '|'
              => element -> |
              enterAtom: '|'
                enterTerminal: '|'
                exitTerminal: '|'
              exitAtom: '|'
            exitElement: '|'
          exitAlternative: '|'
        => elements -> ['|']
            => alternative -> |
        exitLabeledAlt: '|'
        enterLabeledAlt: '='
          enterAlternative: '='
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
          exitAlternative: '='
        => elements -> ['=']
            => alternative -> =
        exitLabeledAlt: '='
        enterLabeledAlt: '+='
          enterAlternative: '+='
            enterElement: '+='
              => element -> +=
              enterAtom: '+='
                enterTerminal: '+='
                exitTerminal: '+='
              exitAtom: '+='
            exitElement: '+='
          exitAlternative: '+='
        => elements -> ['+=']
            => alternative -> +=
        exitLabeledAlt: '+='
        enterLabeledAlt: '-='
          enterAlternative: '-='
            enterElement: '-='
              => element -> -=
              enterAtom: '-='
                enterTerminal: '-='
                exitTerminal: '-='
              exitAtom: '-='
            exitElement: '-='
          exitAlternative: '-='
        => elements -> ['-=']
            => alternative -> -=
        exitLabeledAlt: '-='
        enterLabeledAlt: '*='
          enterAlternative: '*='
            enterElement: '*='
              => element -> *=
              enterAtom: '*='
                enterTerminal: '*='
                exitTerminal: '*='
              exitAtom: '*='
            exitElement: '*='
          exitAlternative: '*='
        => elements -> ['*=']
            => alternative -> *=
        exitLabeledAlt: '*='
        enterLabeledAlt: '/='
          enterAlternative: '/='
            enterElement: '/='
              => element -> /=
              enterAtom: '/='
                enterTerminal: '/='
                exitTerminal: '/='
              exitAtom: '/='
            exitElement: '/='
          exitAlternative: '/='
        => elements -> ['/=']
            => alternative -> /=
        exitLabeledAlt: '/='
        enterLabeledAlt: '%='
          enterAlternative: '%='
            enterElement: '%='
              => element -> %=
              enterAtom: '%='
                enterTerminal: '%='
                exitTerminal: '%='
              exitAtom: '%='
            exitElement: '%='
          exitAlternative: '%='
        => elements -> ['%=']
            => alternative -> %=
        exitLabeledAlt: '%='
        enterLabeledAlt: '^='
          enterAlternative: '^='
            enterElement: '^='
              => element -> ^=
              enterAtom: '^='
                enterTerminal: '^='
                exitTerminal: '^='
              exitAtom: '^='
            exitElement: '^='
          exitAlternative: '^='
        => elements -> ['^=']
            => alternative -> ^=
        exitLabeledAlt: '^='
        enterLabeledAlt: '&='
          enterAlternative: '&='
            enterElement: '&='
              => element -> &=
              enterAtom: '&='
                enterTerminal: '&='
                exitTerminal: '&='
              exitAtom: '&='
            exitElement: '&='
          exitAlternative: '&='
        => elements -> ['&=']
            => alternative -> &=
        exitLabeledAlt: '&='
        enterLabeledAlt: '|='
          enterAlternative: '|='
            enterElement: '|='
              => element -> |=
              enterAtom: '|='
                enterTerminal: '|='
                exitTerminal: '|='
              exitAtom: '|='
            exitElement: '|='
          exitAlternative: '|='
        => elements -> ['|=']
            => alternative -> |=
        exitLabeledAlt: '|='
        enterLabeledAlt: '=='
          enterAlternative: '=='
            enterElement: '=='
              => element -> ==
              enterAtom: '=='
                enterTerminal: '=='
                exitTerminal: '=='
              exitAtom: '=='
            exitElement: '=='
          exitAlternative: '=='
        => elements -> ['==']
            => alternative -> ==
        exitLabeledAlt: '=='
        enterLabeledAlt: '!='
          enterAlternative: '!='
            enterElement: '!='
              => element -> !=
              enterAtom: '!='
                enterTerminal: '!='
                exitTerminal: '!='
              exitAtom: '!='
            exitElement: '!='
          exitAlternative: '!='
        => elements -> ['!=']
            => alternative -> !=
        exitLabeledAlt: '!='
        enterLabeledAlt: '<'
          enterAlternative: '<'
            enterElement: '<'
              => element -> <
              enterAtom: '<'
                enterTerminal: '<'
                exitTerminal: '<'
              exitAtom: '<'
            exitElement: '<'
          exitAlternative: '<'
        => elements -> ['<']
            => alternative -> <
        exitLabeledAlt: '<'
        enterLabeledAlt: '>'
          enterAlternative: '>'
            enterElement: '>'
              => element -> >
              enterAtom: '>'
                enterTerminal: '>'
                exitTerminal: '>'
              exitAtom: '>'
            exitElement: '>'
          exitAlternative: '>'
        => elements -> ['>']
            => alternative -> >
        exitLabeledAlt: '>'
        enterLabeledAlt: '<='
          enterAlternative: '<='
            enterElement: '<='
              => element -> <=
              enterAtom: '<='
                enterTerminal: '<='
                exitTerminal: '<='
              exitAtom: '<='
            exitElement: '<='
          exitAlternative: '<='
        => elements -> ['<=']
            => alternative -> <=
        exitLabeledAlt: '<='
        enterLabeledAlt: '>='
          enterAlternative: '>='
            enterElement: '>='
              => element -> >=
              enterAtom: '>='
                enterTerminal: '>='
                exitTerminal: '>='
              exitAtom: '>='
            exitElement: '>='
          exitAlternative: '>='
        => elements -> ['>=']
            => alternative -> >=
        exitLabeledAlt: '>='
        enterLabeledAlt: '<=>'
          enterAlternative: '<=>'
            enterElement: '<=>'
              => element -> <=>
              enterAtom: '<=>'
                enterTerminal: '<=>'
                exitTerminal: '<=>'
              exitAtom: '<=>'
            exitElement: '<=>'
          exitAlternative: '<=>'
        => elements -> ['<=>']
            => alternative -> <=>
        exitLabeledAlt: '<=>'
        enterLabeledAlt: '&&'
          enterAlternative: '&&'
            enterElement: '&&'
              => element -> &&
              enterAtom: '&&'
                enterTerminal: '&&'
                exitTerminal: '&&'
              exitAtom: '&&'
            exitElement: '&&'
          exitAlternative: '&&'
        => elements -> ['&&']
            => alternative -> &&
        exitLabeledAlt: '&&'
        enterLabeledAlt: '||'
          enterAlternative: '||'
            enterElement: '||'
              => element -> ||
              enterAtom: '||'
                enterTerminal: '||'
                exitTerminal: '||'
              exitAtom: '||'
            exitElement: '||'
          exitAlternative: '||'
        => elements -> ['||']
            => alternative -> ||
        exitLabeledAlt: '||'
        enterLabeledAlt: '<<'
          enterAlternative: '<<'
            enterElement: '<<'
              => element -> <<
              enterAtom: '<<'
                enterTerminal: '<<'
                exitTerminal: '<<'
              exitAtom: '<<'
            exitElement: '<<'
          exitAlternative: '<<'
        => elements -> ['<<']
            => alternative -> <<
        exitLabeledAlt: '<<'
        enterLabeledAlt: '>>'
          enterAlternative: '>>'
            enterElement: '>>'
              => element -> >>
              enterAtom: '>>'
                enterTerminal: '>>'
                exitTerminal: '>>'
              exitAtom: '>>'
            exitElement: '>>'
          exitAlternative: '>>'
        => elements -> ['>>']
            => alternative -> >>
        exitLabeledAlt: '>>'
        enterLabeledAlt: '<<='
          enterAlternative: '<<='
            enterElement: '<<='
              => element -> <<=
              enterAtom: '<<='
                enterTerminal: '<<='
                exitTerminal: '<<='
              exitAtom: '<<='
            exitElement: '<<='
          exitAlternative: '<<='
        => elements -> ['<<=']
            => alternative -> <<=
        exitLabeledAlt: '<<='
        enterLabeledAlt: '>>='
          enterAlternative: '>>='
            enterElement: '>>='
              => element -> >>=
              enterAtom: '>>='
                enterTerminal: '>>='
                exitTerminal: '>>='
              exitAtom: '>>='
            exitElement: '>>='
          exitAlternative: '>>='
        => elements -> ['>>=']
            => alternative -> >>=
        exitLabeledAlt: '>>='
        enterLabeledAlt: '++'
          enterAlternative: '++'
            enterElement: '++'
              => element -> ++
              enterAtom: '++'
                enterTerminal: '++'
                exitTerminal: '++'
              exitAtom: '++'
            exitElement: '++'
          exitAlternative: '++'
        => elements -> ['++']
            => alternative -> ++
        exitLabeledAlt: '++'
        enterLabeledAlt: '--'
          enterAlternative: '--'
            enterElement: '--'
              => element -> --
              enterAtom: '--'
                enterTerminal: '--'
                exitTerminal: '--'
              exitAtom: '--'
            exitElement: '--'
          exitAlternative: '--'
        => elements -> ['--']
            => alternative -> --
        exitLabeledAlt: '--'
        enterLabeledAlt: ','
          enterAlternative: ','
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
          exitAlternative: ','
        => elements -> [',']
            => alternative -> ,
        exitLabeledAlt: ','
        enterLabeledAlt: 'and'
          enterAlternative: 'and'
            enterElement: 'and'
              => element -> and
              enterAtom: 'and'
                enterTerminal: 'and'
                exitTerminal: 'and'
              exitAtom: 'and'
            exitElement: 'and'
          exitAlternative: 'and'
        => elements -> ['and']
            => alternative -> and
        exitLabeledAlt: 'and'
        enterLabeledAlt: 'or'
          enterAlternative: 'or'
            enterElement: 'or'
              => element -> or
              enterAtom: 'or'
                enterTerminal: 'or'
                exitTerminal: 'or'
              exitAtom: 'or'
            exitElement: 'or'
          exitAlternative: 'or'
        => elements -> ['or']
            => alternative -> or
        exitLabeledAlt: 'or'
        enterLabeledAlt: 'xor'
          enterAlternative: 'xor'
            enterElement: 'xor'
              => element -> xor
              enterAtom: 'xor'
                enterTerminal: 'xor'
                exitTerminal: 'xor'
              exitAtom: 'xor'
            exitElement: 'xor'
          exitAlternative: 'xor'
        => elements -> ['xor']
            => alternative -> xor
        exitLabeledAlt: 'xor'
        enterLabeledAlt: 'not'
          enterAlternative: 'not'
            enterElement: 'not'
              => element -> not
              enterAtom: 'not'
                enterTerminal: 'not'
                exitTerminal: 'not'
              exitAtom: 'not'
            exitElement: 'not'
          exitAlternative: 'not'
        => elements -> ['not']
            => alternative -> not
        exitLabeledAlt: 'not'
        enterLabeledAlt: 'bitand'
          enterAlternative: 'bitand'
            enterElement: 'bitand'
              => element -> bitand
              enterAtom: 'bitand'
                enterTerminal: 'bitand'
                exitTerminal: 'bitand'
              exitAtom: 'bitand'
            exitElement: 'bitand'
          exitAlternative: 'bitand'
        => elements -> ['bitand']
            => alternative -> bitand
        exitLabeledAlt: 'bitand'
        enterLabeledAlt: 'bitor'
          enterAlternative: 'bitor'
            enterElement: 'bitor'
              => element -> bitor
              enterAtom: 'bitor'
                enterTerminal: 'bitor'
                exitTerminal: 'bitor'
              exitAtom: 'bitor'
            exitElement: 'bitor'
          exitAlternative: 'bitor'
        => elements -> ['bitor']
            => alternative -> bitor
        exitLabeledAlt: 'bitor'
        enterLabeledAlt: 'compl'
          enterAlternative: 'compl'
            enterElement: 'compl'
              => element -> compl
              enterAtom: 'compl'
                enterTerminal: 'compl'
                exitTerminal: 'compl'
              exitAtom: 'compl'
            exitElement: 'compl'
          exitAlternative: 'compl'
        => elements -> ['compl']
            => alternative -> compl
        exitLabeledAlt: 'compl'
        enterLabeledAlt: 'and_eq'
          enterAlternative: 'and_eq'
            enterElement: 'and_eq'
              => element -> and_eq
              enterAtom: 'and_eq'
                enterTerminal: 'and_eq'
                exitTerminal: 'and_eq'
              exitAtom: 'and_eq'
            exitElement: 'and_eq'
          exitAlternative: 'and_eq'
        => elements -> ['and_eq']
            => alternative -> and_eq
        exitLabeledAlt: 'and_eq'
        enterLabeledAlt: 'or_eq'
          enterAlternative: 'or_eq'
            enterElement: 'or_eq'
              => element -> or_eq
              enterAtom: 'or_eq'
                enterTerminal: 'or_eq'
                exitTerminal: 'or_eq'
              exitAtom: 'or_eq'
            exitElement: 'or_eq'
          exitAlternative: 'or_eq'
        => elements -> ['or_eq']
            => alternative -> or_eq
        exitLabeledAlt: 'or_eq'
        enterLabeledAlt: 'xor_eq'
          enterAlternative: 'xor_eq'
            enterElement: 'xor_eq'
              => element -> xor_eq
              enterAtom: 'xor_eq'
                enterTerminal: 'xor_eq'
                exitTerminal: 'xor_eq'
              exitAtom: 'xor_eq'
            exitElement: 'xor_eq'
          exitAlternative: 'xor_eq'
        => elements -> ['xor_eq']
            => alternative -> xor_eq
        exitLabeledAlt: 'xor_eq'
        enterLabeledAlt: 'not_eq'
          enterAlternative: 'not_eq'
            enterElement: 'not_eq'
              => element -> not_eq
              enterAtom: 'not_eq'
                enterTerminal: 'not_eq'
                exitTerminal: 'not_eq'
              exitAtom: 'not_eq'
            exitElement: 'not_eq'
          exitAlternative: 'not_eq'
        => elements -> ['not_eq']
            => alternative -> not_eq
        exitLabeledAlt: 'not_eq'
      exitRuleAltList: '{'|'}'|'['|']'|'('|')'|'<:'|':>'|'<%'|'%>'|';'|':'|'...'|'?'|'::'|'.'|'.*'|'->'|'->*'|'~'|'!'|'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'='|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'=='|'!='|'<'|'>'|'<='|'>='|'<=>'|'&&'|'||'|'<<'|'>>'|'<<='|'>>='|'++'|'--'|','|'and'|'or'|'xor'|'not'|'bitand'|'bitor'|'compl'|'and_eq'|'or_eq'|'xor_eq'|'not_eq'
    exitRuleBlock: '{'|'}'|'['|']'|'('|')'|'<:'|':>'|'<%'|'%>'|';'|':'|'...'|'?'|'::'|'.'|'.*'|'->'|'->*'|'~'|'!'|'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'='|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'=='|'!='|'<'|'>'|'<='|'>='|'<=>'|'&&'|'||'|'<<'|'>>'|'<<='|'>>='|'++'|'--'|','|'and'|'or'|'xor'|'not'|'bitand'|'bitor'|'compl'|'and_eq'|'or_eq'|'xor_eq'|'not_eq'
  exitRuleSpec: operator-or-punctuator:'{'|'}'|'['|']'|'('|')'|'<:'|':>'|'<%'|'%>'|';'|':'|'...'|'?'|'::'|'.'|'.*'|'->'|'->*'|'~'|'!'|'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'='|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'=='|'!='|'<'|'>'|'<='|'>='|'<=>'|'&&'|'||'|'<<'|'>>'|'<<='|'>>='|'++'|'--'|','|'and'|'or'|'xor'|'not'|'bitand'|'bitor'|'compl'|'and_eq'|'or_eq'|'xor_eq'|'not_eq';

  enterRuleSpec: literal:integer-literal|character-literal|floating-point-literal|string-literal|boolean-literal|pointer-literal|user-defined-literal;
    enterRuleBlock: integer-literal|character-literal|floating-point-literal|string-literal|boolean-literal|pointer-literal|user-defined-literal
      enterRuleAltList: integer-literal|character-literal|floating-point-literal|string-literal|boolean-literal|pointer-literal|user-defined-literal
        enterLabeledAlt: integer-literal
          enterAlternative: integer-literal
            enterElement: integer-literal
              => element -> {integer-literal}
              enterAtom: integer-literal
                enterRuleref: integer-literal
                exitRuleref: integer-literal
              exitAtom: integer-literal
            exitElement: integer-literal
          exitAlternative: integer-literal
        => elements -> ['{integer-literal}']
            => alternative -> {integer-literal}
        exitLabeledAlt: integer-literal
        enterLabeledAlt: character-literal
          enterAlternative: character-literal
            enterElement: character-literal
              => element -> {character-literal}
              enterAtom: character-literal
                enterRuleref: character-literal
                exitRuleref: character-literal
              exitAtom: character-literal
            exitElement: character-literal
          exitAlternative: character-literal
        => elements -> ['{character-literal}']
            => alternative -> {character-literal}
        exitLabeledAlt: character-literal
        enterLabeledAlt: floating-point-literal
          enterAlternative: floating-point-literal
            enterElement: floating-point-literal
              => element -> {floating-point-literal}
              enterAtom: floating-point-literal
                enterRuleref: floating-point-literal
                exitRuleref: floating-point-literal
              exitAtom: floating-point-literal
            exitElement: floating-point-literal
          exitAlternative: floating-point-literal
        => elements -> ['{floating-point-literal}']
            => alternative -> {floating-point-literal}
        exitLabeledAlt: floating-point-literal
        enterLabeledAlt: string-literal
          enterAlternative: string-literal
            enterElement: string-literal
              => element -> {string-literal}
              enterAtom: string-literal
                enterRuleref: string-literal
                exitRuleref: string-literal
              exitAtom: string-literal
            exitElement: string-literal
          exitAlternative: string-literal
        => elements -> ['{string-literal}']
            => alternative -> {string-literal}
        exitLabeledAlt: string-literal
        enterLabeledAlt: boolean-literal
          enterAlternative: boolean-literal
            enterElement: boolean-literal
              => element -> {boolean-literal}
              enterAtom: boolean-literal
                enterRuleref: boolean-literal
                exitRuleref: boolean-literal
              exitAtom: boolean-literal
            exitElement: boolean-literal
          exitAlternative: boolean-literal
        => elements -> ['{boolean-literal}']
            => alternative -> {boolean-literal}
        exitLabeledAlt: boolean-literal
        enterLabeledAlt: pointer-literal
          enterAlternative: pointer-literal
            enterElement: pointer-literal
              => element -> {pointer-literal}
              enterAtom: pointer-literal
                enterRuleref: pointer-literal
                exitRuleref: pointer-literal
              exitAtom: pointer-literal
            exitElement: pointer-literal
          exitAlternative: pointer-literal
        => elements -> ['{pointer-literal}']
            => alternative -> {pointer-literal}
        exitLabeledAlt: pointer-literal
        enterLabeledAlt: user-defined-literal
          enterAlternative: user-defined-literal
            enterElement: user-defined-literal
              => element -> {user-defined-literal}
              enterAtom: user-defined-literal
                enterRuleref: user-defined-literal
                exitRuleref: user-defined-literal
              exitAtom: user-defined-literal
            exitElement: user-defined-literal
          exitAlternative: user-defined-literal
        => elements -> ['{user-defined-literal}']
            => alternative -> {user-defined-literal}
        exitLabeledAlt: user-defined-literal
      exitRuleAltList: integer-literal|character-literal|floating-point-literal|string-literal|boolean-literal|pointer-literal|user-defined-literal
    exitRuleBlock: integer-literal|character-literal|floating-point-literal|string-literal|boolean-literal|pointer-literal|user-defined-literal
  exitRuleSpec: literal:integer-literal|character-literal|floating-point-literal|string-literal|boolean-literal|pointer-literal|user-defined-literal;

  enterRuleSpec: integer-literal:binary-literalinteger-suffix?|octal-literalinteger-suffix?|decimal-literalinteger-suffix?|hexadecimal-literalinteger-suffix?;
    enterRuleBlock: binary-literalinteger-suffix?|octal-literalinteger-suffix?|decimal-literalinteger-suffix?|hexadecimal-literalinteger-suffix?
      enterRuleAltList: binary-literalinteger-suffix?|octal-literalinteger-suffix?|decimal-literalinteger-suffix?|hexadecimal-literalinteger-suffix?
        enterLabeledAlt: binary-literalinteger-suffix?
          enterAlternative: binary-literalinteger-suffix?
            enterElement: binary-literal
              => element -> {binary-literal}
              enterAtom: binary-literal
                enterRuleref: binary-literal
                exitRuleref: binary-literal
              exitAtom: binary-literal
            exitElement: binary-literal
            enterElement: integer-suffix?
              => element -> [integer-suffix]
              enterAtom: integer-suffix
                enterRuleref: integer-suffix
                exitRuleref: integer-suffix
              exitAtom: integer-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: integer-suffix?
          exitAlternative: binary-literalinteger-suffix?
        => elements -> ['{binary-literal}', '[integer-suffix]']
            => alternative -> {binary-literal} [integer-suffix]
        exitLabeledAlt: binary-literalinteger-suffix?
        enterLabeledAlt: octal-literalinteger-suffix?
          enterAlternative: octal-literalinteger-suffix?
            enterElement: octal-literal
              => element -> {octal-literal}
              enterAtom: octal-literal
                enterRuleref: octal-literal
                exitRuleref: octal-literal
              exitAtom: octal-literal
            exitElement: octal-literal
            enterElement: integer-suffix?
              => element -> [integer-suffix]
              enterAtom: integer-suffix
                enterRuleref: integer-suffix
                exitRuleref: integer-suffix
              exitAtom: integer-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: integer-suffix?
          exitAlternative: octal-literalinteger-suffix?
        => elements -> ['{octal-literal}', '[integer-suffix]']
            => alternative -> {octal-literal} [integer-suffix]
        exitLabeledAlt: octal-literalinteger-suffix?
        enterLabeledAlt: decimal-literalinteger-suffix?
          enterAlternative: decimal-literalinteger-suffix?
            enterElement: decimal-literal
              => element -> {decimal-literal}
              enterAtom: decimal-literal
                enterRuleref: decimal-literal
                exitRuleref: decimal-literal
              exitAtom: decimal-literal
            exitElement: decimal-literal
            enterElement: integer-suffix?
              => element -> [integer-suffix]
              enterAtom: integer-suffix
                enterRuleref: integer-suffix
                exitRuleref: integer-suffix
              exitAtom: integer-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: integer-suffix?
          exitAlternative: decimal-literalinteger-suffix?
        => elements -> ['{decimal-literal}', '[integer-suffix]']
            => alternative -> {decimal-literal} [integer-suffix]
        exitLabeledAlt: decimal-literalinteger-suffix?
        enterLabeledAlt: hexadecimal-literalinteger-suffix?
          enterAlternative: hexadecimal-literalinteger-suffix?
            enterElement: hexadecimal-literal
              => element -> {hexadecimal-literal}
              enterAtom: hexadecimal-literal
                enterRuleref: hexadecimal-literal
                exitRuleref: hexadecimal-literal
              exitAtom: hexadecimal-literal
            exitElement: hexadecimal-literal
            enterElement: integer-suffix?
              => element -> [integer-suffix]
              enterAtom: integer-suffix
                enterRuleref: integer-suffix
                exitRuleref: integer-suffix
              exitAtom: integer-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: integer-suffix?
          exitAlternative: hexadecimal-literalinteger-suffix?
        => elements -> ['{hexadecimal-literal}', '[integer-suffix]']
            => alternative -> {hexadecimal-literal} [integer-suffix]
        exitLabeledAlt: hexadecimal-literalinteger-suffix?
      exitRuleAltList: binary-literalinteger-suffix?|octal-literalinteger-suffix?|decimal-literalinteger-suffix?|hexadecimal-literalinteger-suffix?
    exitRuleBlock: binary-literalinteger-suffix?|octal-literalinteger-suffix?|decimal-literalinteger-suffix?|hexadecimal-literalinteger-suffix?
  exitRuleSpec: integer-literal:binary-literalinteger-suffix?|octal-literalinteger-suffix?|decimal-literalinteger-suffix?|hexadecimal-literalinteger-suffix?;

  enterRuleSpec: simple-quote-char:'\'';
    enterRuleBlock: '\''
      enterRuleAltList: '\''
        enterLabeledAlt: '\''
          enterAlternative: '\''
            enterElement: '\''
              => element -> \'
              enterAtom: '\''
                enterTerminal: '\''
                exitTerminal: '\''
              exitAtom: '\''
            exitElement: '\''
          exitAlternative: '\''
        => elements -> ["\\'"]
            => alternative -> \'
        exitLabeledAlt: '\''
      exitRuleAltList: '\''
    exitRuleBlock: '\''
  exitRuleSpec: simple-quote-char:'\'';

  enterRuleSpec: binary-literal:'0b'binary-digit|'0B'binary-digit|binary-literalsimple-quote-char?binary-digit;
    enterRuleBlock: '0b'binary-digit|'0B'binary-digit|binary-literalsimple-quote-char?binary-digit
      enterRuleAltList: '0b'binary-digit|'0B'binary-digit|binary-literalsimple-quote-char?binary-digit
        enterLabeledAlt: '0b'binary-digit
          enterAlternative: '0b'binary-digit
            enterElement: '0b'
              => element -> 0b
              enterAtom: '0b'
                enterTerminal: '0b'
                exitTerminal: '0b'
              exitAtom: '0b'
            exitElement: '0b'
            enterElement: binary-digit
              => element -> {binary-digit}
              enterAtom: binary-digit
                enterRuleref: binary-digit
                exitRuleref: binary-digit
              exitAtom: binary-digit
            exitElement: binary-digit
          exitAlternative: '0b'binary-digit
        => elements -> ['0b', '{binary-digit}']
            => alternative -> 0b {binary-digit}
        exitLabeledAlt: '0b'binary-digit
        enterLabeledAlt: '0B'binary-digit
          enterAlternative: '0B'binary-digit
            enterElement: '0B'
              => element -> 0B
              enterAtom: '0B'
                enterTerminal: '0B'
                exitTerminal: '0B'
              exitAtom: '0B'
            exitElement: '0B'
            enterElement: binary-digit
              => element -> {binary-digit}
              enterAtom: binary-digit
                enterRuleref: binary-digit
                exitRuleref: binary-digit
              exitAtom: binary-digit
            exitElement: binary-digit
          exitAlternative: '0B'binary-digit
        => elements -> ['0B', '{binary-digit}']
            => alternative -> 0B {binary-digit}
        exitLabeledAlt: '0B'binary-digit
        enterLabeledAlt: binary-literalsimple-quote-char?binary-digit
          enterAlternative: binary-literalsimple-quote-char?binary-digit
            enterElement: binary-literal
              => element -> {binary-literal}
              enterAtom: binary-literal
                enterRuleref: binary-literal
                exitRuleref: binary-literal
              exitAtom: binary-literal
            exitElement: binary-literal
            enterElement: simple-quote-char?
              => element -> [simple-quote-char]
              enterAtom: simple-quote-char
                enterRuleref: simple-quote-char
                exitRuleref: simple-quote-char
              exitAtom: simple-quote-char
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: simple-quote-char?
            enterElement: binary-digit
              => element -> {binary-digit}
              enterAtom: binary-digit
                enterRuleref: binary-digit
                exitRuleref: binary-digit
              exitAtom: binary-digit
            exitElement: binary-digit
          exitAlternative: binary-literalsimple-quote-char?binary-digit
        => elements -> ['{binary-literal}', '[simple-quote-char]', '{binary-digit}']
            => alternative -> {binary-literal} [simple-quote-char] {binary-digit}
        exitLabeledAlt: binary-literalsimple-quote-char?binary-digit
      exitRuleAltList: '0b'binary-digit|'0B'binary-digit|binary-literalsimple-quote-char?binary-digit
    exitRuleBlock: '0b'binary-digit|'0B'binary-digit|binary-literalsimple-quote-char?binary-digit
  exitRuleSpec: binary-literal:'0b'binary-digit|'0B'binary-digit|binary-literalsimple-quote-char?binary-digit;

  enterRuleSpec: octal-literal:'0'|octal-literalsimple-quote-char?octal-digit;
    enterRuleBlock: '0'|octal-literalsimple-quote-char?octal-digit
      enterRuleAltList: '0'|octal-literalsimple-quote-char?octal-digit
        enterLabeledAlt: '0'
          enterAlternative: '0'
            enterElement: '0'
              => element -> 0
              enterAtom: '0'
                enterTerminal: '0'
                exitTerminal: '0'
              exitAtom: '0'
            exitElement: '0'
          exitAlternative: '0'
        => elements -> ['0']
            => alternative -> 0
        exitLabeledAlt: '0'
        enterLabeledAlt: octal-literalsimple-quote-char?octal-digit
          enterAlternative: octal-literalsimple-quote-char?octal-digit
            enterElement: octal-literal
              => element -> {octal-literal}
              enterAtom: octal-literal
                enterRuleref: octal-literal
                exitRuleref: octal-literal
              exitAtom: octal-literal
            exitElement: octal-literal
            enterElement: simple-quote-char?
              => element -> [simple-quote-char]
              enterAtom: simple-quote-char
                enterRuleref: simple-quote-char
                exitRuleref: simple-quote-char
              exitAtom: simple-quote-char
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: simple-quote-char?
            enterElement: octal-digit
              => element -> {octal-digit}
              enterAtom: octal-digit
                enterRuleref: octal-digit
                exitRuleref: octal-digit
              exitAtom: octal-digit
            exitElement: octal-digit
          exitAlternative: octal-literalsimple-quote-char?octal-digit
        => elements -> ['{octal-literal}', '[simple-quote-char]', '{octal-digit}']
            => alternative -> {octal-literal} [simple-quote-char] {octal-digit}
        exitLabeledAlt: octal-literalsimple-quote-char?octal-digit
      exitRuleAltList: '0'|octal-literalsimple-quote-char?octal-digit
    exitRuleBlock: '0'|octal-literalsimple-quote-char?octal-digit
  exitRuleSpec: octal-literal:'0'|octal-literalsimple-quote-char?octal-digit;

  enterRuleSpec: decimal-literal:nonzero-digit|decimal-literalsimple-quote-char?digit;
    enterRuleBlock: nonzero-digit|decimal-literalsimple-quote-char?digit
      enterRuleAltList: nonzero-digit|decimal-literalsimple-quote-char?digit
        enterLabeledAlt: nonzero-digit
          enterAlternative: nonzero-digit
            enterElement: nonzero-digit
              => element -> {nonzero-digit}
              enterAtom: nonzero-digit
                enterRuleref: nonzero-digit
                exitRuleref: nonzero-digit
              exitAtom: nonzero-digit
            exitElement: nonzero-digit
          exitAlternative: nonzero-digit
        => elements -> ['{nonzero-digit}']
            => alternative -> {nonzero-digit}
        exitLabeledAlt: nonzero-digit
        enterLabeledAlt: decimal-literalsimple-quote-char?digit
          enterAlternative: decimal-literalsimple-quote-char?digit
            enterElement: decimal-literal
              => element -> {decimal-literal}
              enterAtom: decimal-literal
                enterRuleref: decimal-literal
                exitRuleref: decimal-literal
              exitAtom: decimal-literal
            exitElement: decimal-literal
            enterElement: simple-quote-char?
              => element -> [simple-quote-char]
              enterAtom: simple-quote-char
                enterRuleref: simple-quote-char
                exitRuleref: simple-quote-char
              exitAtom: simple-quote-char
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: simple-quote-char?
            enterElement: digit
              => element -> {digit}
              enterAtom: digit
                enterRuleref: digit
                exitRuleref: digit
              exitAtom: digit
            exitElement: digit
          exitAlternative: decimal-literalsimple-quote-char?digit
        => elements -> ['{decimal-literal}', '[simple-quote-char]', '{digit}']
            => alternative -> {decimal-literal} [simple-quote-char] {digit}
        exitLabeledAlt: decimal-literalsimple-quote-char?digit
      exitRuleAltList: nonzero-digit|decimal-literalsimple-quote-char?digit
    exitRuleBlock: nonzero-digit|decimal-literalsimple-quote-char?digit
  exitRuleSpec: decimal-literal:nonzero-digit|decimal-literalsimple-quote-char?digit;

  enterRuleSpec: hexadecimal-literal:hexadecimal-prefixhexadecimal-digit-sequence;
    enterRuleBlock: hexadecimal-prefixhexadecimal-digit-sequence
      enterRuleAltList: hexadecimal-prefixhexadecimal-digit-sequence
        enterLabeledAlt: hexadecimal-prefixhexadecimal-digit-sequence
          enterAlternative: hexadecimal-prefixhexadecimal-digit-sequence
            enterElement: hexadecimal-prefix
              => element -> {hexadecimal-prefix}
              enterAtom: hexadecimal-prefix
                enterRuleref: hexadecimal-prefix
                exitRuleref: hexadecimal-prefix
              exitAtom: hexadecimal-prefix
            exitElement: hexadecimal-prefix
            enterElement: hexadecimal-digit-sequence
              => element -> {hexadecimal-digit-sequence}
              enterAtom: hexadecimal-digit-sequence
                enterRuleref: hexadecimal-digit-sequence
                exitRuleref: hexadecimal-digit-sequence
              exitAtom: hexadecimal-digit-sequence
            exitElement: hexadecimal-digit-sequence
          exitAlternative: hexadecimal-prefixhexadecimal-digit-sequence
        => elements -> ['{hexadecimal-prefix}', '{hexadecimal-digit-sequence}']
            => alternative -> {hexadecimal-prefix} {hexadecimal-digit-sequence}
        exitLabeledAlt: hexadecimal-prefixhexadecimal-digit-sequence
      exitRuleAltList: hexadecimal-prefixhexadecimal-digit-sequence
    exitRuleBlock: hexadecimal-prefixhexadecimal-digit-sequence
  exitRuleSpec: hexadecimal-literal:hexadecimal-prefixhexadecimal-digit-sequence;

  enterRuleSpec: binary-digit:'0'|'1';
    enterRuleBlock: '0'|'1'
      enterRuleAltList: '0'|'1'
        enterLabeledAlt: '0'
          enterAlternative: '0'
            enterElement: '0'
              => element -> 0
              enterAtom: '0'
                enterTerminal: '0'
                exitTerminal: '0'
              exitAtom: '0'
            exitElement: '0'
          exitAlternative: '0'
        => elements -> ['0']
            => alternative -> 0
        exitLabeledAlt: '0'
        enterLabeledAlt: '1'
          enterAlternative: '1'
            enterElement: '1'
              => element -> 1
              enterAtom: '1'
                enterTerminal: '1'
                exitTerminal: '1'
              exitAtom: '1'
            exitElement: '1'
          exitAlternative: '1'
        => elements -> ['1']
            => alternative -> 1
        exitLabeledAlt: '1'
      exitRuleAltList: '0'|'1'
    exitRuleBlock: '0'|'1'
  exitRuleSpec: binary-digit:'0'|'1';

  enterRuleSpec: octal-digit:'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7';
    enterRuleBlock: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'
      enterRuleAltList: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'
        enterLabeledAlt: '0'
          enterAlternative: '0'
            enterElement: '0'
              => element -> 0
              enterAtom: '0'
                enterTerminal: '0'
                exitTerminal: '0'
              exitAtom: '0'
            exitElement: '0'
          exitAlternative: '0'
        => elements -> ['0']
            => alternative -> 0
        exitLabeledAlt: '0'
        enterLabeledAlt: '1'
          enterAlternative: '1'
            enterElement: '1'
              => element -> 1
              enterAtom: '1'
                enterTerminal: '1'
                exitTerminal: '1'
              exitAtom: '1'
            exitElement: '1'
          exitAlternative: '1'
        => elements -> ['1']
            => alternative -> 1
        exitLabeledAlt: '1'
        enterLabeledAlt: '2'
          enterAlternative: '2'
            enterElement: '2'
              => element -> 2
              enterAtom: '2'
                enterTerminal: '2'
                exitTerminal: '2'
              exitAtom: '2'
            exitElement: '2'
          exitAlternative: '2'
        => elements -> ['2']
            => alternative -> 2
        exitLabeledAlt: '2'
        enterLabeledAlt: '3'
          enterAlternative: '3'
            enterElement: '3'
              => element -> 3
              enterAtom: '3'
                enterTerminal: '3'
                exitTerminal: '3'
              exitAtom: '3'
            exitElement: '3'
          exitAlternative: '3'
        => elements -> ['3']
            => alternative -> 3
        exitLabeledAlt: '3'
        enterLabeledAlt: '4'
          enterAlternative: '4'
            enterElement: '4'
              => element -> 4
              enterAtom: '4'
                enterTerminal: '4'
                exitTerminal: '4'
              exitAtom: '4'
            exitElement: '4'
          exitAlternative: '4'
        => elements -> ['4']
            => alternative -> 4
        exitLabeledAlt: '4'
        enterLabeledAlt: '5'
          enterAlternative: '5'
            enterElement: '5'
              => element -> 5
              enterAtom: '5'
                enterTerminal: '5'
                exitTerminal: '5'
              exitAtom: '5'
            exitElement: '5'
          exitAlternative: '5'
        => elements -> ['5']
            => alternative -> 5
        exitLabeledAlt: '5'
        enterLabeledAlt: '6'
          enterAlternative: '6'
            enterElement: '6'
              => element -> 6
              enterAtom: '6'
                enterTerminal: '6'
                exitTerminal: '6'
              exitAtom: '6'
            exitElement: '6'
          exitAlternative: '6'
        => elements -> ['6']
            => alternative -> 6
        exitLabeledAlt: '6'
        enterLabeledAlt: '7'
          enterAlternative: '7'
            enterElement: '7'
              => element -> 7
              enterAtom: '7'
                enterTerminal: '7'
                exitTerminal: '7'
              exitAtom: '7'
            exitElement: '7'
          exitAlternative: '7'
        => elements -> ['7']
            => alternative -> 7
        exitLabeledAlt: '7'
      exitRuleAltList: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'
    exitRuleBlock: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'
  exitRuleSpec: octal-digit:'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7';

  enterRuleSpec: nonzero-digit:'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9';
    enterRuleBlock: '1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
      enterRuleAltList: '1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
        enterLabeledAlt: '1'
          enterAlternative: '1'
            enterElement: '1'
              => element -> 1
              enterAtom: '1'
                enterTerminal: '1'
                exitTerminal: '1'
              exitAtom: '1'
            exitElement: '1'
          exitAlternative: '1'
        => elements -> ['1']
            => alternative -> 1
        exitLabeledAlt: '1'
        enterLabeledAlt: '2'
          enterAlternative: '2'
            enterElement: '2'
              => element -> 2
              enterAtom: '2'
                enterTerminal: '2'
                exitTerminal: '2'
              exitAtom: '2'
            exitElement: '2'
          exitAlternative: '2'
        => elements -> ['2']
            => alternative -> 2
        exitLabeledAlt: '2'
        enterLabeledAlt: '3'
          enterAlternative: '3'
            enterElement: '3'
              => element -> 3
              enterAtom: '3'
                enterTerminal: '3'
                exitTerminal: '3'
              exitAtom: '3'
            exitElement: '3'
          exitAlternative: '3'
        => elements -> ['3']
            => alternative -> 3
        exitLabeledAlt: '3'
        enterLabeledAlt: '4'
          enterAlternative: '4'
            enterElement: '4'
              => element -> 4
              enterAtom: '4'
                enterTerminal: '4'
                exitTerminal: '4'
              exitAtom: '4'
            exitElement: '4'
          exitAlternative: '4'
        => elements -> ['4']
            => alternative -> 4
        exitLabeledAlt: '4'
        enterLabeledAlt: '5'
          enterAlternative: '5'
            enterElement: '5'
              => element -> 5
              enterAtom: '5'
                enterTerminal: '5'
                exitTerminal: '5'
              exitAtom: '5'
            exitElement: '5'
          exitAlternative: '5'
        => elements -> ['5']
            => alternative -> 5
        exitLabeledAlt: '5'
        enterLabeledAlt: '6'
          enterAlternative: '6'
            enterElement: '6'
              => element -> 6
              enterAtom: '6'
                enterTerminal: '6'
                exitTerminal: '6'
              exitAtom: '6'
            exitElement: '6'
          exitAlternative: '6'
        => elements -> ['6']
            => alternative -> 6
        exitLabeledAlt: '6'
        enterLabeledAlt: '7'
          enterAlternative: '7'
            enterElement: '7'
              => element -> 7
              enterAtom: '7'
                enterTerminal: '7'
                exitTerminal: '7'
              exitAtom: '7'
            exitElement: '7'
          exitAlternative: '7'
        => elements -> ['7']
            => alternative -> 7
        exitLabeledAlt: '7'
        enterLabeledAlt: '8'
          enterAlternative: '8'
            enterElement: '8'
              => element -> 8
              enterAtom: '8'
                enterTerminal: '8'
                exitTerminal: '8'
              exitAtom: '8'
            exitElement: '8'
          exitAlternative: '8'
        => elements -> ['8']
            => alternative -> 8
        exitLabeledAlt: '8'
        enterLabeledAlt: '9'
          enterAlternative: '9'
            enterElement: '9'
              => element -> 9
              enterAtom: '9'
                enterTerminal: '9'
                exitTerminal: '9'
              exitAtom: '9'
            exitElement: '9'
          exitAlternative: '9'
        => elements -> ['9']
            => alternative -> 9
        exitLabeledAlt: '9'
      exitRuleAltList: '1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
    exitRuleBlock: '1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
  exitRuleSpec: nonzero-digit:'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9';

  enterRuleSpec: hexadecimal-prefix:'0x'|'0X';
    enterRuleBlock: '0x'|'0X'
      enterRuleAltList: '0x'|'0X'
        enterLabeledAlt: '0x'
          enterAlternative: '0x'
            enterElement: '0x'
              => element -> 0x
              enterAtom: '0x'
                enterTerminal: '0x'
                exitTerminal: '0x'
              exitAtom: '0x'
            exitElement: '0x'
          exitAlternative: '0x'
        => elements -> ['0x']
            => alternative -> 0x
        exitLabeledAlt: '0x'
        enterLabeledAlt: '0X'
          enterAlternative: '0X'
            enterElement: '0X'
              => element -> 0X
              enterAtom: '0X'
                enterTerminal: '0X'
                exitTerminal: '0X'
              exitAtom: '0X'
            exitElement: '0X'
          exitAlternative: '0X'
        => elements -> ['0X']
            => alternative -> 0X
        exitLabeledAlt: '0X'
      exitRuleAltList: '0x'|'0X'
    exitRuleBlock: '0x'|'0X'
  exitRuleSpec: hexadecimal-prefix:'0x'|'0X';

  enterRuleSpec: hexadecimal-digit-sequence:hexadecimal-digit|hexadecimal-digit-sequencesimple-quote-char?hexadecimal-digit;
    enterRuleBlock: hexadecimal-digit|hexadecimal-digit-sequencesimple-quote-char?hexadecimal-digit
      enterRuleAltList: hexadecimal-digit|hexadecimal-digit-sequencesimple-quote-char?hexadecimal-digit
        enterLabeledAlt: hexadecimal-digit
          enterAlternative: hexadecimal-digit
            enterElement: hexadecimal-digit
              => element -> {hexadecimal-digit}
              enterAtom: hexadecimal-digit
                enterRuleref: hexadecimal-digit
                exitRuleref: hexadecimal-digit
              exitAtom: hexadecimal-digit
            exitElement: hexadecimal-digit
          exitAlternative: hexadecimal-digit
        => elements -> ['{hexadecimal-digit}']
            => alternative -> {hexadecimal-digit}
        exitLabeledAlt: hexadecimal-digit
        enterLabeledAlt: hexadecimal-digit-sequencesimple-quote-char?hexadecimal-digit
          enterAlternative: hexadecimal-digit-sequencesimple-quote-char?hexadecimal-digit
            enterElement: hexadecimal-digit-sequence
              => element -> {hexadecimal-digit-sequence}
              enterAtom: hexadecimal-digit-sequence
                enterRuleref: hexadecimal-digit-sequence
                exitRuleref: hexadecimal-digit-sequence
              exitAtom: hexadecimal-digit-sequence
            exitElement: hexadecimal-digit-sequence
            enterElement: simple-quote-char?
              => element -> [simple-quote-char]
              enterAtom: simple-quote-char
                enterRuleref: simple-quote-char
                exitRuleref: simple-quote-char
              exitAtom: simple-quote-char
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: simple-quote-char?
            enterElement: hexadecimal-digit
              => element -> {hexadecimal-digit}
              enterAtom: hexadecimal-digit
                enterRuleref: hexadecimal-digit
                exitRuleref: hexadecimal-digit
              exitAtom: hexadecimal-digit
            exitElement: hexadecimal-digit
          exitAlternative: hexadecimal-digit-sequencesimple-quote-char?hexadecimal-digit
        => elements -> ['{hexadecimal-digit-sequence}', '[simple-quote-char]', '{hexadecimal-digit}']
            => alternative -> {hexadecimal-digit-sequence} [simple-quote-char] {hexadecimal-digit}
        exitLabeledAlt: hexadecimal-digit-sequencesimple-quote-char?hexadecimal-digit
      exitRuleAltList: hexadecimal-digit|hexadecimal-digit-sequencesimple-quote-char?hexadecimal-digit
    exitRuleBlock: hexadecimal-digit|hexadecimal-digit-sequencesimple-quote-char?hexadecimal-digit
  exitRuleSpec: hexadecimal-digit-sequence:hexadecimal-digit|hexadecimal-digit-sequencesimple-quote-char?hexadecimal-digit;

  enterRuleSpec: hexadecimal-digit:'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'a'|'b'|'c'|'d'|'e'|'f'|'A'|'B'|'C'|'D'|'E'|'F';
    enterRuleBlock: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'a'|'b'|'c'|'d'|'e'|'f'|'A'|'B'|'C'|'D'|'E'|'F'
      enterRuleAltList: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'a'|'b'|'c'|'d'|'e'|'f'|'A'|'B'|'C'|'D'|'E'|'F'
        enterLabeledAlt: '0'
          enterAlternative: '0'
            enterElement: '0'
              => element -> 0
              enterAtom: '0'
                enterTerminal: '0'
                exitTerminal: '0'
              exitAtom: '0'
            exitElement: '0'
          exitAlternative: '0'
        => elements -> ['0']
            => alternative -> 0
        exitLabeledAlt: '0'
        enterLabeledAlt: '1'
          enterAlternative: '1'
            enterElement: '1'
              => element -> 1
              enterAtom: '1'
                enterTerminal: '1'
                exitTerminal: '1'
              exitAtom: '1'
            exitElement: '1'
          exitAlternative: '1'
        => elements -> ['1']
            => alternative -> 1
        exitLabeledAlt: '1'
        enterLabeledAlt: '2'
          enterAlternative: '2'
            enterElement: '2'
              => element -> 2
              enterAtom: '2'
                enterTerminal: '2'
                exitTerminal: '2'
              exitAtom: '2'
            exitElement: '2'
          exitAlternative: '2'
        => elements -> ['2']
            => alternative -> 2
        exitLabeledAlt: '2'
        enterLabeledAlt: '3'
          enterAlternative: '3'
            enterElement: '3'
              => element -> 3
              enterAtom: '3'
                enterTerminal: '3'
                exitTerminal: '3'
              exitAtom: '3'
            exitElement: '3'
          exitAlternative: '3'
        => elements -> ['3']
            => alternative -> 3
        exitLabeledAlt: '3'
        enterLabeledAlt: '4'
          enterAlternative: '4'
            enterElement: '4'
              => element -> 4
              enterAtom: '4'
                enterTerminal: '4'
                exitTerminal: '4'
              exitAtom: '4'
            exitElement: '4'
          exitAlternative: '4'
        => elements -> ['4']
            => alternative -> 4
        exitLabeledAlt: '4'
        enterLabeledAlt: '5'
          enterAlternative: '5'
            enterElement: '5'
              => element -> 5
              enterAtom: '5'
                enterTerminal: '5'
                exitTerminal: '5'
              exitAtom: '5'
            exitElement: '5'
          exitAlternative: '5'
        => elements -> ['5']
            => alternative -> 5
        exitLabeledAlt: '5'
        enterLabeledAlt: '6'
          enterAlternative: '6'
            enterElement: '6'
              => element -> 6
              enterAtom: '6'
                enterTerminal: '6'
                exitTerminal: '6'
              exitAtom: '6'
            exitElement: '6'
          exitAlternative: '6'
        => elements -> ['6']
            => alternative -> 6
        exitLabeledAlt: '6'
        enterLabeledAlt: '7'
          enterAlternative: '7'
            enterElement: '7'
              => element -> 7
              enterAtom: '7'
                enterTerminal: '7'
                exitTerminal: '7'
              exitAtom: '7'
            exitElement: '7'
          exitAlternative: '7'
        => elements -> ['7']
            => alternative -> 7
        exitLabeledAlt: '7'
        enterLabeledAlt: '8'
          enterAlternative: '8'
            enterElement: '8'
              => element -> 8
              enterAtom: '8'
                enterTerminal: '8'
                exitTerminal: '8'
              exitAtom: '8'
            exitElement: '8'
          exitAlternative: '8'
        => elements -> ['8']
            => alternative -> 8
        exitLabeledAlt: '8'
        enterLabeledAlt: '9'
          enterAlternative: '9'
            enterElement: '9'
              => element -> 9
              enterAtom: '9'
                enterTerminal: '9'
                exitTerminal: '9'
              exitAtom: '9'
            exitElement: '9'
          exitAlternative: '9'
        => elements -> ['9']
            => alternative -> 9
        exitLabeledAlt: '9'
        enterLabeledAlt: 'a'
          enterAlternative: 'a'
            enterElement: 'a'
              => element -> a
              enterAtom: 'a'
                enterTerminal: 'a'
                exitTerminal: 'a'
              exitAtom: 'a'
            exitElement: 'a'
          exitAlternative: 'a'
        => elements -> ['a']
            => alternative -> a
        exitLabeledAlt: 'a'
        enterLabeledAlt: 'b'
          enterAlternative: 'b'
            enterElement: 'b'
              => element -> b
              enterAtom: 'b'
                enterTerminal: 'b'
                exitTerminal: 'b'
              exitAtom: 'b'
            exitElement: 'b'
          exitAlternative: 'b'
        => elements -> ['b']
            => alternative -> b
        exitLabeledAlt: 'b'
        enterLabeledAlt: 'c'
          enterAlternative: 'c'
            enterElement: 'c'
              => element -> c
              enterAtom: 'c'
                enterTerminal: 'c'
                exitTerminal: 'c'
              exitAtom: 'c'
            exitElement: 'c'
          exitAlternative: 'c'
        => elements -> ['c']
            => alternative -> c
        exitLabeledAlt: 'c'
        enterLabeledAlt: 'd'
          enterAlternative: 'd'
            enterElement: 'd'
              => element -> d
              enterAtom: 'd'
                enterTerminal: 'd'
                exitTerminal: 'd'
              exitAtom: 'd'
            exitElement: 'd'
          exitAlternative: 'd'
        => elements -> ['d']
            => alternative -> d
        exitLabeledAlt: 'd'
        enterLabeledAlt: 'e'
          enterAlternative: 'e'
            enterElement: 'e'
              => element -> e
              enterAtom: 'e'
                enterTerminal: 'e'
                exitTerminal: 'e'
              exitAtom: 'e'
            exitElement: 'e'
          exitAlternative: 'e'
        => elements -> ['e']
            => alternative -> e
        exitLabeledAlt: 'e'
        enterLabeledAlt: 'f'
          enterAlternative: 'f'
            enterElement: 'f'
              => element -> f
              enterAtom: 'f'
                enterTerminal: 'f'
                exitTerminal: 'f'
              exitAtom: 'f'
            exitElement: 'f'
          exitAlternative: 'f'
        => elements -> ['f']
            => alternative -> f
        exitLabeledAlt: 'f'
        enterLabeledAlt: 'A'
          enterAlternative: 'A'
            enterElement: 'A'
              => element -> A
              enterAtom: 'A'
                enterTerminal: 'A'
                exitTerminal: 'A'
              exitAtom: 'A'
            exitElement: 'A'
          exitAlternative: 'A'
        => elements -> ['A']
            => alternative -> A
        exitLabeledAlt: 'A'
        enterLabeledAlt: 'B'
          enterAlternative: 'B'
            enterElement: 'B'
              => element -> B
              enterAtom: 'B'
                enterTerminal: 'B'
                exitTerminal: 'B'
              exitAtom: 'B'
            exitElement: 'B'
          exitAlternative: 'B'
        => elements -> ['B']
            => alternative -> B
        exitLabeledAlt: 'B'
        enterLabeledAlt: 'C'
          enterAlternative: 'C'
            enterElement: 'C'
              => element -> C
              enterAtom: 'C'
                enterTerminal: 'C'
                exitTerminal: 'C'
              exitAtom: 'C'
            exitElement: 'C'
          exitAlternative: 'C'
        => elements -> ['C']
            => alternative -> C
        exitLabeledAlt: 'C'
        enterLabeledAlt: 'D'
          enterAlternative: 'D'
            enterElement: 'D'
              => element -> D
              enterAtom: 'D'
                enterTerminal: 'D'
                exitTerminal: 'D'
              exitAtom: 'D'
            exitElement: 'D'
          exitAlternative: 'D'
        => elements -> ['D']
            => alternative -> D
        exitLabeledAlt: 'D'
        enterLabeledAlt: 'E'
          enterAlternative: 'E'
            enterElement: 'E'
              => element -> E
              enterAtom: 'E'
                enterTerminal: 'E'
                exitTerminal: 'E'
              exitAtom: 'E'
            exitElement: 'E'
          exitAlternative: 'E'
        => elements -> ['E']
            => alternative -> E
        exitLabeledAlt: 'E'
        enterLabeledAlt: 'F'
          enterAlternative: 'F'
            enterElement: 'F'
              => element -> F
              enterAtom: 'F'
                enterTerminal: 'F'
                exitTerminal: 'F'
              exitAtom: 'F'
            exitElement: 'F'
          exitAlternative: 'F'
        => elements -> ['F']
            => alternative -> F
        exitLabeledAlt: 'F'
      exitRuleAltList: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'a'|'b'|'c'|'d'|'e'|'f'|'A'|'B'|'C'|'D'|'E'|'F'
    exitRuleBlock: '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'a'|'b'|'c'|'d'|'e'|'f'|'A'|'B'|'C'|'D'|'E'|'F'
  exitRuleSpec: hexadecimal-digit:'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'a'|'b'|'c'|'d'|'e'|'f'|'A'|'B'|'C'|'D'|'E'|'F';

  enterRuleSpec: integer-suffix:unsigned-suffixlong-suffix?|unsigned-suffixlong-long-suffix?|unsigned-suffixsize-suffix?|long-suffixunsigned-suffix?|long-long-suffixunsigned-suffix?|size-suffixunsigned-suffix?;
    enterRuleBlock: unsigned-suffixlong-suffix?|unsigned-suffixlong-long-suffix?|unsigned-suffixsize-suffix?|long-suffixunsigned-suffix?|long-long-suffixunsigned-suffix?|size-suffixunsigned-suffix?
      enterRuleAltList: unsigned-suffixlong-suffix?|unsigned-suffixlong-long-suffix?|unsigned-suffixsize-suffix?|long-suffixunsigned-suffix?|long-long-suffixunsigned-suffix?|size-suffixunsigned-suffix?
        enterLabeledAlt: unsigned-suffixlong-suffix?
          enterAlternative: unsigned-suffixlong-suffix?
            enterElement: unsigned-suffix
              => element -> {unsigned-suffix}
              enterAtom: unsigned-suffix
                enterRuleref: unsigned-suffix
                exitRuleref: unsigned-suffix
              exitAtom: unsigned-suffix
            exitElement: unsigned-suffix
            enterElement: long-suffix?
              => element -> [long-suffix]
              enterAtom: long-suffix
                enterRuleref: long-suffix
                exitRuleref: long-suffix
              exitAtom: long-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: long-suffix?
          exitAlternative: unsigned-suffixlong-suffix?
        => elements -> ['{unsigned-suffix}', '[long-suffix]']
            => alternative -> {unsigned-suffix} [long-suffix]
        exitLabeledAlt: unsigned-suffixlong-suffix?
        enterLabeledAlt: unsigned-suffixlong-long-suffix?
          enterAlternative: unsigned-suffixlong-long-suffix?
            enterElement: unsigned-suffix
              => element -> {unsigned-suffix}
              enterAtom: unsigned-suffix
                enterRuleref: unsigned-suffix
                exitRuleref: unsigned-suffix
              exitAtom: unsigned-suffix
            exitElement: unsigned-suffix
            enterElement: long-long-suffix?
              => element -> [long-long-suffix]
              enterAtom: long-long-suffix
                enterRuleref: long-long-suffix
                exitRuleref: long-long-suffix
              exitAtom: long-long-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: long-long-suffix?
          exitAlternative: unsigned-suffixlong-long-suffix?
        => elements -> ['{unsigned-suffix}', '[long-long-suffix]']
            => alternative -> {unsigned-suffix} [long-long-suffix]
        exitLabeledAlt: unsigned-suffixlong-long-suffix?
        enterLabeledAlt: unsigned-suffixsize-suffix?
          enterAlternative: unsigned-suffixsize-suffix?
            enterElement: unsigned-suffix
              => element -> {unsigned-suffix}
              enterAtom: unsigned-suffix
                enterRuleref: unsigned-suffix
                exitRuleref: unsigned-suffix
              exitAtom: unsigned-suffix
            exitElement: unsigned-suffix
            enterElement: size-suffix?
              => element -> [size-suffix]
              enterAtom: size-suffix
                enterRuleref: size-suffix
                exitRuleref: size-suffix
              exitAtom: size-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: size-suffix?
          exitAlternative: unsigned-suffixsize-suffix?
        => elements -> ['{unsigned-suffix}', '[size-suffix]']
            => alternative -> {unsigned-suffix} [size-suffix]
        exitLabeledAlt: unsigned-suffixsize-suffix?
        enterLabeledAlt: long-suffixunsigned-suffix?
          enterAlternative: long-suffixunsigned-suffix?
            enterElement: long-suffix
              => element -> {long-suffix}
              enterAtom: long-suffix
                enterRuleref: long-suffix
                exitRuleref: long-suffix
              exitAtom: long-suffix
            exitElement: long-suffix
            enterElement: unsigned-suffix?
              => element -> [unsigned-suffix]
              enterAtom: unsigned-suffix
                enterRuleref: unsigned-suffix
                exitRuleref: unsigned-suffix
              exitAtom: unsigned-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: unsigned-suffix?
          exitAlternative: long-suffixunsigned-suffix?
        => elements -> ['{long-suffix}', '[unsigned-suffix]']
            => alternative -> {long-suffix} [unsigned-suffix]
        exitLabeledAlt: long-suffixunsigned-suffix?
        enterLabeledAlt: long-long-suffixunsigned-suffix?
          enterAlternative: long-long-suffixunsigned-suffix?
            enterElement: long-long-suffix
              => element -> {long-long-suffix}
              enterAtom: long-long-suffix
                enterRuleref: long-long-suffix
                exitRuleref: long-long-suffix
              exitAtom: long-long-suffix
            exitElement: long-long-suffix
            enterElement: unsigned-suffix?
              => element -> [unsigned-suffix]
              enterAtom: unsigned-suffix
                enterRuleref: unsigned-suffix
                exitRuleref: unsigned-suffix
              exitAtom: unsigned-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: unsigned-suffix?
          exitAlternative: long-long-suffixunsigned-suffix?
        => elements -> ['{long-long-suffix}', '[unsigned-suffix]']
            => alternative -> {long-long-suffix} [unsigned-suffix]
        exitLabeledAlt: long-long-suffixunsigned-suffix?
        enterLabeledAlt: size-suffixunsigned-suffix?
          enterAlternative: size-suffixunsigned-suffix?
            enterElement: size-suffix
              => element -> {size-suffix}
              enterAtom: size-suffix
                enterRuleref: size-suffix
                exitRuleref: size-suffix
              exitAtom: size-suffix
            exitElement: size-suffix
            enterElement: unsigned-suffix?
              => element -> [unsigned-suffix]
              enterAtom: unsigned-suffix
                enterRuleref: unsigned-suffix
                exitRuleref: unsigned-suffix
              exitAtom: unsigned-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: unsigned-suffix?
          exitAlternative: size-suffixunsigned-suffix?
        => elements -> ['{size-suffix}', '[unsigned-suffix]']
            => alternative -> {size-suffix} [unsigned-suffix]
        exitLabeledAlt: size-suffixunsigned-suffix?
      exitRuleAltList: unsigned-suffixlong-suffix?|unsigned-suffixlong-long-suffix?|unsigned-suffixsize-suffix?|long-suffixunsigned-suffix?|long-long-suffixunsigned-suffix?|size-suffixunsigned-suffix?
    exitRuleBlock: unsigned-suffixlong-suffix?|unsigned-suffixlong-long-suffix?|unsigned-suffixsize-suffix?|long-suffixunsigned-suffix?|long-long-suffixunsigned-suffix?|size-suffixunsigned-suffix?
  exitRuleSpec: integer-suffix:unsigned-suffixlong-suffix?|unsigned-suffixlong-long-suffix?|unsigned-suffixsize-suffix?|long-suffixunsigned-suffix?|long-long-suffixunsigned-suffix?|size-suffixunsigned-suffix?;

  enterRuleSpec: unsigned-suffix:'u'|'U';
    enterRuleBlock: 'u'|'U'
      enterRuleAltList: 'u'|'U'
        enterLabeledAlt: 'u'
          enterAlternative: 'u'
            enterElement: 'u'
              => element -> u
              enterAtom: 'u'
                enterTerminal: 'u'
                exitTerminal: 'u'
              exitAtom: 'u'
            exitElement: 'u'
          exitAlternative: 'u'
        => elements -> ['u']
            => alternative -> u
        exitLabeledAlt: 'u'
        enterLabeledAlt: 'U'
          enterAlternative: 'U'
            enterElement: 'U'
              => element -> U
              enterAtom: 'U'
                enterTerminal: 'U'
                exitTerminal: 'U'
              exitAtom: 'U'
            exitElement: 'U'
          exitAlternative: 'U'
        => elements -> ['U']
            => alternative -> U
        exitLabeledAlt: 'U'
      exitRuleAltList: 'u'|'U'
    exitRuleBlock: 'u'|'U'
  exitRuleSpec: unsigned-suffix:'u'|'U';

  enterRuleSpec: long-suffix:'l'|'L';
    enterRuleBlock: 'l'|'L'
      enterRuleAltList: 'l'|'L'
        enterLabeledAlt: 'l'
          enterAlternative: 'l'
            enterElement: 'l'
              => element -> l
              enterAtom: 'l'
                enterTerminal: 'l'
                exitTerminal: 'l'
              exitAtom: 'l'
            exitElement: 'l'
          exitAlternative: 'l'
        => elements -> ['l']
            => alternative -> l
        exitLabeledAlt: 'l'
        enterLabeledAlt: 'L'
          enterAlternative: 'L'
            enterElement: 'L'
              => element -> L
              enterAtom: 'L'
                enterTerminal: 'L'
                exitTerminal: 'L'
              exitAtom: 'L'
            exitElement: 'L'
          exitAlternative: 'L'
        => elements -> ['L']
            => alternative -> L
        exitLabeledAlt: 'L'
      exitRuleAltList: 'l'|'L'
    exitRuleBlock: 'l'|'L'
  exitRuleSpec: long-suffix:'l'|'L';

  enterRuleSpec: long-long-suffix:'ll'|'LL';
    enterRuleBlock: 'll'|'LL'
      enterRuleAltList: 'll'|'LL'
        enterLabeledAlt: 'll'
          enterAlternative: 'll'
            enterElement: 'll'
              => element -> ll
              enterAtom: 'll'
                enterTerminal: 'll'
                exitTerminal: 'll'
              exitAtom: 'll'
            exitElement: 'll'
          exitAlternative: 'll'
        => elements -> ['ll']
            => alternative -> ll
        exitLabeledAlt: 'll'
        enterLabeledAlt: 'LL'
          enterAlternative: 'LL'
            enterElement: 'LL'
              => element -> LL
              enterAtom: 'LL'
                enterTerminal: 'LL'
                exitTerminal: 'LL'
              exitAtom: 'LL'
            exitElement: 'LL'
          exitAlternative: 'LL'
        => elements -> ['LL']
            => alternative -> LL
        exitLabeledAlt: 'LL'
      exitRuleAltList: 'll'|'LL'
    exitRuleBlock: 'll'|'LL'
  exitRuleSpec: long-long-suffix:'ll'|'LL';

  enterRuleSpec: size-suffix:'z'|'Z';
    enterRuleBlock: 'z'|'Z'
      enterRuleAltList: 'z'|'Z'
        enterLabeledAlt: 'z'
          enterAlternative: 'z'
            enterElement: 'z'
              => element -> z
              enterAtom: 'z'
                enterTerminal: 'z'
                exitTerminal: 'z'
              exitAtom: 'z'
            exitElement: 'z'
          exitAlternative: 'z'
        => elements -> ['z']
            => alternative -> z
        exitLabeledAlt: 'z'
        enterLabeledAlt: 'Z'
          enterAlternative: 'Z'
            enterElement: 'Z'
              => element -> Z
              enterAtom: 'Z'
                enterTerminal: 'Z'
                exitTerminal: 'Z'
              exitAtom: 'Z'
            exitElement: 'Z'
          exitAlternative: 'Z'
        => elements -> ['Z']
            => alternative -> Z
        exitLabeledAlt: 'Z'
      exitRuleAltList: 'z'|'Z'
    exitRuleBlock: 'z'|'Z'
  exitRuleSpec: size-suffix:'z'|'Z';

  enterRuleSpec: character-literal:encoding-prefix?'\''c-char+'\'';
    enterRuleBlock: encoding-prefix?'\''c-char+'\''
      enterRuleAltList: encoding-prefix?'\''c-char+'\''
        enterLabeledAlt: encoding-prefix?'\''c-char+'\''
          enterAlternative: encoding-prefix?'\''c-char+'\''
            enterElement: encoding-prefix?
              => element -> [encoding-prefix]
              enterAtom: encoding-prefix
                enterRuleref: encoding-prefix
                exitRuleref: encoding-prefix
              exitAtom: encoding-prefix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: encoding-prefix?
            enterElement: '\''
              => element -> \'
              enterAtom: '\''
                enterTerminal: '\''
                exitTerminal: '\''
              exitAtom: '\''
            exitElement: '\''
            enterElement: c-char+
              => element -> {c-char}...
              enterAtom: c-char
                enterRuleref: c-char
                exitRuleref: c-char
              exitAtom: c-char
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: c-char+
            enterElement: '\''
              => element -> \'
              enterAtom: '\''
                enterTerminal: '\''
                exitTerminal: '\''
              exitAtom: '\''
            exitElement: '\''
          exitAlternative: encoding-prefix?'\''c-char+'\''
        => elements -> ['[encoding-prefix]', "\\'", '{c-char}...', "\\'"]
            => alternative -> [encoding-prefix] \' {c-char}... \'
        exitLabeledAlt: encoding-prefix?'\''c-char+'\''
      exitRuleAltList: encoding-prefix?'\''c-char+'\''
    exitRuleBlock: encoding-prefix?'\''c-char+'\''
  exitRuleSpec: character-literal:encoding-prefix?'\''c-char+'\'';

  enterRuleSpec: encoding-prefix:'u8'|'u'|'U'|'L';
    enterRuleBlock: 'u8'|'u'|'U'|'L'
      enterRuleAltList: 'u8'|'u'|'U'|'L'
        enterLabeledAlt: 'u8'
          enterAlternative: 'u8'
            enterElement: 'u8'
              => element -> u8
              enterAtom: 'u8'
                enterTerminal: 'u8'
                exitTerminal: 'u8'
              exitAtom: 'u8'
            exitElement: 'u8'
          exitAlternative: 'u8'
        => elements -> ['u8']
            => alternative -> u8
        exitLabeledAlt: 'u8'
        enterLabeledAlt: 'u'
          enterAlternative: 'u'
            enterElement: 'u'
              => element -> u
              enterAtom: 'u'
                enterTerminal: 'u'
                exitTerminal: 'u'
              exitAtom: 'u'
            exitElement: 'u'
          exitAlternative: 'u'
        => elements -> ['u']
            => alternative -> u
        exitLabeledAlt: 'u'
        enterLabeledAlt: 'U'
          enterAlternative: 'U'
            enterElement: 'U'
              => element -> U
              enterAtom: 'U'
                enterTerminal: 'U'
                exitTerminal: 'U'
              exitAtom: 'U'
            exitElement: 'U'
          exitAlternative: 'U'
        => elements -> ['U']
            => alternative -> U
        exitLabeledAlt: 'U'
        enterLabeledAlt: 'L'
          enterAlternative: 'L'
            enterElement: 'L'
              => element -> L
              enterAtom: 'L'
                enterTerminal: 'L'
                exitTerminal: 'L'
              exitAtom: 'L'
            exitElement: 'L'
          exitAlternative: 'L'
        => elements -> ['L']
            => alternative -> L
        exitLabeledAlt: 'L'
      exitRuleAltList: 'u8'|'u'|'U'|'L'
    exitRuleBlock: 'u8'|'u'|'U'|'L'
  exitRuleSpec: encoding-prefix:'u8'|'u'|'U'|'L';

  enterRuleSpec: c-char:basic-c-char|escape-sequence|universal-character-name;
    enterRuleBlock: basic-c-char|escape-sequence|universal-character-name
      enterRuleAltList: basic-c-char|escape-sequence|universal-character-name
        enterLabeledAlt: basic-c-char
          enterAlternative: basic-c-char
            enterElement: basic-c-char
              => element -> {basic-c-char}
              enterAtom: basic-c-char
                enterRuleref: basic-c-char
                exitRuleref: basic-c-char
              exitAtom: basic-c-char
            exitElement: basic-c-char
          exitAlternative: basic-c-char
        => elements -> ['{basic-c-char}']
            => alternative -> {basic-c-char}
        exitLabeledAlt: basic-c-char
        enterLabeledAlt: escape-sequence
          enterAlternative: escape-sequence
            enterElement: escape-sequence
              => element -> {escape-sequence}
              enterAtom: escape-sequence
                enterRuleref: escape-sequence
                exitRuleref: escape-sequence
              exitAtom: escape-sequence
            exitElement: escape-sequence
          exitAlternative: escape-sequence
        => elements -> ['{escape-sequence}']
            => alternative -> {escape-sequence}
        exitLabeledAlt: escape-sequence
        enterLabeledAlt: universal-character-name
          enterAlternative: universal-character-name
            enterElement: universal-character-name
              => element -> {universal-character-name}
              enterAtom: universal-character-name
                enterRuleref: universal-character-name
                exitRuleref: universal-character-name
              exitAtom: universal-character-name
            exitElement: universal-character-name
          exitAlternative: universal-character-name
        => elements -> ['{universal-character-name}']
            => alternative -> {universal-character-name}
        exitLabeledAlt: universal-character-name
      exitRuleAltList: basic-c-char|escape-sequence|universal-character-name
    exitRuleBlock: basic-c-char|escape-sequence|universal-character-name
  exitRuleSpec: c-char:basic-c-char|escape-sequence|universal-character-name;

  enterRuleSpec: basic-c-char:'<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>';
    enterRuleBlock: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
      enterRuleAltList: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
        enterLabeledAlt: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
          enterAlternative: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
            enterElement: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
              => element -> <<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>
              enterAtom: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
                enterTerminal: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
                exitTerminal: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
              exitAtom: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
            exitElement: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
          exitAlternative: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
        => elements -> ["<<<Enter a basic source character except the single-quote \\', backslash \\\\, or new-line \\\\n character.>>>"]
            => alternative -> <<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>
        exitLabeledAlt: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
      exitRuleAltList: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
    exitRuleBlock: '<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
  exitRuleSpec: basic-c-char:'<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>';

  enterRuleSpec: escape-sequence:simple-escape-sequence|numeric-escape-sequence|conditional-escape-sequence;
    enterRuleBlock: simple-escape-sequence|numeric-escape-sequence|conditional-escape-sequence
      enterRuleAltList: simple-escape-sequence|numeric-escape-sequence|conditional-escape-sequence
        enterLabeledAlt: simple-escape-sequence
          enterAlternative: simple-escape-sequence
            enterElement: simple-escape-sequence
              => element -> {simple-escape-sequence}
              enterAtom: simple-escape-sequence
                enterRuleref: simple-escape-sequence
                exitRuleref: simple-escape-sequence
              exitAtom: simple-escape-sequence
            exitElement: simple-escape-sequence
          exitAlternative: simple-escape-sequence
        => elements -> ['{simple-escape-sequence}']
            => alternative -> {simple-escape-sequence}
        exitLabeledAlt: simple-escape-sequence
        enterLabeledAlt: numeric-escape-sequence
          enterAlternative: numeric-escape-sequence
            enterElement: numeric-escape-sequence
              => element -> {numeric-escape-sequence}
              enterAtom: numeric-escape-sequence
                enterRuleref: numeric-escape-sequence
                exitRuleref: numeric-escape-sequence
              exitAtom: numeric-escape-sequence
            exitElement: numeric-escape-sequence
          exitAlternative: numeric-escape-sequence
        => elements -> ['{numeric-escape-sequence}']
            => alternative -> {numeric-escape-sequence}
        exitLabeledAlt: numeric-escape-sequence
        enterLabeledAlt: conditional-escape-sequence
          enterAlternative: conditional-escape-sequence
            enterElement: conditional-escape-sequence
              => element -> {conditional-escape-sequence}
              enterAtom: conditional-escape-sequence
                enterRuleref: conditional-escape-sequence
                exitRuleref: conditional-escape-sequence
              exitAtom: conditional-escape-sequence
            exitElement: conditional-escape-sequence
          exitAlternative: conditional-escape-sequence
        => elements -> ['{conditional-escape-sequence}']
            => alternative -> {conditional-escape-sequence}
        exitLabeledAlt: conditional-escape-sequence
      exitRuleAltList: simple-escape-sequence|numeric-escape-sequence|conditional-escape-sequence
    exitRuleBlock: simple-escape-sequence|numeric-escape-sequence|conditional-escape-sequence
  exitRuleSpec: escape-sequence:simple-escape-sequence|numeric-escape-sequence|conditional-escape-sequence;

  enterRuleSpec: simple-escape-sequence:'\\'simple-escape-sequence-char;
    enterRuleBlock: '\\'simple-escape-sequence-char
      enterRuleAltList: '\\'simple-escape-sequence-char
        enterLabeledAlt: '\\'simple-escape-sequence-char
          enterAlternative: '\\'simple-escape-sequence-char
            enterElement: '\\'
              => element -> \\
              enterAtom: '\\'
                enterTerminal: '\\'
                exitTerminal: '\\'
              exitAtom: '\\'
            exitElement: '\\'
            enterElement: simple-escape-sequence-char
              => element -> {simple-escape-sequence-char}
              enterAtom: simple-escape-sequence-char
                enterRuleref: simple-escape-sequence-char
                exitRuleref: simple-escape-sequence-char
              exitAtom: simple-escape-sequence-char
            exitElement: simple-escape-sequence-char
          exitAlternative: '\\'simple-escape-sequence-char
        => elements -> ['\\\\', '{simple-escape-sequence-char}']
            => alternative -> \\ {simple-escape-sequence-char}
        exitLabeledAlt: '\\'simple-escape-sequence-char
      exitRuleAltList: '\\'simple-escape-sequence-char
    exitRuleBlock: '\\'simple-escape-sequence-char
  exitRuleSpec: simple-escape-sequence:'\\'simple-escape-sequence-char;

  enterRuleSpec: simple-escape-sequence-char:'\''|'"'|'?'|'\\'|'a'|'b'|'f'|'n'|'r'|'t'|'v';
    enterRuleBlock: '\''|'"'|'?'|'\\'|'a'|'b'|'f'|'n'|'r'|'t'|'v'
      enterRuleAltList: '\''|'"'|'?'|'\\'|'a'|'b'|'f'|'n'|'r'|'t'|'v'
        enterLabeledAlt: '\''
          enterAlternative: '\''
            enterElement: '\''
              => element -> \'
              enterAtom: '\''
                enterTerminal: '\''
                exitTerminal: '\''
              exitAtom: '\''
            exitElement: '\''
          exitAlternative: '\''
        => elements -> ["\\'"]
            => alternative -> \'
        exitLabeledAlt: '\''
        enterLabeledAlt: '"'
          enterAlternative: '"'
            enterElement: '"'
              => element -> "
              enterAtom: '"'
                enterTerminal: '"'
                exitTerminal: '"'
              exitAtom: '"'
            exitElement: '"'
          exitAlternative: '"'
        => elements -> ['"']
            => alternative -> "
        exitLabeledAlt: '"'
        enterLabeledAlt: '?'
          enterAlternative: '?'
            enterElement: '?'
              => element -> ?
              enterAtom: '?'
                enterTerminal: '?'
                exitTerminal: '?'
              exitAtom: '?'
            exitElement: '?'
          exitAlternative: '?'
        => elements -> ['?']
            => alternative -> ?
        exitLabeledAlt: '?'
        enterLabeledAlt: '\\'
          enterAlternative: '\\'
            enterElement: '\\'
              => element -> \\
              enterAtom: '\\'
                enterTerminal: '\\'
                exitTerminal: '\\'
              exitAtom: '\\'
            exitElement: '\\'
          exitAlternative: '\\'
        => elements -> ['\\\\']
            => alternative -> \\
        exitLabeledAlt: '\\'
        enterLabeledAlt: 'a'
          enterAlternative: 'a'
            enterElement: 'a'
              => element -> a
              enterAtom: 'a'
                enterTerminal: 'a'
                exitTerminal: 'a'
              exitAtom: 'a'
            exitElement: 'a'
          exitAlternative: 'a'
        => elements -> ['a']
            => alternative -> a
        exitLabeledAlt: 'a'
        enterLabeledAlt: 'b'
          enterAlternative: 'b'
            enterElement: 'b'
              => element -> b
              enterAtom: 'b'
                enterTerminal: 'b'
                exitTerminal: 'b'
              exitAtom: 'b'
            exitElement: 'b'
          exitAlternative: 'b'
        => elements -> ['b']
            => alternative -> b
        exitLabeledAlt: 'b'
        enterLabeledAlt: 'f'
          enterAlternative: 'f'
            enterElement: 'f'
              => element -> f
              enterAtom: 'f'
                enterTerminal: 'f'
                exitTerminal: 'f'
              exitAtom: 'f'
            exitElement: 'f'
          exitAlternative: 'f'
        => elements -> ['f']
            => alternative -> f
        exitLabeledAlt: 'f'
        enterLabeledAlt: 'n'
          enterAlternative: 'n'
            enterElement: 'n'
              => element -> n
              enterAtom: 'n'
                enterTerminal: 'n'
                exitTerminal: 'n'
              exitAtom: 'n'
            exitElement: 'n'
          exitAlternative: 'n'
        => elements -> ['n']
            => alternative -> n
        exitLabeledAlt: 'n'
        enterLabeledAlt: 'r'
          enterAlternative: 'r'
            enterElement: 'r'
              => element -> r
              enterAtom: 'r'
                enterTerminal: 'r'
                exitTerminal: 'r'
              exitAtom: 'r'
            exitElement: 'r'
          exitAlternative: 'r'
        => elements -> ['r']
            => alternative -> r
        exitLabeledAlt: 'r'
        enterLabeledAlt: 't'
          enterAlternative: 't'
            enterElement: 't'
              => element -> t
              enterAtom: 't'
                enterTerminal: 't'
                exitTerminal: 't'
              exitAtom: 't'
            exitElement: 't'
          exitAlternative: 't'
        => elements -> ['t']
            => alternative -> t
        exitLabeledAlt: 't'
        enterLabeledAlt: 'v'
          enterAlternative: 'v'
            enterElement: 'v'
              => element -> v
              enterAtom: 'v'
                enterTerminal: 'v'
                exitTerminal: 'v'
              exitAtom: 'v'
            exitElement: 'v'
          exitAlternative: 'v'
        => elements -> ['v']
            => alternative -> v
        exitLabeledAlt: 'v'
      exitRuleAltList: '\''|'"'|'?'|'\\'|'a'|'b'|'f'|'n'|'r'|'t'|'v'
    exitRuleBlock: '\''|'"'|'?'|'\\'|'a'|'b'|'f'|'n'|'r'|'t'|'v'
  exitRuleSpec: simple-escape-sequence-char:'\''|'"'|'?'|'\\'|'a'|'b'|'f'|'n'|'r'|'t'|'v';

  enterRuleSpec: numeric-escape-sequence:octal-escape-sequence|hexadecimal-escape-sequence;
    enterRuleBlock: octal-escape-sequence|hexadecimal-escape-sequence
      enterRuleAltList: octal-escape-sequence|hexadecimal-escape-sequence
        enterLabeledAlt: octal-escape-sequence
          enterAlternative: octal-escape-sequence
            enterElement: octal-escape-sequence
              => element -> {octal-escape-sequence}
              enterAtom: octal-escape-sequence
                enterRuleref: octal-escape-sequence
                exitRuleref: octal-escape-sequence
              exitAtom: octal-escape-sequence
            exitElement: octal-escape-sequence
          exitAlternative: octal-escape-sequence
        => elements -> ['{octal-escape-sequence}']
            => alternative -> {octal-escape-sequence}
        exitLabeledAlt: octal-escape-sequence
        enterLabeledAlt: hexadecimal-escape-sequence
          enterAlternative: hexadecimal-escape-sequence
            enterElement: hexadecimal-escape-sequence
              => element -> {hexadecimal-escape-sequence}
              enterAtom: hexadecimal-escape-sequence
                enterRuleref: hexadecimal-escape-sequence
                exitRuleref: hexadecimal-escape-sequence
              exitAtom: hexadecimal-escape-sequence
            exitElement: hexadecimal-escape-sequence
          exitAlternative: hexadecimal-escape-sequence
        => elements -> ['{hexadecimal-escape-sequence}']
            => alternative -> {hexadecimal-escape-sequence}
        exitLabeledAlt: hexadecimal-escape-sequence
      exitRuleAltList: octal-escape-sequence|hexadecimal-escape-sequence
    exitRuleBlock: octal-escape-sequence|hexadecimal-escape-sequence
  exitRuleSpec: numeric-escape-sequence:octal-escape-sequence|hexadecimal-escape-sequence;

  enterRuleSpec: octal-escape-sequence:'\\'octal-digit|'\\'octal-digitoctal-digit|'\\'octal-digitoctal-digitoctal-digit|'\\o{'octal-digit+'}';
    enterRuleBlock: '\\'octal-digit|'\\'octal-digitoctal-digit|'\\'octal-digitoctal-digitoctal-digit|'\\o{'octal-digit+'}'
      enterRuleAltList: '\\'octal-digit|'\\'octal-digitoctal-digit|'\\'octal-digitoctal-digitoctal-digit|'\\o{'octal-digit+'}'
        enterLabeledAlt: '\\'octal-digit
          enterAlternative: '\\'octal-digit
            enterElement: '\\'
              => element -> \\
              enterAtom: '\\'
                enterTerminal: '\\'
                exitTerminal: '\\'
              exitAtom: '\\'
            exitElement: '\\'
            enterElement: octal-digit
              => element -> {octal-digit}
              enterAtom: octal-digit
                enterRuleref: octal-digit
                exitRuleref: octal-digit
              exitAtom: octal-digit
            exitElement: octal-digit
          exitAlternative: '\\'octal-digit
        => elements -> ['\\\\', '{octal-digit}']
            => alternative -> \\ {octal-digit}
        exitLabeledAlt: '\\'octal-digit
        enterLabeledAlt: '\\'octal-digitoctal-digit
          enterAlternative: '\\'octal-digitoctal-digit
            enterElement: '\\'
              => element -> \\
              enterAtom: '\\'
                enterTerminal: '\\'
                exitTerminal: '\\'
              exitAtom: '\\'
            exitElement: '\\'
            enterElement: octal-digit
              => element -> {octal-digit}
              enterAtom: octal-digit
                enterRuleref: octal-digit
                exitRuleref: octal-digit
              exitAtom: octal-digit
            exitElement: octal-digit
            enterElement: octal-digit
              => element -> {octal-digit}
              enterAtom: octal-digit
                enterRuleref: octal-digit
                exitRuleref: octal-digit
              exitAtom: octal-digit
            exitElement: octal-digit
          exitAlternative: '\\'octal-digitoctal-digit
        => elements -> ['\\\\', '{octal-digit}', '{octal-digit}']
            => alternative -> \\ {octal-digit} {octal-digit}
        exitLabeledAlt: '\\'octal-digitoctal-digit
        enterLabeledAlt: '\\'octal-digitoctal-digitoctal-digit
          enterAlternative: '\\'octal-digitoctal-digitoctal-digit
            enterElement: '\\'
              => element -> \\
              enterAtom: '\\'
                enterTerminal: '\\'
                exitTerminal: '\\'
              exitAtom: '\\'
            exitElement: '\\'
            enterElement: octal-digit
              => element -> {octal-digit}
              enterAtom: octal-digit
                enterRuleref: octal-digit
                exitRuleref: octal-digit
              exitAtom: octal-digit
            exitElement: octal-digit
            enterElement: octal-digit
              => element -> {octal-digit}
              enterAtom: octal-digit
                enterRuleref: octal-digit
                exitRuleref: octal-digit
              exitAtom: octal-digit
            exitElement: octal-digit
            enterElement: octal-digit
              => element -> {octal-digit}
              enterAtom: octal-digit
                enterRuleref: octal-digit
                exitRuleref: octal-digit
              exitAtom: octal-digit
            exitElement: octal-digit
          exitAlternative: '\\'octal-digitoctal-digitoctal-digit
        => elements -> ['\\\\', '{octal-digit}', '{octal-digit}', '{octal-digit}']
            => alternative -> \\ {octal-digit} {octal-digit} {octal-digit}
        exitLabeledAlt: '\\'octal-digitoctal-digitoctal-digit
        enterLabeledAlt: '\\o{'octal-digit+'}'
          enterAlternative: '\\o{'octal-digit+'}'
            enterElement: '\\o{'
              => element -> \\o{
              enterAtom: '\\o{'
                enterTerminal: '\\o{'
                exitTerminal: '\\o{'
              exitAtom: '\\o{'
            exitElement: '\\o{'
            enterElement: octal-digit+
              => element -> {octal-digit}...
              enterAtom: octal-digit
                enterRuleref: octal-digit
                exitRuleref: octal-digit
              exitAtom: octal-digit
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: octal-digit+
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: '\\o{'octal-digit+'}'
        => elements -> ['\\\\o{', '{octal-digit}...', '}']
            => alternative -> \\o{ {octal-digit}... }
        exitLabeledAlt: '\\o{'octal-digit+'}'
      exitRuleAltList: '\\'octal-digit|'\\'octal-digitoctal-digit|'\\'octal-digitoctal-digitoctal-digit|'\\o{'octal-digit+'}'
    exitRuleBlock: '\\'octal-digit|'\\'octal-digitoctal-digit|'\\'octal-digitoctal-digitoctal-digit|'\\o{'octal-digit+'}'
  exitRuleSpec: octal-escape-sequence:'\\'octal-digit|'\\'octal-digitoctal-digit|'\\'octal-digitoctal-digitoctal-digit|'\\o{'octal-digit+'}';

  enterRuleSpec: hexadecimal-escape-sequence:'\\x'hexadecimal-digit|'\\x{'hexadecimal-digit'}';
    enterRuleBlock: '\\x'hexadecimal-digit|'\\x{'hexadecimal-digit'}'
      enterRuleAltList: '\\x'hexadecimal-digit|'\\x{'hexadecimal-digit'}'
        enterLabeledAlt: '\\x'hexadecimal-digit
          enterAlternative: '\\x'hexadecimal-digit
            enterElement: '\\x'
              => element -> \\x
              enterAtom: '\\x'
                enterTerminal: '\\x'
                exitTerminal: '\\x'
              exitAtom: '\\x'
            exitElement: '\\x'
            enterElement: hexadecimal-digit
              => element -> {hexadecimal-digit}
              enterAtom: hexadecimal-digit
                enterRuleref: hexadecimal-digit
                exitRuleref: hexadecimal-digit
              exitAtom: hexadecimal-digit
            exitElement: hexadecimal-digit
          exitAlternative: '\\x'hexadecimal-digit
        => elements -> ['\\\\x', '{hexadecimal-digit}']
            => alternative -> \\x {hexadecimal-digit}
        exitLabeledAlt: '\\x'hexadecimal-digit
        enterLabeledAlt: '\\x{'hexadecimal-digit'}'
          enterAlternative: '\\x{'hexadecimal-digit'}'
            enterElement: '\\x{'
              => element -> \\x{
              enterAtom: '\\x{'
                enterTerminal: '\\x{'
                exitTerminal: '\\x{'
              exitAtom: '\\x{'
            exitElement: '\\x{'
            enterElement: hexadecimal-digit
              => element -> {hexadecimal-digit}
              enterAtom: hexadecimal-digit
                enterRuleref: hexadecimal-digit
                exitRuleref: hexadecimal-digit
              exitAtom: hexadecimal-digit
            exitElement: hexadecimal-digit
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: '\\x{'hexadecimal-digit'}'
        => elements -> ['\\\\x{', '{hexadecimal-digit}', '}']
            => alternative -> \\x{ {hexadecimal-digit} }
        exitLabeledAlt: '\\x{'hexadecimal-digit'}'
      exitRuleAltList: '\\x'hexadecimal-digit|'\\x{'hexadecimal-digit'}'
    exitRuleBlock: '\\x'hexadecimal-digit|'\\x{'hexadecimal-digit'}'
  exitRuleSpec: hexadecimal-escape-sequence:'\\x'hexadecimal-digit|'\\x{'hexadecimal-digit'}';

  enterRuleSpec: conditional-escape-sequence:'\\'conditional-escape-sequence-char;
    enterRuleBlock: '\\'conditional-escape-sequence-char
      enterRuleAltList: '\\'conditional-escape-sequence-char
        enterLabeledAlt: '\\'conditional-escape-sequence-char
          enterAlternative: '\\'conditional-escape-sequence-char
            enterElement: '\\'
              => element -> \\
              enterAtom: '\\'
                enterTerminal: '\\'
                exitTerminal: '\\'
              exitAtom: '\\'
            exitElement: '\\'
            enterElement: conditional-escape-sequence-char
              => element -> {conditional-escape-sequence-char}
              enterAtom: conditional-escape-sequence-char
                enterRuleref: conditional-escape-sequence-char
                exitRuleref: conditional-escape-sequence-char
              exitAtom: conditional-escape-sequence-char
            exitElement: conditional-escape-sequence-char
          exitAlternative: '\\'conditional-escape-sequence-char
        => elements -> ['\\\\', '{conditional-escape-sequence-char}']
            => alternative -> \\ {conditional-escape-sequence-char}
        exitLabeledAlt: '\\'conditional-escape-sequence-char
      exitRuleAltList: '\\'conditional-escape-sequence-char
    exitRuleBlock: '\\'conditional-escape-sequence-char
  exitRuleSpec: conditional-escape-sequence:'\\'conditional-escape-sequence-char;

  enterRuleSpec: conditional-escape-sequence-char:'<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>';
    enterRuleBlock: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
      enterRuleAltList: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
        enterLabeledAlt: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
          enterAlternative: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
            enterElement: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
              => element -> <<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>
              enterAtom: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
                enterTerminal: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
                exitTerminal: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
              exitAtom: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
            exitElement: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
          exitAlternative: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
        => elements -> ['<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>']
            => alternative -> <<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>
        exitLabeledAlt: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
      exitRuleAltList: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
    exitRuleBlock: '<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
  exitRuleSpec: conditional-escape-sequence-char:'<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>';

  enterRuleSpec: floating-point-literal:decimal-floating-point-literal|hexadecimal-floating-point-literal;
    enterRuleBlock: decimal-floating-point-literal|hexadecimal-floating-point-literal
      enterRuleAltList: decimal-floating-point-literal|hexadecimal-floating-point-literal
        enterLabeledAlt: decimal-floating-point-literal
          enterAlternative: decimal-floating-point-literal
            enterElement: decimal-floating-point-literal
              => element -> {decimal-floating-point-literal}
              enterAtom: decimal-floating-point-literal
                enterRuleref: decimal-floating-point-literal
                exitRuleref: decimal-floating-point-literal
              exitAtom: decimal-floating-point-literal
            exitElement: decimal-floating-point-literal
          exitAlternative: decimal-floating-point-literal
        => elements -> ['{decimal-floating-point-literal}']
            => alternative -> {decimal-floating-point-literal}
        exitLabeledAlt: decimal-floating-point-literal
        enterLabeledAlt: hexadecimal-floating-point-literal
          enterAlternative: hexadecimal-floating-point-literal
            enterElement: hexadecimal-floating-point-literal
              => element -> {hexadecimal-floating-point-literal}
              enterAtom: hexadecimal-floating-point-literal
                enterRuleref: hexadecimal-floating-point-literal
                exitRuleref: hexadecimal-floating-point-literal
              exitAtom: hexadecimal-floating-point-literal
            exitElement: hexadecimal-floating-point-literal
          exitAlternative: hexadecimal-floating-point-literal
        => elements -> ['{hexadecimal-floating-point-literal}']
            => alternative -> {hexadecimal-floating-point-literal}
        exitLabeledAlt: hexadecimal-floating-point-literal
      exitRuleAltList: decimal-floating-point-literal|hexadecimal-floating-point-literal
    exitRuleBlock: decimal-floating-point-literal|hexadecimal-floating-point-literal
  exitRuleSpec: floating-point-literal:decimal-floating-point-literal|hexadecimal-floating-point-literal;

  enterRuleSpec: decimal-floating-point-literal:fractional-constantexponent-part?floating-point-suffix?|digit-sequenceexponent-partfloating-point-suffix?;
    enterRuleBlock: fractional-constantexponent-part?floating-point-suffix?|digit-sequenceexponent-partfloating-point-suffix?
      enterRuleAltList: fractional-constantexponent-part?floating-point-suffix?|digit-sequenceexponent-partfloating-point-suffix?
        enterLabeledAlt: fractional-constantexponent-part?floating-point-suffix?
          enterAlternative: fractional-constantexponent-part?floating-point-suffix?
            enterElement: fractional-constant
              => element -> {fractional-constant}
              enterAtom: fractional-constant
                enterRuleref: fractional-constant
                exitRuleref: fractional-constant
              exitAtom: fractional-constant
            exitElement: fractional-constant
            enterElement: exponent-part?
              => element -> [exponent-part]
              enterAtom: exponent-part
                enterRuleref: exponent-part
                exitRuleref: exponent-part
              exitAtom: exponent-part
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: exponent-part?
            enterElement: floating-point-suffix?
              => element -> [floating-point-suffix]
              enterAtom: floating-point-suffix
                enterRuleref: floating-point-suffix
                exitRuleref: floating-point-suffix
              exitAtom: floating-point-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: floating-point-suffix?
          exitAlternative: fractional-constantexponent-part?floating-point-suffix?
        => elements -> ['{fractional-constant}', '[exponent-part]', '[floating-point-suffix]']
            => alternative -> {fractional-constant} [exponent-part] [floating-point-suffix]
        exitLabeledAlt: fractional-constantexponent-part?floating-point-suffix?
        enterLabeledAlt: digit-sequenceexponent-partfloating-point-suffix?
          enterAlternative: digit-sequenceexponent-partfloating-point-suffix?
            enterElement: digit-sequence
              => element -> {digit-sequence}
              enterAtom: digit-sequence
                enterRuleref: digit-sequence
                exitRuleref: digit-sequence
              exitAtom: digit-sequence
            exitElement: digit-sequence
            enterElement: exponent-part
              => element -> {exponent-part}
              enterAtom: exponent-part
                enterRuleref: exponent-part
                exitRuleref: exponent-part
              exitAtom: exponent-part
            exitElement: exponent-part
            enterElement: floating-point-suffix?
              => element -> [floating-point-suffix]
              enterAtom: floating-point-suffix
                enterRuleref: floating-point-suffix
                exitRuleref: floating-point-suffix
              exitAtom: floating-point-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: floating-point-suffix?
          exitAlternative: digit-sequenceexponent-partfloating-point-suffix?
        => elements -> ['{digit-sequence}', '{exponent-part}', '[floating-point-suffix]']
            => alternative -> {digit-sequence} {exponent-part} [floating-point-suffix]
        exitLabeledAlt: digit-sequenceexponent-partfloating-point-suffix?
      exitRuleAltList: fractional-constantexponent-part?floating-point-suffix?|digit-sequenceexponent-partfloating-point-suffix?
    exitRuleBlock: fractional-constantexponent-part?floating-point-suffix?|digit-sequenceexponent-partfloating-point-suffix?
  exitRuleSpec: decimal-floating-point-literal:fractional-constantexponent-part?floating-point-suffix?|digit-sequenceexponent-partfloating-point-suffix?;

  enterRuleSpec: hexadecimal-floating-point-literal:hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partfloating-point-suffix?|hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partfloating-point-suffix?;
    enterRuleBlock: hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partfloating-point-suffix?|hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partfloating-point-suffix?
      enterRuleAltList: hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partfloating-point-suffix?|hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partfloating-point-suffix?
        enterLabeledAlt: hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partfloating-point-suffix?
          enterAlternative: hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partfloating-point-suffix?
            enterElement: hexadecimal-prefix
              => element -> {hexadecimal-prefix}
              enterAtom: hexadecimal-prefix
                enterRuleref: hexadecimal-prefix
                exitRuleref: hexadecimal-prefix
              exitAtom: hexadecimal-prefix
            exitElement: hexadecimal-prefix
            enterElement: hexadecimal-fractional-constant
              => element -> {hexadecimal-fractional-constant}
              enterAtom: hexadecimal-fractional-constant
                enterRuleref: hexadecimal-fractional-constant
                exitRuleref: hexadecimal-fractional-constant
              exitAtom: hexadecimal-fractional-constant
            exitElement: hexadecimal-fractional-constant
            enterElement: binary-exponent-part
              => element -> {binary-exponent-part}
              enterAtom: binary-exponent-part
                enterRuleref: binary-exponent-part
                exitRuleref: binary-exponent-part
              exitAtom: binary-exponent-part
            exitElement: binary-exponent-part
            enterElement: floating-point-suffix?
              => element -> [floating-point-suffix]
              enterAtom: floating-point-suffix
                enterRuleref: floating-point-suffix
                exitRuleref: floating-point-suffix
              exitAtom: floating-point-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: floating-point-suffix?
          exitAlternative: hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partfloating-point-suffix?
        => elements -> ['{hexadecimal-prefix}', '{hexadecimal-fractional-constant}', '{binary-exponent-part}', '[floating-point-suffix]']
            => alternative -> {hexadecimal-prefix} {hexadecimal-fractional-constant} {binary-exponent-part} [floating-point-suffix]
        exitLabeledAlt: hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partfloating-point-suffix?
        enterLabeledAlt: hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partfloating-point-suffix?
          enterAlternative: hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partfloating-point-suffix?
            enterElement: hexadecimal-prefix
              => element -> {hexadecimal-prefix}
              enterAtom: hexadecimal-prefix
                enterRuleref: hexadecimal-prefix
                exitRuleref: hexadecimal-prefix
              exitAtom: hexadecimal-prefix
            exitElement: hexadecimal-prefix
            enterElement: hexadecimal-digit-sequence
              => element -> {hexadecimal-digit-sequence}
              enterAtom: hexadecimal-digit-sequence
                enterRuleref: hexadecimal-digit-sequence
                exitRuleref: hexadecimal-digit-sequence
              exitAtom: hexadecimal-digit-sequence
            exitElement: hexadecimal-digit-sequence
            enterElement: binary-exponent-part
              => element -> {binary-exponent-part}
              enterAtom: binary-exponent-part
                enterRuleref: binary-exponent-part
                exitRuleref: binary-exponent-part
              exitAtom: binary-exponent-part
            exitElement: binary-exponent-part
            enterElement: floating-point-suffix?
              => element -> [floating-point-suffix]
              enterAtom: floating-point-suffix
                enterRuleref: floating-point-suffix
                exitRuleref: floating-point-suffix
              exitAtom: floating-point-suffix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: floating-point-suffix?
          exitAlternative: hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partfloating-point-suffix?
        => elements -> ['{hexadecimal-prefix}', '{hexadecimal-digit-sequence}', '{binary-exponent-part}', '[floating-point-suffix]']
            => alternative -> {hexadecimal-prefix} {hexadecimal-digit-sequence} {binary-exponent-part} [floating-point-suffix]
        exitLabeledAlt: hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partfloating-point-suffix?
      exitRuleAltList: hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partfloating-point-suffix?|hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partfloating-point-suffix?
    exitRuleBlock: hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partfloating-point-suffix?|hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partfloating-point-suffix?
  exitRuleSpec: hexadecimal-floating-point-literal:hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partfloating-point-suffix?|hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partfloating-point-suffix?;

  enterRuleSpec: fractional-constant:digit-sequence?'.'digit-sequence|digit-sequence'.';
    enterRuleBlock: digit-sequence?'.'digit-sequence|digit-sequence'.'
      enterRuleAltList: digit-sequence?'.'digit-sequence|digit-sequence'.'
        enterLabeledAlt: digit-sequence?'.'digit-sequence
          enterAlternative: digit-sequence?'.'digit-sequence
            enterElement: digit-sequence?
              => element -> [digit-sequence]
              enterAtom: digit-sequence
                enterRuleref: digit-sequence
                exitRuleref: digit-sequence
              exitAtom: digit-sequence
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: digit-sequence?
            enterElement: '.'
              => element -> .
              enterAtom: '.'
                enterTerminal: '.'
                exitTerminal: '.'
              exitAtom: '.'
            exitElement: '.'
            enterElement: digit-sequence
              => element -> {digit-sequence}
              enterAtom: digit-sequence
                enterRuleref: digit-sequence
                exitRuleref: digit-sequence
              exitAtom: digit-sequence
            exitElement: digit-sequence
          exitAlternative: digit-sequence?'.'digit-sequence
        => elements -> ['[digit-sequence]', '.', '{digit-sequence}']
            => alternative -> [digit-sequence] . {digit-sequence}
        exitLabeledAlt: digit-sequence?'.'digit-sequence
        enterLabeledAlt: digit-sequence'.'
          enterAlternative: digit-sequence'.'
            enterElement: digit-sequence
              => element -> {digit-sequence}
              enterAtom: digit-sequence
                enterRuleref: digit-sequence
                exitRuleref: digit-sequence
              exitAtom: digit-sequence
            exitElement: digit-sequence
            enterElement: '.'
              => element -> .
              enterAtom: '.'
                enterTerminal: '.'
                exitTerminal: '.'
              exitAtom: '.'
            exitElement: '.'
          exitAlternative: digit-sequence'.'
        => elements -> ['{digit-sequence}', '.']
            => alternative -> {digit-sequence} .
        exitLabeledAlt: digit-sequence'.'
      exitRuleAltList: digit-sequence?'.'digit-sequence|digit-sequence'.'
    exitRuleBlock: digit-sequence?'.'digit-sequence|digit-sequence'.'
  exitRuleSpec: fractional-constant:digit-sequence?'.'digit-sequence|digit-sequence'.';

  enterRuleSpec: hexadecimal-fractional-constant:hexadecimal-digit-sequence?'.'hexadecimal-digit-sequence|hexadecimal-digit-sequence'.';
    enterRuleBlock: hexadecimal-digit-sequence?'.'hexadecimal-digit-sequence|hexadecimal-digit-sequence'.'
      enterRuleAltList: hexadecimal-digit-sequence?'.'hexadecimal-digit-sequence|hexadecimal-digit-sequence'.'
        enterLabeledAlt: hexadecimal-digit-sequence?'.'hexadecimal-digit-sequence
          enterAlternative: hexadecimal-digit-sequence?'.'hexadecimal-digit-sequence
            enterElement: hexadecimal-digit-sequence?
              => element -> [hexadecimal-digit-sequence]
              enterAtom: hexadecimal-digit-sequence
                enterRuleref: hexadecimal-digit-sequence
                exitRuleref: hexadecimal-digit-sequence
              exitAtom: hexadecimal-digit-sequence
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: hexadecimal-digit-sequence?
            enterElement: '.'
              => element -> .
              enterAtom: '.'
                enterTerminal: '.'
                exitTerminal: '.'
              exitAtom: '.'
            exitElement: '.'
            enterElement: hexadecimal-digit-sequence
              => element -> {hexadecimal-digit-sequence}
              enterAtom: hexadecimal-digit-sequence
                enterRuleref: hexadecimal-digit-sequence
                exitRuleref: hexadecimal-digit-sequence
              exitAtom: hexadecimal-digit-sequence
            exitElement: hexadecimal-digit-sequence
          exitAlternative: hexadecimal-digit-sequence?'.'hexadecimal-digit-sequence
        => elements -> ['[hexadecimal-digit-sequence]', '.', '{hexadecimal-digit-sequence}']
            => alternative -> [hexadecimal-digit-sequence] . {hexadecimal-digit-sequence}
        exitLabeledAlt: hexadecimal-digit-sequence?'.'hexadecimal-digit-sequence
        enterLabeledAlt: hexadecimal-digit-sequence'.'
          enterAlternative: hexadecimal-digit-sequence'.'
            enterElement: hexadecimal-digit-sequence
              => element -> {hexadecimal-digit-sequence}
              enterAtom: hexadecimal-digit-sequence
                enterRuleref: hexadecimal-digit-sequence
                exitRuleref: hexadecimal-digit-sequence
              exitAtom: hexadecimal-digit-sequence
            exitElement: hexadecimal-digit-sequence
            enterElement: '.'
              => element -> .
              enterAtom: '.'
                enterTerminal: '.'
                exitTerminal: '.'
              exitAtom: '.'
            exitElement: '.'
          exitAlternative: hexadecimal-digit-sequence'.'
        => elements -> ['{hexadecimal-digit-sequence}', '.']
            => alternative -> {hexadecimal-digit-sequence} .
        exitLabeledAlt: hexadecimal-digit-sequence'.'
      exitRuleAltList: hexadecimal-digit-sequence?'.'hexadecimal-digit-sequence|hexadecimal-digit-sequence'.'
    exitRuleBlock: hexadecimal-digit-sequence?'.'hexadecimal-digit-sequence|hexadecimal-digit-sequence'.'
  exitRuleSpec: hexadecimal-fractional-constant:hexadecimal-digit-sequence?'.'hexadecimal-digit-sequence|hexadecimal-digit-sequence'.';

  enterRuleSpec: exponent-part:'e'sign?digit-sequence|'E'sign?digit-sequence;
    enterRuleBlock: 'e'sign?digit-sequence|'E'sign?digit-sequence
      enterRuleAltList: 'e'sign?digit-sequence|'E'sign?digit-sequence
        enterLabeledAlt: 'e'sign?digit-sequence
          enterAlternative: 'e'sign?digit-sequence
            enterElement: 'e'
              => element -> e
              enterAtom: 'e'
                enterTerminal: 'e'
                exitTerminal: 'e'
              exitAtom: 'e'
            exitElement: 'e'
            enterElement: sign?
              => element -> [sign]
              enterAtom: sign
                enterRuleref: sign
                exitRuleref: sign
              exitAtom: sign
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: sign?
            enterElement: digit-sequence
              => element -> {digit-sequence}
              enterAtom: digit-sequence
                enterRuleref: digit-sequence
                exitRuleref: digit-sequence
              exitAtom: digit-sequence
            exitElement: digit-sequence
          exitAlternative: 'e'sign?digit-sequence
        => elements -> ['e', '[sign]', '{digit-sequence}']
            => alternative -> e [sign] {digit-sequence}
        exitLabeledAlt: 'e'sign?digit-sequence
        enterLabeledAlt: 'E'sign?digit-sequence
          enterAlternative: 'E'sign?digit-sequence
            enterElement: 'E'
              => element -> E
              enterAtom: 'E'
                enterTerminal: 'E'
                exitTerminal: 'E'
              exitAtom: 'E'
            exitElement: 'E'
            enterElement: sign?
              => element -> [sign]
              enterAtom: sign
                enterRuleref: sign
                exitRuleref: sign
              exitAtom: sign
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: sign?
            enterElement: digit-sequence
              => element -> {digit-sequence}
              enterAtom: digit-sequence
                enterRuleref: digit-sequence
                exitRuleref: digit-sequence
              exitAtom: digit-sequence
            exitElement: digit-sequence
          exitAlternative: 'E'sign?digit-sequence
        => elements -> ['E', '[sign]', '{digit-sequence}']
            => alternative -> E [sign] {digit-sequence}
        exitLabeledAlt: 'E'sign?digit-sequence
      exitRuleAltList: 'e'sign?digit-sequence|'E'sign?digit-sequence
    exitRuleBlock: 'e'sign?digit-sequence|'E'sign?digit-sequence
  exitRuleSpec: exponent-part:'e'sign?digit-sequence|'E'sign?digit-sequence;

  enterRuleSpec: binary-exponent-part:'p'sign?digit-sequence|'P'sign?digit-sequence;
    enterRuleBlock: 'p'sign?digit-sequence|'P'sign?digit-sequence
      enterRuleAltList: 'p'sign?digit-sequence|'P'sign?digit-sequence
        enterLabeledAlt: 'p'sign?digit-sequence
          enterAlternative: 'p'sign?digit-sequence
            enterElement: 'p'
              => element -> p
              enterAtom: 'p'
                enterTerminal: 'p'
                exitTerminal: 'p'
              exitAtom: 'p'
            exitElement: 'p'
            enterElement: sign?
              => element -> [sign]
              enterAtom: sign
                enterRuleref: sign
                exitRuleref: sign
              exitAtom: sign
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: sign?
            enterElement: digit-sequence
              => element -> {digit-sequence}
              enterAtom: digit-sequence
                enterRuleref: digit-sequence
                exitRuleref: digit-sequence
              exitAtom: digit-sequence
            exitElement: digit-sequence
          exitAlternative: 'p'sign?digit-sequence
        => elements -> ['p', '[sign]', '{digit-sequence}']
            => alternative -> p [sign] {digit-sequence}
        exitLabeledAlt: 'p'sign?digit-sequence
        enterLabeledAlt: 'P'sign?digit-sequence
          enterAlternative: 'P'sign?digit-sequence
            enterElement: 'P'
              => element -> P
              enterAtom: 'P'
                enterTerminal: 'P'
                exitTerminal: 'P'
              exitAtom: 'P'
            exitElement: 'P'
            enterElement: sign?
              => element -> [sign]
              enterAtom: sign
                enterRuleref: sign
                exitRuleref: sign
              exitAtom: sign
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: sign?
            enterElement: digit-sequence
              => element -> {digit-sequence}
              enterAtom: digit-sequence
                enterRuleref: digit-sequence
                exitRuleref: digit-sequence
              exitAtom: digit-sequence
            exitElement: digit-sequence
          exitAlternative: 'P'sign?digit-sequence
        => elements -> ['P', '[sign]', '{digit-sequence}']
            => alternative -> P [sign] {digit-sequence}
        exitLabeledAlt: 'P'sign?digit-sequence
      exitRuleAltList: 'p'sign?digit-sequence|'P'sign?digit-sequence
    exitRuleBlock: 'p'sign?digit-sequence|'P'sign?digit-sequence
  exitRuleSpec: binary-exponent-part:'p'sign?digit-sequence|'P'sign?digit-sequence;

  enterRuleSpec: sign:'+'|'-';
    enterRuleBlock: '+'|'-'
      enterRuleAltList: '+'|'-'
        enterLabeledAlt: '+'
          enterAlternative: '+'
            enterElement: '+'
              => element -> +
              enterAtom: '+'
                enterTerminal: '+'
                exitTerminal: '+'
              exitAtom: '+'
            exitElement: '+'
          exitAlternative: '+'
        => elements -> ['+']
            => alternative -> +
        exitLabeledAlt: '+'
        enterLabeledAlt: '-'
          enterAlternative: '-'
            enterElement: '-'
              => element -> -
              enterAtom: '-'
                enterTerminal: '-'
                exitTerminal: '-'
              exitAtom: '-'
            exitElement: '-'
          exitAlternative: '-'
        => elements -> ['-']
            => alternative -> -
        exitLabeledAlt: '-'
      exitRuleAltList: '+'|'-'
    exitRuleBlock: '+'|'-'
  exitRuleSpec: sign:'+'|'-';

  enterRuleSpec: digit-sequence:digit|digit-sequencesimple-quote-char?digit;
    enterRuleBlock: digit|digit-sequencesimple-quote-char?digit
      enterRuleAltList: digit|digit-sequencesimple-quote-char?digit
        enterLabeledAlt: digit
          enterAlternative: digit
            enterElement: digit
              => element -> {digit}
              enterAtom: digit
                enterRuleref: digit
                exitRuleref: digit
              exitAtom: digit
            exitElement: digit
          exitAlternative: digit
        => elements -> ['{digit}']
            => alternative -> {digit}
        exitLabeledAlt: digit
        enterLabeledAlt: digit-sequencesimple-quote-char?digit
          enterAlternative: digit-sequencesimple-quote-char?digit
            enterElement: digit-sequence
              => element -> {digit-sequence}
              enterAtom: digit-sequence
                enterRuleref: digit-sequence
                exitRuleref: digit-sequence
              exitAtom: digit-sequence
            exitElement: digit-sequence
            enterElement: simple-quote-char?
              => element -> [simple-quote-char]
              enterAtom: simple-quote-char
                enterRuleref: simple-quote-char
                exitRuleref: simple-quote-char
              exitAtom: simple-quote-char
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: simple-quote-char?
            enterElement: digit
              => element -> {digit}
              enterAtom: digit
                enterRuleref: digit
                exitRuleref: digit
              exitAtom: digit
            exitElement: digit
          exitAlternative: digit-sequencesimple-quote-char?digit
        => elements -> ['{digit-sequence}', '[simple-quote-char]', '{digit}']
            => alternative -> {digit-sequence} [simple-quote-char] {digit}
        exitLabeledAlt: digit-sequencesimple-quote-char?digit
      exitRuleAltList: digit|digit-sequencesimple-quote-char?digit
    exitRuleBlock: digit|digit-sequencesimple-quote-char?digit
  exitRuleSpec: digit-sequence:digit|digit-sequencesimple-quote-char?digit;

  enterRuleSpec: floating-point-suffix:'f'|'l'|'f16'|'f32'|'f64'|'f128'|'bf16'|'F'|'L'|'F16'|'F32'|'F64'|'F128'|'BF16';
    enterRuleBlock: 'f'|'l'|'f16'|'f32'|'f64'|'f128'|'bf16'|'F'|'L'|'F16'|'F32'|'F64'|'F128'|'BF16'
      enterRuleAltList: 'f'|'l'|'f16'|'f32'|'f64'|'f128'|'bf16'|'F'|'L'|'F16'|'F32'|'F64'|'F128'|'BF16'
        enterLabeledAlt: 'f'
          enterAlternative: 'f'
            enterElement: 'f'
              => element -> f
              enterAtom: 'f'
                enterTerminal: 'f'
                exitTerminal: 'f'
              exitAtom: 'f'
            exitElement: 'f'
          exitAlternative: 'f'
        => elements -> ['f']
            => alternative -> f
        exitLabeledAlt: 'f'
        enterLabeledAlt: 'l'
          enterAlternative: 'l'
            enterElement: 'l'
              => element -> l
              enterAtom: 'l'
                enterTerminal: 'l'
                exitTerminal: 'l'
              exitAtom: 'l'
            exitElement: 'l'
          exitAlternative: 'l'
        => elements -> ['l']
            => alternative -> l
        exitLabeledAlt: 'l'
        enterLabeledAlt: 'f16'
          enterAlternative: 'f16'
            enterElement: 'f16'
              => element -> f16
              enterAtom: 'f16'
                enterTerminal: 'f16'
                exitTerminal: 'f16'
              exitAtom: 'f16'
            exitElement: 'f16'
          exitAlternative: 'f16'
        => elements -> ['f16']
            => alternative -> f16
        exitLabeledAlt: 'f16'
        enterLabeledAlt: 'f32'
          enterAlternative: 'f32'
            enterElement: 'f32'
              => element -> f32
              enterAtom: 'f32'
                enterTerminal: 'f32'
                exitTerminal: 'f32'
              exitAtom: 'f32'
            exitElement: 'f32'
          exitAlternative: 'f32'
        => elements -> ['f32']
            => alternative -> f32
        exitLabeledAlt: 'f32'
        enterLabeledAlt: 'f64'
          enterAlternative: 'f64'
            enterElement: 'f64'
              => element -> f64
              enterAtom: 'f64'
                enterTerminal: 'f64'
                exitTerminal: 'f64'
              exitAtom: 'f64'
            exitElement: 'f64'
          exitAlternative: 'f64'
        => elements -> ['f64']
            => alternative -> f64
        exitLabeledAlt: 'f64'
        enterLabeledAlt: 'f128'
          enterAlternative: 'f128'
            enterElement: 'f128'
              => element -> f128
              enterAtom: 'f128'
                enterTerminal: 'f128'
                exitTerminal: 'f128'
              exitAtom: 'f128'
            exitElement: 'f128'
          exitAlternative: 'f128'
        => elements -> ['f128']
            => alternative -> f128
        exitLabeledAlt: 'f128'
        enterLabeledAlt: 'bf16'
          enterAlternative: 'bf16'
            enterElement: 'bf16'
              => element -> bf16
              enterAtom: 'bf16'
                enterTerminal: 'bf16'
                exitTerminal: 'bf16'
              exitAtom: 'bf16'
            exitElement: 'bf16'
          exitAlternative: 'bf16'
        => elements -> ['bf16']
            => alternative -> bf16
        exitLabeledAlt: 'bf16'
        enterLabeledAlt: 'F'
          enterAlternative: 'F'
            enterElement: 'F'
              => element -> F
              enterAtom: 'F'
                enterTerminal: 'F'
                exitTerminal: 'F'
              exitAtom: 'F'
            exitElement: 'F'
          exitAlternative: 'F'
        => elements -> ['F']
            => alternative -> F
        exitLabeledAlt: 'F'
        enterLabeledAlt: 'L'
          enterAlternative: 'L'
            enterElement: 'L'
              => element -> L
              enterAtom: 'L'
                enterTerminal: 'L'
                exitTerminal: 'L'
              exitAtom: 'L'
            exitElement: 'L'
          exitAlternative: 'L'
        => elements -> ['L']
            => alternative -> L
        exitLabeledAlt: 'L'
        enterLabeledAlt: 'F16'
          enterAlternative: 'F16'
            enterElement: 'F16'
              => element -> F16
              enterAtom: 'F16'
                enterTerminal: 'F16'
                exitTerminal: 'F16'
              exitAtom: 'F16'
            exitElement: 'F16'
          exitAlternative: 'F16'
        => elements -> ['F16']
            => alternative -> F16
        exitLabeledAlt: 'F16'
        enterLabeledAlt: 'F32'
          enterAlternative: 'F32'
            enterElement: 'F32'
              => element -> F32
              enterAtom: 'F32'
                enterTerminal: 'F32'
                exitTerminal: 'F32'
              exitAtom: 'F32'
            exitElement: 'F32'
          exitAlternative: 'F32'
        => elements -> ['F32']
            => alternative -> F32
        exitLabeledAlt: 'F32'
        enterLabeledAlt: 'F64'
          enterAlternative: 'F64'
            enterElement: 'F64'
              => element -> F64
              enterAtom: 'F64'
                enterTerminal: 'F64'
                exitTerminal: 'F64'
              exitAtom: 'F64'
            exitElement: 'F64'
          exitAlternative: 'F64'
        => elements -> ['F64']
            => alternative -> F64
        exitLabeledAlt: 'F64'
        enterLabeledAlt: 'F128'
          enterAlternative: 'F128'
            enterElement: 'F128'
              => element -> F128
              enterAtom: 'F128'
                enterTerminal: 'F128'
                exitTerminal: 'F128'
              exitAtom: 'F128'
            exitElement: 'F128'
          exitAlternative: 'F128'
        => elements -> ['F128']
            => alternative -> F128
        exitLabeledAlt: 'F128'
        enterLabeledAlt: 'BF16'
          enterAlternative: 'BF16'
            enterElement: 'BF16'
              => element -> BF16
              enterAtom: 'BF16'
                enterTerminal: 'BF16'
                exitTerminal: 'BF16'
              exitAtom: 'BF16'
            exitElement: 'BF16'
          exitAlternative: 'BF16'
        => elements -> ['BF16']
            => alternative -> BF16
        exitLabeledAlt: 'BF16'
      exitRuleAltList: 'f'|'l'|'f16'|'f32'|'f64'|'f128'|'bf16'|'F'|'L'|'F16'|'F32'|'F64'|'F128'|'BF16'
    exitRuleBlock: 'f'|'l'|'f16'|'f32'|'f64'|'f128'|'bf16'|'F'|'L'|'F16'|'F32'|'F64'|'F128'|'BF16'
  exitRuleSpec: floating-point-suffix:'f'|'l'|'f16'|'f32'|'f64'|'f128'|'bf16'|'F'|'L'|'F16'|'F32'|'F64'|'F128'|'BF16';

  enterRuleSpec: string-literal:encoding-prefix?'"'s-char*'"'|encoding-prefix?'R'raw-string;
    enterRuleBlock: encoding-prefix?'"'s-char*'"'|encoding-prefix?'R'raw-string
      enterRuleAltList: encoding-prefix?'"'s-char*'"'|encoding-prefix?'R'raw-string
        enterLabeledAlt: encoding-prefix?'"'s-char*'"'
          enterAlternative: encoding-prefix?'"'s-char*'"'
            enterElement: encoding-prefix?
              => element -> [encoding-prefix]
              enterAtom: encoding-prefix
                enterRuleref: encoding-prefix
                exitRuleref: encoding-prefix
              exitAtom: encoding-prefix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: encoding-prefix?
            enterElement: '"'
              => element -> "
              enterAtom: '"'
                enterTerminal: '"'
                exitTerminal: '"'
              exitAtom: '"'
            exitElement: '"'
            enterElement: s-char*
              => element -> [s-char]...
              enterAtom: s-char
                enterRuleref: s-char
                exitRuleref: s-char
              exitAtom: s-char
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: s-char*
            enterElement: '"'
              => element -> "
              enterAtom: '"'
                enterTerminal: '"'
                exitTerminal: '"'
              exitAtom: '"'
            exitElement: '"'
          exitAlternative: encoding-prefix?'"'s-char*'"'
        => elements -> ['[encoding-prefix]', '"', '[s-char]...', '"']
            => alternative -> [encoding-prefix] " [s-char]... "
        exitLabeledAlt: encoding-prefix?'"'s-char*'"'
        enterLabeledAlt: encoding-prefix?'R'raw-string
          enterAlternative: encoding-prefix?'R'raw-string
            enterElement: encoding-prefix?
              => element -> [encoding-prefix]
              enterAtom: encoding-prefix
                enterRuleref: encoding-prefix
                exitRuleref: encoding-prefix
              exitAtom: encoding-prefix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: encoding-prefix?
            enterElement: 'R'
              => element -> R
              enterAtom: 'R'
                enterTerminal: 'R'
                exitTerminal: 'R'
              exitAtom: 'R'
            exitElement: 'R'
            enterElement: raw-string
              => element -> {raw-string}
              enterAtom: raw-string
                enterRuleref: raw-string
                exitRuleref: raw-string
              exitAtom: raw-string
            exitElement: raw-string
          exitAlternative: encoding-prefix?'R'raw-string
        => elements -> ['[encoding-prefix]', 'R', '{raw-string}']
            => alternative -> [encoding-prefix] R {raw-string}
        exitLabeledAlt: encoding-prefix?'R'raw-string
      exitRuleAltList: encoding-prefix?'"'s-char*'"'|encoding-prefix?'R'raw-string
    exitRuleBlock: encoding-prefix?'"'s-char*'"'|encoding-prefix?'R'raw-string
  exitRuleSpec: string-literal:encoding-prefix?'"'s-char*'"'|encoding-prefix?'R'raw-string;

  enterRuleSpec: s-char:basic-s-char|escape-sequence|universal-character-name;
    enterRuleBlock: basic-s-char|escape-sequence|universal-character-name
      enterRuleAltList: basic-s-char|escape-sequence|universal-character-name
        enterLabeledAlt: basic-s-char
          enterAlternative: basic-s-char
            enterElement: basic-s-char
              => element -> {basic-s-char}
              enterAtom: basic-s-char
                enterRuleref: basic-s-char
                exitRuleref: basic-s-char
              exitAtom: basic-s-char
            exitElement: basic-s-char
          exitAlternative: basic-s-char
        => elements -> ['{basic-s-char}']
            => alternative -> {basic-s-char}
        exitLabeledAlt: basic-s-char
        enterLabeledAlt: escape-sequence
          enterAlternative: escape-sequence
            enterElement: escape-sequence
              => element -> {escape-sequence}
              enterAtom: escape-sequence
                enterRuleref: escape-sequence
                exitRuleref: escape-sequence
              exitAtom: escape-sequence
            exitElement: escape-sequence
          exitAlternative: escape-sequence
        => elements -> ['{escape-sequence}']
            => alternative -> {escape-sequence}
        exitLabeledAlt: escape-sequence
        enterLabeledAlt: universal-character-name
          enterAlternative: universal-character-name
            enterElement: universal-character-name
              => element -> {universal-character-name}
              enterAtom: universal-character-name
                enterRuleref: universal-character-name
                exitRuleref: universal-character-name
              exitAtom: universal-character-name
            exitElement: universal-character-name
          exitAlternative: universal-character-name
        => elements -> ['{universal-character-name}']
            => alternative -> {universal-character-name}
        exitLabeledAlt: universal-character-name
      exitRuleAltList: basic-s-char|escape-sequence|universal-character-name
    exitRuleBlock: basic-s-char|escape-sequence|universal-character-name
  exitRuleSpec: s-char:basic-s-char|escape-sequence|universal-character-name;

  enterRuleSpec: basic-s-char:'<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>';
    enterRuleBlock: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
      enterRuleAltList: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
        enterLabeledAlt: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
          enterAlternative: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
            enterElement: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
              => element -> <<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>
              enterAtom: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
                enterTerminal: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
                exitTerminal: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
              exitAtom: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
            exitElement: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
          exitAlternative: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
        => elements -> ['<<<Enter a basic source character except the double-quote ", backslash \\\\, or new-line \\\\n character.>>>']
            => alternative -> <<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>
        exitLabeledAlt: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
      exitRuleAltList: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
    exitRuleBlock: '<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
  exitRuleSpec: basic-s-char:'<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>';

  enterRuleSpec: raw-string:'"'d-char*'('r-char*')'d-char*'"';
    enterRuleBlock: '"'d-char*'('r-char*')'d-char*'"'
      enterRuleAltList: '"'d-char*'('r-char*')'d-char*'"'
        enterLabeledAlt: '"'d-char*'('r-char*')'d-char*'"'
          enterAlternative: '"'d-char*'('r-char*')'d-char*'"'
            enterElement: '"'
              => element -> "
              enterAtom: '"'
                enterTerminal: '"'
                exitTerminal: '"'
              exitAtom: '"'
            exitElement: '"'
            enterElement: d-char*
              => element -> [d-char]...
              enterAtom: d-char
                enterRuleref: d-char
                exitRuleref: d-char
              exitAtom: d-char
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: d-char*
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: r-char*
              => element -> [r-char]...
              enterAtom: r-char
                enterRuleref: r-char
                exitRuleref: r-char
              exitAtom: r-char
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: r-char*
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
            enterElement: d-char*
              => element -> [d-char]...
              enterAtom: d-char
                enterRuleref: d-char
                exitRuleref: d-char
              exitAtom: d-char
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: d-char*
            enterElement: '"'
              => element -> "
              enterAtom: '"'
                enterTerminal: '"'
                exitTerminal: '"'
              exitAtom: '"'
            exitElement: '"'
          exitAlternative: '"'d-char*'('r-char*')'d-char*'"'
        => elements -> ['"', '[d-char]...', '(', '[r-char]...', ')', '[d-char]...', '"']
            => alternative -> " [d-char]... ( [r-char]... ) [d-char]... "
        exitLabeledAlt: '"'d-char*'('r-char*')'d-char*'"'
      exitRuleAltList: '"'d-char*'('r-char*')'d-char*'"'
    exitRuleBlock: '"'d-char*'('r-char*')'d-char*'"'
  exitRuleSpec: raw-string:'"'d-char*'('r-char*')'d-char*'"';

  enterRuleSpec: r-char:'<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>';
    enterRuleBlock: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
      enterRuleAltList: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
        enterLabeledAlt: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
          enterAlternative: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
            enterElement: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
              => element -> <<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>
              enterAtom: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
                enterTerminal: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
                exitTerminal: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
              exitAtom: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
            exitElement: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
          exitAlternative: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
        => elements -> ['<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>']
            => alternative -> <<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>
        exitLabeledAlt: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
      exitRuleAltList: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
    exitRuleBlock: '<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
  exitRuleSpec: r-char:'<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>';

  enterRuleSpec: d-char:'<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>';
    enterRuleBlock: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
      enterRuleAltList: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
        enterLabeledAlt: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
          enterAlternative: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
            enterElement: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
              => element -> <<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>
              enterAtom: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
                enterTerminal: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
                exitTerminal: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
              exitAtom: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
            exitElement: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
          exitAlternative: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
        => elements -> ['<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\\\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>']
            => alternative -> <<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>
        exitLabeledAlt: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
      exitRuleAltList: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
    exitRuleBlock: '<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
  exitRuleSpec: d-char:'<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>';

  enterRuleSpec: boolean-literal:'false'|'true';
    enterRuleBlock: 'false'|'true'
      enterRuleAltList: 'false'|'true'
        enterLabeledAlt: 'false'
          enterAlternative: 'false'
            enterElement: 'false'
              => element -> false
              enterAtom: 'false'
                enterTerminal: 'false'
                exitTerminal: 'false'
              exitAtom: 'false'
            exitElement: 'false'
          exitAlternative: 'false'
        => elements -> ['false']
            => alternative -> false
        exitLabeledAlt: 'false'
        enterLabeledAlt: 'true'
          enterAlternative: 'true'
            enterElement: 'true'
              => element -> true
              enterAtom: 'true'
                enterTerminal: 'true'
                exitTerminal: 'true'
              exitAtom: 'true'
            exitElement: 'true'
          exitAlternative: 'true'
        => elements -> ['true']
            => alternative -> true
        exitLabeledAlt: 'true'
      exitRuleAltList: 'false'|'true'
    exitRuleBlock: 'false'|'true'
  exitRuleSpec: boolean-literal:'false'|'true';

  enterRuleSpec: pointer-literal:'nullptr';
    enterRuleBlock: 'nullptr'
      enterRuleAltList: 'nullptr'
        enterLabeledAlt: 'nullptr'
          enterAlternative: 'nullptr'
            enterElement: 'nullptr'
              => element -> nullptr
              enterAtom: 'nullptr'
                enterTerminal: 'nullptr'
                exitTerminal: 'nullptr'
              exitAtom: 'nullptr'
            exitElement: 'nullptr'
          exitAlternative: 'nullptr'
        => elements -> ['nullptr']
            => alternative -> nullptr
        exitLabeledAlt: 'nullptr'
      exitRuleAltList: 'nullptr'
    exitRuleBlock: 'nullptr'
  exitRuleSpec: pointer-literal:'nullptr';

  enterRuleSpec: user-defined-literal:user-defined-integer-literal|user-defined-floating-point-literal|user-defined-string-literal|user-defined-character-literal;
    enterRuleBlock: user-defined-integer-literal|user-defined-floating-point-literal|user-defined-string-literal|user-defined-character-literal
      enterRuleAltList: user-defined-integer-literal|user-defined-floating-point-literal|user-defined-string-literal|user-defined-character-literal
        enterLabeledAlt: user-defined-integer-literal
          enterAlternative: user-defined-integer-literal
            enterElement: user-defined-integer-literal
              => element -> {user-defined-integer-literal}
              enterAtom: user-defined-integer-literal
                enterRuleref: user-defined-integer-literal
                exitRuleref: user-defined-integer-literal
              exitAtom: user-defined-integer-literal
            exitElement: user-defined-integer-literal
          exitAlternative: user-defined-integer-literal
        => elements -> ['{user-defined-integer-literal}']
            => alternative -> {user-defined-integer-literal}
        exitLabeledAlt: user-defined-integer-literal
        enterLabeledAlt: user-defined-floating-point-literal
          enterAlternative: user-defined-floating-point-literal
            enterElement: user-defined-floating-point-literal
              => element -> {user-defined-floating-point-literal}
              enterAtom: user-defined-floating-point-literal
                enterRuleref: user-defined-floating-point-literal
                exitRuleref: user-defined-floating-point-literal
              exitAtom: user-defined-floating-point-literal
            exitElement: user-defined-floating-point-literal
          exitAlternative: user-defined-floating-point-literal
        => elements -> ['{user-defined-floating-point-literal}']
            => alternative -> {user-defined-floating-point-literal}
        exitLabeledAlt: user-defined-floating-point-literal
        enterLabeledAlt: user-defined-string-literal
          enterAlternative: user-defined-string-literal
            enterElement: user-defined-string-literal
              => element -> {user-defined-string-literal}
              enterAtom: user-defined-string-literal
                enterRuleref: user-defined-string-literal
                exitRuleref: user-defined-string-literal
              exitAtom: user-defined-string-literal
            exitElement: user-defined-string-literal
          exitAlternative: user-defined-string-literal
        => elements -> ['{user-defined-string-literal}']
            => alternative -> {user-defined-string-literal}
        exitLabeledAlt: user-defined-string-literal
        enterLabeledAlt: user-defined-character-literal
          enterAlternative: user-defined-character-literal
            enterElement: user-defined-character-literal
              => element -> {user-defined-character-literal}
              enterAtom: user-defined-character-literal
                enterRuleref: user-defined-character-literal
                exitRuleref: user-defined-character-literal
              exitAtom: user-defined-character-literal
            exitElement: user-defined-character-literal
          exitAlternative: user-defined-character-literal
        => elements -> ['{user-defined-character-literal}']
            => alternative -> {user-defined-character-literal}
        exitLabeledAlt: user-defined-character-literal
      exitRuleAltList: user-defined-integer-literal|user-defined-floating-point-literal|user-defined-string-literal|user-defined-character-literal
    exitRuleBlock: user-defined-integer-literal|user-defined-floating-point-literal|user-defined-string-literal|user-defined-character-literal
  exitRuleSpec: user-defined-literal:user-defined-integer-literal|user-defined-floating-point-literal|user-defined-string-literal|user-defined-character-literal;

  enterRuleSpec: user-defined-integer-literal:decimal-literalud-suffix|octal-literalud-suffix|hexadecimal-literalud-suffix|binary-literalud-suffix;
    enterRuleBlock: decimal-literalud-suffix|octal-literalud-suffix|hexadecimal-literalud-suffix|binary-literalud-suffix
      enterRuleAltList: decimal-literalud-suffix|octal-literalud-suffix|hexadecimal-literalud-suffix|binary-literalud-suffix
        enterLabeledAlt: decimal-literalud-suffix
          enterAlternative: decimal-literalud-suffix
            enterElement: decimal-literal
              => element -> {decimal-literal}
              enterAtom: decimal-literal
                enterRuleref: decimal-literal
                exitRuleref: decimal-literal
              exitAtom: decimal-literal
            exitElement: decimal-literal
            enterElement: ud-suffix
              => element -> {ud-suffix}
              enterAtom: ud-suffix
                enterRuleref: ud-suffix
                exitRuleref: ud-suffix
              exitAtom: ud-suffix
            exitElement: ud-suffix
          exitAlternative: decimal-literalud-suffix
        => elements -> ['{decimal-literal}', '{ud-suffix}']
            => alternative -> {decimal-literal} {ud-suffix}
        exitLabeledAlt: decimal-literalud-suffix
        enterLabeledAlt: octal-literalud-suffix
          enterAlternative: octal-literalud-suffix
            enterElement: octal-literal
              => element -> {octal-literal}
              enterAtom: octal-literal
                enterRuleref: octal-literal
                exitRuleref: octal-literal
              exitAtom: octal-literal
            exitElement: octal-literal
            enterElement: ud-suffix
              => element -> {ud-suffix}
              enterAtom: ud-suffix
                enterRuleref: ud-suffix
                exitRuleref: ud-suffix
              exitAtom: ud-suffix
            exitElement: ud-suffix
          exitAlternative: octal-literalud-suffix
        => elements -> ['{octal-literal}', '{ud-suffix}']
            => alternative -> {octal-literal} {ud-suffix}
        exitLabeledAlt: octal-literalud-suffix
        enterLabeledAlt: hexadecimal-literalud-suffix
          enterAlternative: hexadecimal-literalud-suffix
            enterElement: hexadecimal-literal
              => element -> {hexadecimal-literal}
              enterAtom: hexadecimal-literal
                enterRuleref: hexadecimal-literal
                exitRuleref: hexadecimal-literal
              exitAtom: hexadecimal-literal
            exitElement: hexadecimal-literal
            enterElement: ud-suffix
              => element -> {ud-suffix}
              enterAtom: ud-suffix
                enterRuleref: ud-suffix
                exitRuleref: ud-suffix
              exitAtom: ud-suffix
            exitElement: ud-suffix
          exitAlternative: hexadecimal-literalud-suffix
        => elements -> ['{hexadecimal-literal}', '{ud-suffix}']
            => alternative -> {hexadecimal-literal} {ud-suffix}
        exitLabeledAlt: hexadecimal-literalud-suffix
        enterLabeledAlt: binary-literalud-suffix
          enterAlternative: binary-literalud-suffix
            enterElement: binary-literal
              => element -> {binary-literal}
              enterAtom: binary-literal
                enterRuleref: binary-literal
                exitRuleref: binary-literal
              exitAtom: binary-literal
            exitElement: binary-literal
            enterElement: ud-suffix
              => element -> {ud-suffix}
              enterAtom: ud-suffix
                enterRuleref: ud-suffix
                exitRuleref: ud-suffix
              exitAtom: ud-suffix
            exitElement: ud-suffix
          exitAlternative: binary-literalud-suffix
        => elements -> ['{binary-literal}', '{ud-suffix}']
            => alternative -> {binary-literal} {ud-suffix}
        exitLabeledAlt: binary-literalud-suffix
      exitRuleAltList: decimal-literalud-suffix|octal-literalud-suffix|hexadecimal-literalud-suffix|binary-literalud-suffix
    exitRuleBlock: decimal-literalud-suffix|octal-literalud-suffix|hexadecimal-literalud-suffix|binary-literalud-suffix
  exitRuleSpec: user-defined-integer-literal:decimal-literalud-suffix|octal-literalud-suffix|hexadecimal-literalud-suffix|binary-literalud-suffix;

  enterRuleSpec: user-defined-floating-point-literal:fractional-constantexponent-part?ud-suffix|digit-sequenceexponent-partud-suffix|hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partud-suffix|hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partud-suffix;
    enterRuleBlock: fractional-constantexponent-part?ud-suffix|digit-sequenceexponent-partud-suffix|hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partud-suffix|hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partud-suffix
      enterRuleAltList: fractional-constantexponent-part?ud-suffix|digit-sequenceexponent-partud-suffix|hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partud-suffix|hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partud-suffix
        enterLabeledAlt: fractional-constantexponent-part?ud-suffix
          enterAlternative: fractional-constantexponent-part?ud-suffix
            enterElement: fractional-constant
              => element -> {fractional-constant}
              enterAtom: fractional-constant
                enterRuleref: fractional-constant
                exitRuleref: fractional-constant
              exitAtom: fractional-constant
            exitElement: fractional-constant
            enterElement: exponent-part?
              => element -> [exponent-part]
              enterAtom: exponent-part
                enterRuleref: exponent-part
                exitRuleref: exponent-part
              exitAtom: exponent-part
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: exponent-part?
            enterElement: ud-suffix
              => element -> {ud-suffix}
              enterAtom: ud-suffix
                enterRuleref: ud-suffix
                exitRuleref: ud-suffix
              exitAtom: ud-suffix
            exitElement: ud-suffix
          exitAlternative: fractional-constantexponent-part?ud-suffix
        => elements -> ['{fractional-constant}', '[exponent-part]', '{ud-suffix}']
            => alternative -> {fractional-constant} [exponent-part] {ud-suffix}
        exitLabeledAlt: fractional-constantexponent-part?ud-suffix
        enterLabeledAlt: digit-sequenceexponent-partud-suffix
          enterAlternative: digit-sequenceexponent-partud-suffix
            enterElement: digit-sequence
              => element -> {digit-sequence}
              enterAtom: digit-sequence
                enterRuleref: digit-sequence
                exitRuleref: digit-sequence
              exitAtom: digit-sequence
            exitElement: digit-sequence
            enterElement: exponent-part
              => element -> {exponent-part}
              enterAtom: exponent-part
                enterRuleref: exponent-part
                exitRuleref: exponent-part
              exitAtom: exponent-part
            exitElement: exponent-part
            enterElement: ud-suffix
              => element -> {ud-suffix}
              enterAtom: ud-suffix
                enterRuleref: ud-suffix
                exitRuleref: ud-suffix
              exitAtom: ud-suffix
            exitElement: ud-suffix
          exitAlternative: digit-sequenceexponent-partud-suffix
        => elements -> ['{digit-sequence}', '{exponent-part}', '{ud-suffix}']
            => alternative -> {digit-sequence} {exponent-part} {ud-suffix}
        exitLabeledAlt: digit-sequenceexponent-partud-suffix
        enterLabeledAlt: hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partud-suffix
          enterAlternative: hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partud-suffix
            enterElement: hexadecimal-prefix
              => element -> {hexadecimal-prefix}
              enterAtom: hexadecimal-prefix
                enterRuleref: hexadecimal-prefix
                exitRuleref: hexadecimal-prefix
              exitAtom: hexadecimal-prefix
            exitElement: hexadecimal-prefix
            enterElement: hexadecimal-fractional-constant
              => element -> {hexadecimal-fractional-constant}
              enterAtom: hexadecimal-fractional-constant
                enterRuleref: hexadecimal-fractional-constant
                exitRuleref: hexadecimal-fractional-constant
              exitAtom: hexadecimal-fractional-constant
            exitElement: hexadecimal-fractional-constant
            enterElement: binary-exponent-part
              => element -> {binary-exponent-part}
              enterAtom: binary-exponent-part
                enterRuleref: binary-exponent-part
                exitRuleref: binary-exponent-part
              exitAtom: binary-exponent-part
            exitElement: binary-exponent-part
            enterElement: ud-suffix
              => element -> {ud-suffix}
              enterAtom: ud-suffix
                enterRuleref: ud-suffix
                exitRuleref: ud-suffix
              exitAtom: ud-suffix
            exitElement: ud-suffix
          exitAlternative: hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partud-suffix
        => elements -> ['{hexadecimal-prefix}', '{hexadecimal-fractional-constant}', '{binary-exponent-part}', '{ud-suffix}']
            => alternative -> {hexadecimal-prefix} {hexadecimal-fractional-constant} {binary-exponent-part} {ud-suffix}
        exitLabeledAlt: hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partud-suffix
        enterLabeledAlt: hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partud-suffix
          enterAlternative: hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partud-suffix
            enterElement: hexadecimal-prefix
              => element -> {hexadecimal-prefix}
              enterAtom: hexadecimal-prefix
                enterRuleref: hexadecimal-prefix
                exitRuleref: hexadecimal-prefix
              exitAtom: hexadecimal-prefix
            exitElement: hexadecimal-prefix
            enterElement: hexadecimal-digit-sequence
              => element -> {hexadecimal-digit-sequence}
              enterAtom: hexadecimal-digit-sequence
                enterRuleref: hexadecimal-digit-sequence
                exitRuleref: hexadecimal-digit-sequence
              exitAtom: hexadecimal-digit-sequence
            exitElement: hexadecimal-digit-sequence
            enterElement: binary-exponent-part
              => element -> {binary-exponent-part}
              enterAtom: binary-exponent-part
                enterRuleref: binary-exponent-part
                exitRuleref: binary-exponent-part
              exitAtom: binary-exponent-part
            exitElement: binary-exponent-part
            enterElement: ud-suffix
              => element -> {ud-suffix}
              enterAtom: ud-suffix
                enterRuleref: ud-suffix
                exitRuleref: ud-suffix
              exitAtom: ud-suffix
            exitElement: ud-suffix
          exitAlternative: hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partud-suffix
        => elements -> ['{hexadecimal-prefix}', '{hexadecimal-digit-sequence}', '{binary-exponent-part}', '{ud-suffix}']
            => alternative -> {hexadecimal-prefix} {hexadecimal-digit-sequence} {binary-exponent-part} {ud-suffix}
        exitLabeledAlt: hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partud-suffix
      exitRuleAltList: fractional-constantexponent-part?ud-suffix|digit-sequenceexponent-partud-suffix|hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partud-suffix|hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partud-suffix
    exitRuleBlock: fractional-constantexponent-part?ud-suffix|digit-sequenceexponent-partud-suffix|hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partud-suffix|hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partud-suffix
  exitRuleSpec: user-defined-floating-point-literal:fractional-constantexponent-part?ud-suffix|digit-sequenceexponent-partud-suffix|hexadecimal-prefixhexadecimal-fractional-constantbinary-exponent-partud-suffix|hexadecimal-prefixhexadecimal-digit-sequencebinary-exponent-partud-suffix;

  enterRuleSpec: user-defined-string-literal:string-literalud-suffix;
    enterRuleBlock: string-literalud-suffix
      enterRuleAltList: string-literalud-suffix
        enterLabeledAlt: string-literalud-suffix
          enterAlternative: string-literalud-suffix
            enterElement: string-literal
              => element -> {string-literal}
              enterAtom: string-literal
                enterRuleref: string-literal
                exitRuleref: string-literal
              exitAtom: string-literal
            exitElement: string-literal
            enterElement: ud-suffix
              => element -> {ud-suffix}
              enterAtom: ud-suffix
                enterRuleref: ud-suffix
                exitRuleref: ud-suffix
              exitAtom: ud-suffix
            exitElement: ud-suffix
          exitAlternative: string-literalud-suffix
        => elements -> ['{string-literal}', '{ud-suffix}']
            => alternative -> {string-literal} {ud-suffix}
        exitLabeledAlt: string-literalud-suffix
      exitRuleAltList: string-literalud-suffix
    exitRuleBlock: string-literalud-suffix
  exitRuleSpec: user-defined-string-literal:string-literalud-suffix;

  enterRuleSpec: user-defined-character-literal:character-literalud-suffix;
    enterRuleBlock: character-literalud-suffix
      enterRuleAltList: character-literalud-suffix
        enterLabeledAlt: character-literalud-suffix
          enterAlternative: character-literalud-suffix
            enterElement: character-literal
              => element -> {character-literal}
              enterAtom: character-literal
                enterRuleref: character-literal
                exitRuleref: character-literal
              exitAtom: character-literal
            exitElement: character-literal
            enterElement: ud-suffix
              => element -> {ud-suffix}
              enterAtom: ud-suffix
                enterRuleref: ud-suffix
                exitRuleref: ud-suffix
              exitAtom: ud-suffix
            exitElement: ud-suffix
          exitAlternative: character-literalud-suffix
        => elements -> ['{character-literal}', '{ud-suffix}']
            => alternative -> {character-literal} {ud-suffix}
        exitLabeledAlt: character-literalud-suffix
      exitRuleAltList: character-literalud-suffix
    exitRuleBlock: character-literalud-suffix
  exitRuleSpec: user-defined-character-literal:character-literalud-suffix;

  enterRuleSpec: ud-suffix:identifier;
    enterRuleBlock: identifier
      enterRuleAltList: identifier
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
      exitRuleAltList: identifier
    exitRuleBlock: identifier
  exitRuleSpec: ud-suffix:identifier;

  enterRuleSpec: translation-unit:declaration*|global-module-fragment?module-declarationdeclaration*private-module-fragment?;
    enterRuleBlock: declaration*|global-module-fragment?module-declarationdeclaration*private-module-fragment?
      enterRuleAltList: declaration*|global-module-fragment?module-declarationdeclaration*private-module-fragment?
        enterLabeledAlt: declaration*
          enterAlternative: declaration*
            enterElement: declaration*
              => element -> [declaration]...
              enterAtom: declaration
                enterRuleref: declaration
                exitRuleref: declaration
              exitAtom: declaration
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: declaration*
          exitAlternative: declaration*
        => elements -> ['[declaration]...']
            => alternative -> [declaration]...
        exitLabeledAlt: declaration*
        enterLabeledAlt: global-module-fragment?module-declarationdeclaration*private-module-fragment?
          enterAlternative: global-module-fragment?module-declarationdeclaration*private-module-fragment?
            enterElement: global-module-fragment?
              => element -> [global-module-fragment]
              enterAtom: global-module-fragment
                enterRuleref: global-module-fragment
                exitRuleref: global-module-fragment
              exitAtom: global-module-fragment
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: global-module-fragment?
            enterElement: module-declaration
              => element -> {module-declaration}
              enterAtom: module-declaration
                enterRuleref: module-declaration
                exitRuleref: module-declaration
              exitAtom: module-declaration
            exitElement: module-declaration
            enterElement: declaration*
              => element -> [declaration]...
              enterAtom: declaration
                enterRuleref: declaration
                exitRuleref: declaration
              exitAtom: declaration
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: declaration*
            enterElement: private-module-fragment?
              => element -> [private-module-fragment]
              enterAtom: private-module-fragment
                enterRuleref: private-module-fragment
                exitRuleref: private-module-fragment
              exitAtom: private-module-fragment
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: private-module-fragment?
          exitAlternative: global-module-fragment?module-declarationdeclaration*private-module-fragment?
        => elements -> ['[global-module-fragment]', '{module-declaration}', '[declaration]...', '[private-module-fragment]']
            => alternative -> [global-module-fragment] {module-declaration} [declaration]... [private-module-fragment]
        exitLabeledAlt: global-module-fragment?module-declarationdeclaration*private-module-fragment?
      exitRuleAltList: declaration*|global-module-fragment?module-declarationdeclaration*private-module-fragment?
    exitRuleBlock: declaration*|global-module-fragment?module-declarationdeclaration*private-module-fragment?
  exitRuleSpec: translation-unit:declaration*|global-module-fragment?module-declarationdeclaration*private-module-fragment?;

  enterRuleSpec: primary-expression:literal|'this'|'('expression')'|id-expression|lambda-expression|fold-expression|requires-expression;
    enterRuleBlock: literal|'this'|'('expression')'|id-expression|lambda-expression|fold-expression|requires-expression
      enterRuleAltList: literal|'this'|'('expression')'|id-expression|lambda-expression|fold-expression|requires-expression
        enterLabeledAlt: literal
          enterAlternative: literal
            enterElement: literal
              => element -> {literal}
              enterAtom: literal
                enterRuleref: literal
                exitRuleref: literal
              exitAtom: literal
            exitElement: literal
          exitAlternative: literal
        => elements -> ['{literal}']
            => alternative -> {literal}
        exitLabeledAlt: literal
        enterLabeledAlt: 'this'
          enterAlternative: 'this'
            enterElement: 'this'
              => element -> this
              enterAtom: 'this'
                enterTerminal: 'this'
                exitTerminal: 'this'
              exitAtom: 'this'
            exitElement: 'this'
          exitAlternative: 'this'
        => elements -> ['this']
            => alternative -> this
        exitLabeledAlt: 'this'
        enterLabeledAlt: '('expression')'
          enterAlternative: '('expression')'
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '('expression')'
        => elements -> ['(', '{expression}', ')']
            => alternative -> ( {expression} )
        exitLabeledAlt: '('expression')'
        enterLabeledAlt: id-expression
          enterAlternative: id-expression
            enterElement: id-expression
              => element -> {id-expression}
              enterAtom: id-expression
                enterRuleref: id-expression
                exitRuleref: id-expression
              exitAtom: id-expression
            exitElement: id-expression
          exitAlternative: id-expression
        => elements -> ['{id-expression}']
            => alternative -> {id-expression}
        exitLabeledAlt: id-expression
        enterLabeledAlt: lambda-expression
          enterAlternative: lambda-expression
            enterElement: lambda-expression
              => element -> {lambda-expression}
              enterAtom: lambda-expression
                enterRuleref: lambda-expression
                exitRuleref: lambda-expression
              exitAtom: lambda-expression
            exitElement: lambda-expression
          exitAlternative: lambda-expression
        => elements -> ['{lambda-expression}']
            => alternative -> {lambda-expression}
        exitLabeledAlt: lambda-expression
        enterLabeledAlt: fold-expression
          enterAlternative: fold-expression
            enterElement: fold-expression
              => element -> {fold-expression}
              enterAtom: fold-expression
                enterRuleref: fold-expression
                exitRuleref: fold-expression
              exitAtom: fold-expression
            exitElement: fold-expression
          exitAlternative: fold-expression
        => elements -> ['{fold-expression}']
            => alternative -> {fold-expression}
        exitLabeledAlt: fold-expression
        enterLabeledAlt: requires-expression
          enterAlternative: requires-expression
            enterElement: requires-expression
              => element -> {requires-expression}
              enterAtom: requires-expression
                enterRuleref: requires-expression
                exitRuleref: requires-expression
              exitAtom: requires-expression
            exitElement: requires-expression
          exitAlternative: requires-expression
        => elements -> ['{requires-expression}']
            => alternative -> {requires-expression}
        exitLabeledAlt: requires-expression
      exitRuleAltList: literal|'this'|'('expression')'|id-expression|lambda-expression|fold-expression|requires-expression
    exitRuleBlock: literal|'this'|'('expression')'|id-expression|lambda-expression|fold-expression|requires-expression
  exitRuleSpec: primary-expression:literal|'this'|'('expression')'|id-expression|lambda-expression|fold-expression|requires-expression;

  enterRuleSpec: id-expression:unqualified-id|qualified-id|pack-index-expression;
    enterRuleBlock: unqualified-id|qualified-id|pack-index-expression
      enterRuleAltList: unqualified-id|qualified-id|pack-index-expression
        enterLabeledAlt: unqualified-id
          enterAlternative: unqualified-id
            enterElement: unqualified-id
              => element -> {unqualified-id}
              enterAtom: unqualified-id
                enterRuleref: unqualified-id
                exitRuleref: unqualified-id
              exitAtom: unqualified-id
            exitElement: unqualified-id
          exitAlternative: unqualified-id
        => elements -> ['{unqualified-id}']
            => alternative -> {unqualified-id}
        exitLabeledAlt: unqualified-id
        enterLabeledAlt: qualified-id
          enterAlternative: qualified-id
            enterElement: qualified-id
              => element -> {qualified-id}
              enterAtom: qualified-id
                enterRuleref: qualified-id
                exitRuleref: qualified-id
              exitAtom: qualified-id
            exitElement: qualified-id
          exitAlternative: qualified-id
        => elements -> ['{qualified-id}']
            => alternative -> {qualified-id}
        exitLabeledAlt: qualified-id
        enterLabeledAlt: pack-index-expression
          enterAlternative: pack-index-expression
            enterElement: pack-index-expression
              => element -> {pack-index-expression}
              enterAtom: pack-index-expression
                enterRuleref: pack-index-expression
                exitRuleref: pack-index-expression
              exitAtom: pack-index-expression
            exitElement: pack-index-expression
          exitAlternative: pack-index-expression
        => elements -> ['{pack-index-expression}']
            => alternative -> {pack-index-expression}
        exitLabeledAlt: pack-index-expression
      exitRuleAltList: unqualified-id|qualified-id|pack-index-expression
    exitRuleBlock: unqualified-id|qualified-id|pack-index-expression
  exitRuleSpec: id-expression:unqualified-id|qualified-id|pack-index-expression;

  enterRuleSpec: unqualified-id:identifier|operator-function-id|conversion-function-id|literal-operator-id|'~'type-name|'~'computed-type-specifier|template-id;
    enterRuleBlock: identifier|operator-function-id|conversion-function-id|literal-operator-id|'~'type-name|'~'computed-type-specifier|template-id
      enterRuleAltList: identifier|operator-function-id|conversion-function-id|literal-operator-id|'~'type-name|'~'computed-type-specifier|template-id
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
        enterLabeledAlt: operator-function-id
          enterAlternative: operator-function-id
            enterElement: operator-function-id
              => element -> {operator-function-id}
              enterAtom: operator-function-id
                enterRuleref: operator-function-id
                exitRuleref: operator-function-id
              exitAtom: operator-function-id
            exitElement: operator-function-id
          exitAlternative: operator-function-id
        => elements -> ['{operator-function-id}']
            => alternative -> {operator-function-id}
        exitLabeledAlt: operator-function-id
        enterLabeledAlt: conversion-function-id
          enterAlternative: conversion-function-id
            enterElement: conversion-function-id
              => element -> {conversion-function-id}
              enterAtom: conversion-function-id
                enterRuleref: conversion-function-id
                exitRuleref: conversion-function-id
              exitAtom: conversion-function-id
            exitElement: conversion-function-id
          exitAlternative: conversion-function-id
        => elements -> ['{conversion-function-id}']
            => alternative -> {conversion-function-id}
        exitLabeledAlt: conversion-function-id
        enterLabeledAlt: literal-operator-id
          enterAlternative: literal-operator-id
            enterElement: literal-operator-id
              => element -> {literal-operator-id}
              enterAtom: literal-operator-id
                enterRuleref: literal-operator-id
                exitRuleref: literal-operator-id
              exitAtom: literal-operator-id
            exitElement: literal-operator-id
          exitAlternative: literal-operator-id
        => elements -> ['{literal-operator-id}']
            => alternative -> {literal-operator-id}
        exitLabeledAlt: literal-operator-id
        enterLabeledAlt: '~'type-name
          enterAlternative: '~'type-name
            enterElement: '~'
              => element -> ~
              enterAtom: '~'
                enterTerminal: '~'
                exitTerminal: '~'
              exitAtom: '~'
            exitElement: '~'
            enterElement: type-name
              => element -> {type-name}
              enterAtom: type-name
                enterRuleref: type-name
                exitRuleref: type-name
              exitAtom: type-name
            exitElement: type-name
          exitAlternative: '~'type-name
        => elements -> ['~', '{type-name}']
            => alternative -> ~ {type-name}
        exitLabeledAlt: '~'type-name
        enterLabeledAlt: '~'computed-type-specifier
          enterAlternative: '~'computed-type-specifier
            enterElement: '~'
              => element -> ~
              enterAtom: '~'
                enterTerminal: '~'
                exitTerminal: '~'
              exitAtom: '~'
            exitElement: '~'
            enterElement: computed-type-specifier
              => element -> {computed-type-specifier}
              enterAtom: computed-type-specifier
                enterRuleref: computed-type-specifier
                exitRuleref: computed-type-specifier
              exitAtom: computed-type-specifier
            exitElement: computed-type-specifier
          exitAlternative: '~'computed-type-specifier
        => elements -> ['~', '{computed-type-specifier}']
            => alternative -> ~ {computed-type-specifier}
        exitLabeledAlt: '~'computed-type-specifier
        enterLabeledAlt: template-id
          enterAlternative: template-id
            enterElement: template-id
              => element -> {template-id}
              enterAtom: template-id
                enterRuleref: template-id
                exitRuleref: template-id
              exitAtom: template-id
            exitElement: template-id
          exitAlternative: template-id
        => elements -> ['{template-id}']
            => alternative -> {template-id}
        exitLabeledAlt: template-id
      exitRuleAltList: identifier|operator-function-id|conversion-function-id|literal-operator-id|'~'type-name|'~'computed-type-specifier|template-id
    exitRuleBlock: identifier|operator-function-id|conversion-function-id|literal-operator-id|'~'type-name|'~'computed-type-specifier|template-id
  exitRuleSpec: unqualified-id:identifier|operator-function-id|conversion-function-id|literal-operator-id|'~'type-name|'~'computed-type-specifier|template-id;

  enterRuleSpec: template:'template';
    enterRuleBlock: 'template'
      enterRuleAltList: 'template'
        enterLabeledAlt: 'template'
          enterAlternative: 'template'
            enterElement: 'template'
              => element -> template
              enterAtom: 'template'
                enterTerminal: 'template'
                exitTerminal: 'template'
              exitAtom: 'template'
            exitElement: 'template'
          exitAlternative: 'template'
        => elements -> ['template']
            => alternative -> template
        exitLabeledAlt: 'template'
      exitRuleAltList: 'template'
    exitRuleBlock: 'template'
  exitRuleSpec: template:'template';

  enterRuleSpec: qualified-id:nested-name-specifiertemplate?unqualified-id;
    enterRuleBlock: nested-name-specifiertemplate?unqualified-id
      enterRuleAltList: nested-name-specifiertemplate?unqualified-id
        enterLabeledAlt: nested-name-specifiertemplate?unqualified-id
          enterAlternative: nested-name-specifiertemplate?unqualified-id
            enterElement: nested-name-specifier
              => element -> {nested-name-specifier}
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
            exitElement: nested-name-specifier
            enterElement: template?
              => element -> [template]
              enterAtom: template
                enterRuleref: template
                exitRuleref: template
              exitAtom: template
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: template?
            enterElement: unqualified-id
              => element -> {unqualified-id}
              enterAtom: unqualified-id
                enterRuleref: unqualified-id
                exitRuleref: unqualified-id
              exitAtom: unqualified-id
            exitElement: unqualified-id
          exitAlternative: nested-name-specifiertemplate?unqualified-id
        => elements -> ['{nested-name-specifier}', '[template]', '{unqualified-id}']
            => alternative -> {nested-name-specifier} [template] {unqualified-id}
        exitLabeledAlt: nested-name-specifiertemplate?unqualified-id
      exitRuleAltList: nested-name-specifiertemplate?unqualified-id
    exitRuleBlock: nested-name-specifiertemplate?unqualified-id
  exitRuleSpec: qualified-id:nested-name-specifiertemplate?unqualified-id;

  enterRuleSpec: nested-name-specifier:'::'|type-name'::'|namespace-name'::'|computed-type-specifier'::'|nested-name-specifieridentifier'::'|nested-name-specifiertemplate?simple-template-id'::';
    enterRuleBlock: '::'|type-name'::'|namespace-name'::'|computed-type-specifier'::'|nested-name-specifieridentifier'::'|nested-name-specifiertemplate?simple-template-id'::'
      enterRuleAltList: '::'|type-name'::'|namespace-name'::'|computed-type-specifier'::'|nested-name-specifieridentifier'::'|nested-name-specifiertemplate?simple-template-id'::'
        enterLabeledAlt: '::'
          enterAlternative: '::'
            enterElement: '::'
              => element -> ::
              enterAtom: '::'
                enterTerminal: '::'
                exitTerminal: '::'
              exitAtom: '::'
            exitElement: '::'
          exitAlternative: '::'
        => elements -> ['::']
            => alternative -> ::
        exitLabeledAlt: '::'
        enterLabeledAlt: type-name'::'
          enterAlternative: type-name'::'
            enterElement: type-name
              => element -> {type-name}
              enterAtom: type-name
                enterRuleref: type-name
                exitRuleref: type-name
              exitAtom: type-name
            exitElement: type-name
            enterElement: '::'
              => element -> ::
              enterAtom: '::'
                enterTerminal: '::'
                exitTerminal: '::'
              exitAtom: '::'
            exitElement: '::'
          exitAlternative: type-name'::'
        => elements -> ['{type-name}', '::']
            => alternative -> {type-name} ::
        exitLabeledAlt: type-name'::'
        enterLabeledAlt: namespace-name'::'
          enterAlternative: namespace-name'::'
            enterElement: namespace-name
              => element -> {namespace-name}
              enterAtom: namespace-name
                enterRuleref: namespace-name
                exitRuleref: namespace-name
              exitAtom: namespace-name
            exitElement: namespace-name
            enterElement: '::'
              => element -> ::
              enterAtom: '::'
                enterTerminal: '::'
                exitTerminal: '::'
              exitAtom: '::'
            exitElement: '::'
          exitAlternative: namespace-name'::'
        => elements -> ['{namespace-name}', '::']
            => alternative -> {namespace-name} ::
        exitLabeledAlt: namespace-name'::'
        enterLabeledAlt: computed-type-specifier'::'
          enterAlternative: computed-type-specifier'::'
            enterElement: computed-type-specifier
              => element -> {computed-type-specifier}
              enterAtom: computed-type-specifier
                enterRuleref: computed-type-specifier
                exitRuleref: computed-type-specifier
              exitAtom: computed-type-specifier
            exitElement: computed-type-specifier
            enterElement: '::'
              => element -> ::
              enterAtom: '::'
                enterTerminal: '::'
                exitTerminal: '::'
              exitAtom: '::'
            exitElement: '::'
          exitAlternative: computed-type-specifier'::'
        => elements -> ['{computed-type-specifier}', '::']
            => alternative -> {computed-type-specifier} ::
        exitLabeledAlt: computed-type-specifier'::'
        enterLabeledAlt: nested-name-specifieridentifier'::'
          enterAlternative: nested-name-specifieridentifier'::'
            enterElement: nested-name-specifier
              => element -> {nested-name-specifier}
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
            exitElement: nested-name-specifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: '::'
              => element -> ::
              enterAtom: '::'
                enterTerminal: '::'
                exitTerminal: '::'
              exitAtom: '::'
            exitElement: '::'
          exitAlternative: nested-name-specifieridentifier'::'
        => elements -> ['{nested-name-specifier}', '{identifier}', '::']
            => alternative -> {nested-name-specifier} {identifier} ::
        exitLabeledAlt: nested-name-specifieridentifier'::'
        enterLabeledAlt: nested-name-specifiertemplate?simple-template-id'::'
          enterAlternative: nested-name-specifiertemplate?simple-template-id'::'
            enterElement: nested-name-specifier
              => element -> {nested-name-specifier}
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
            exitElement: nested-name-specifier
            enterElement: template?
              => element -> [template]
              enterAtom: template
                enterRuleref: template
                exitRuleref: template
              exitAtom: template
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: template?
            enterElement: simple-template-id
              => element -> {simple-template-id}
              enterAtom: simple-template-id
                enterRuleref: simple-template-id
                exitRuleref: simple-template-id
              exitAtom: simple-template-id
            exitElement: simple-template-id
            enterElement: '::'
              => element -> ::
              enterAtom: '::'
                enterTerminal: '::'
                exitTerminal: '::'
              exitAtom: '::'
            exitElement: '::'
          exitAlternative: nested-name-specifiertemplate?simple-template-id'::'
        => elements -> ['{nested-name-specifier}', '[template]', '{simple-template-id}', '::']
            => alternative -> {nested-name-specifier} [template] {simple-template-id} ::
        exitLabeledAlt: nested-name-specifiertemplate?simple-template-id'::'
      exitRuleAltList: '::'|type-name'::'|namespace-name'::'|computed-type-specifier'::'|nested-name-specifieridentifier'::'|nested-name-specifiertemplate?simple-template-id'::'
    exitRuleBlock: '::'|type-name'::'|namespace-name'::'|computed-type-specifier'::'|nested-name-specifieridentifier'::'|nested-name-specifiertemplate?simple-template-id'::'
  exitRuleSpec: nested-name-specifier:'::'|type-name'::'|namespace-name'::'|computed-type-specifier'::'|nested-name-specifieridentifier'::'|nested-name-specifiertemplate?simple-template-id'::';

  enterRuleSpec: pack-index-expression:id-expression'... ['constant-expression']';
    enterRuleBlock: id-expression'... ['constant-expression']'
      enterRuleAltList: id-expression'... ['constant-expression']'
        enterLabeledAlt: id-expression'... ['constant-expression']'
          enterAlternative: id-expression'... ['constant-expression']'
            enterElement: id-expression
              => element -> {id-expression}
              enterAtom: id-expression
                enterRuleref: id-expression
                exitRuleref: id-expression
              exitAtom: id-expression
            exitElement: id-expression
            enterElement: '... ['
              => element -> ... [
              enterAtom: '... ['
                enterTerminal: '... ['
                exitTerminal: '... ['
              exitAtom: '... ['
            exitElement: '... ['
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
            enterElement: ']'
              => element -> ]
              enterAtom: ']'
                enterTerminal: ']'
                exitTerminal: ']'
              exitAtom: ']'
            exitElement: ']'
          exitAlternative: id-expression'... ['constant-expression']'
        => elements -> ['{id-expression}', '... [', '{constant-expression}', ']']
            => alternative -> {id-expression} ... [ {constant-expression} ]
        exitLabeledAlt: id-expression'... ['constant-expression']'
      exitRuleAltList: id-expression'... ['constant-expression']'
    exitRuleBlock: id-expression'... ['constant-expression']'
  exitRuleSpec: pack-index-expression:id-expression'... ['constant-expression']';

  enterRuleSpec: lambda-expression:lambda-introducerattribute-specifier*lambda-declaratorcompound-statement|lambda-introducer'<'template-parameter-list'>'requires-clause?attribute-specifier*lambda-declaratorcompound-statement;
    enterRuleBlock: lambda-introducerattribute-specifier*lambda-declaratorcompound-statement|lambda-introducer'<'template-parameter-list'>'requires-clause?attribute-specifier*lambda-declaratorcompound-statement
      enterRuleAltList: lambda-introducerattribute-specifier*lambda-declaratorcompound-statement|lambda-introducer'<'template-parameter-list'>'requires-clause?attribute-specifier*lambda-declaratorcompound-statement
        enterLabeledAlt: lambda-introducerattribute-specifier*lambda-declaratorcompound-statement
          enterAlternative: lambda-introducerattribute-specifier*lambda-declaratorcompound-statement
            enterElement: lambda-introducer
              => element -> {lambda-introducer}
              enterAtom: lambda-introducer
                enterRuleref: lambda-introducer
                exitRuleref: lambda-introducer
              exitAtom: lambda-introducer
            exitElement: lambda-introducer
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: lambda-declarator
              => element -> {lambda-declarator}
              enterAtom: lambda-declarator
                enterRuleref: lambda-declarator
                exitRuleref: lambda-declarator
              exitAtom: lambda-declarator
            exitElement: lambda-declarator
            enterElement: compound-statement
              => element -> {compound-statement}
              enterAtom: compound-statement
                enterRuleref: compound-statement
                exitRuleref: compound-statement
              exitAtom: compound-statement
            exitElement: compound-statement
          exitAlternative: lambda-introducerattribute-specifier*lambda-declaratorcompound-statement
        => elements -> ['{lambda-introducer}', '[attribute-specifier]...', '{lambda-declarator}', '{compound-statement}']
            => alternative -> {lambda-introducer} [attribute-specifier]... {lambda-declarator} {compound-statement}
        exitLabeledAlt: lambda-introducerattribute-specifier*lambda-declaratorcompound-statement
        enterLabeledAlt: lambda-introducer'<'template-parameter-list'>'requires-clause?attribute-specifier*lambda-declaratorcompound-statement
          enterAlternative: lambda-introducer'<'template-parameter-list'>'requires-clause?attribute-specifier*lambda-declaratorcompound-statement
            enterElement: lambda-introducer
              => element -> {lambda-introducer}
              enterAtom: lambda-introducer
                enterRuleref: lambda-introducer
                exitRuleref: lambda-introducer
              exitAtom: lambda-introducer
            exitElement: lambda-introducer
            enterElement: '<'
              => element -> <
              enterAtom: '<'
                enterTerminal: '<'
                exitTerminal: '<'
              exitAtom: '<'
            exitElement: '<'
            enterElement: template-parameter-list
              => element -> {template-parameter-list}
              enterAtom: template-parameter-list
                enterRuleref: template-parameter-list
                exitRuleref: template-parameter-list
              exitAtom: template-parameter-list
            exitElement: template-parameter-list
            enterElement: '>'
              => element -> >
              enterAtom: '>'
                enterTerminal: '>'
                exitTerminal: '>'
              exitAtom: '>'
            exitElement: '>'
            enterElement: requires-clause?
              => element -> [requires-clause]
              enterAtom: requires-clause
                enterRuleref: requires-clause
                exitRuleref: requires-clause
              exitAtom: requires-clause
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: requires-clause?
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: lambda-declarator
              => element -> {lambda-declarator}
              enterAtom: lambda-declarator
                enterRuleref: lambda-declarator
                exitRuleref: lambda-declarator
              exitAtom: lambda-declarator
            exitElement: lambda-declarator
            enterElement: compound-statement
              => element -> {compound-statement}
              enterAtom: compound-statement
                enterRuleref: compound-statement
                exitRuleref: compound-statement
              exitAtom: compound-statement
            exitElement: compound-statement
          exitAlternative: lambda-introducer'<'template-parameter-list'>'requires-clause?attribute-specifier*lambda-declaratorcompound-statement
        => elements -> ['{lambda-introducer}', '<', '{template-parameter-list}', '>', '[requires-clause]', '[attribute-specifier]...', '{lambda-declarator}', '{compound-statement}']
            => alternative -> {lambda-introducer} < {template-parameter-list} > [requires-clause] [attribute-specifier]... {lambda-declarator} {compound-statement}
        exitLabeledAlt: lambda-introducer'<'template-parameter-list'>'requires-clause?attribute-specifier*lambda-declaratorcompound-statement
      exitRuleAltList: lambda-introducerattribute-specifier*lambda-declaratorcompound-statement|lambda-introducer'<'template-parameter-list'>'requires-clause?attribute-specifier*lambda-declaratorcompound-statement
    exitRuleBlock: lambda-introducerattribute-specifier*lambda-declaratorcompound-statement|lambda-introducer'<'template-parameter-list'>'requires-clause?attribute-specifier*lambda-declaratorcompound-statement
  exitRuleSpec: lambda-expression:lambda-introducerattribute-specifier*lambda-declaratorcompound-statement|lambda-introducer'<'template-parameter-list'>'requires-clause?attribute-specifier*lambda-declaratorcompound-statement;

  enterRuleSpec: lambda-introducer:'['lambda-capture?']';
    enterRuleBlock: '['lambda-capture?']'
      enterRuleAltList: '['lambda-capture?']'
        enterLabeledAlt: '['lambda-capture?']'
          enterAlternative: '['lambda-capture?']'
            enterElement: '['
              => element -> [
              enterAtom: '['
                enterTerminal: '['
                exitTerminal: '['
              exitAtom: '['
            exitElement: '['
            enterElement: lambda-capture?
              => element -> [lambda-capture]
              enterAtom: lambda-capture
                enterRuleref: lambda-capture
                exitRuleref: lambda-capture
              exitAtom: lambda-capture
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: lambda-capture?
            enterElement: ']'
              => element -> ]
              enterAtom: ']'
                enterTerminal: ']'
                exitTerminal: ']'
              exitAtom: ']'
            exitElement: ']'
          exitAlternative: '['lambda-capture?']'
        => elements -> ['[', '[lambda-capture]', ']']
            => alternative -> [ [lambda-capture] ]
        exitLabeledAlt: '['lambda-capture?']'
      exitRuleAltList: '['lambda-capture?']'
    exitRuleBlock: '['lambda-capture?']'
  exitRuleSpec: lambda-introducer:'['lambda-capture?']';

  enterRuleSpec: lambda-declarator:lambda-specifier+noexcept-specifier?attribute-specifier*trailing-return-type?|noexcept-specifierattribute-specifier*trailing-return-type?|trailing-return-type?|'('parameter-declaration-clause')'lambda-specifier*noexcept-specifier?attribute-specifier*trailing-return-type?requires-clause?;
    enterRuleBlock: lambda-specifier+noexcept-specifier?attribute-specifier*trailing-return-type?|noexcept-specifierattribute-specifier*trailing-return-type?|trailing-return-type?|'('parameter-declaration-clause')'lambda-specifier*noexcept-specifier?attribute-specifier*trailing-return-type?requires-clause?
      enterRuleAltList: lambda-specifier+noexcept-specifier?attribute-specifier*trailing-return-type?|noexcept-specifierattribute-specifier*trailing-return-type?|trailing-return-type?|'('parameter-declaration-clause')'lambda-specifier*noexcept-specifier?attribute-specifier*trailing-return-type?requires-clause?
        enterLabeledAlt: lambda-specifier+noexcept-specifier?attribute-specifier*trailing-return-type?
          enterAlternative: lambda-specifier+noexcept-specifier?attribute-specifier*trailing-return-type?
            enterElement: lambda-specifier+
              => element -> {lambda-specifier}...
              enterAtom: lambda-specifier
                enterRuleref: lambda-specifier
                exitRuleref: lambda-specifier
              exitAtom: lambda-specifier
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: lambda-specifier+
            enterElement: noexcept-specifier?
              => element -> [noexcept-specifier]
              enterAtom: noexcept-specifier
                enterRuleref: noexcept-specifier
                exitRuleref: noexcept-specifier
              exitAtom: noexcept-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: noexcept-specifier?
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: trailing-return-type?
              => element -> [trailing-return-type]
              enterAtom: trailing-return-type
                enterRuleref: trailing-return-type
                exitRuleref: trailing-return-type
              exitAtom: trailing-return-type
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: trailing-return-type?
          exitAlternative: lambda-specifier+noexcept-specifier?attribute-specifier*trailing-return-type?
        => elements -> ['{lambda-specifier}...', '[noexcept-specifier]', '[attribute-specifier]...', '[trailing-return-type]']
            => alternative -> {lambda-specifier}... [noexcept-specifier] [attribute-specifier]... [trailing-return-type]
        exitLabeledAlt: lambda-specifier+noexcept-specifier?attribute-specifier*trailing-return-type?
        enterLabeledAlt: noexcept-specifierattribute-specifier*trailing-return-type?
          enterAlternative: noexcept-specifierattribute-specifier*trailing-return-type?
            enterElement: noexcept-specifier
              => element -> {noexcept-specifier}
              enterAtom: noexcept-specifier
                enterRuleref: noexcept-specifier
                exitRuleref: noexcept-specifier
              exitAtom: noexcept-specifier
            exitElement: noexcept-specifier
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: trailing-return-type?
              => element -> [trailing-return-type]
              enterAtom: trailing-return-type
                enterRuleref: trailing-return-type
                exitRuleref: trailing-return-type
              exitAtom: trailing-return-type
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: trailing-return-type?
          exitAlternative: noexcept-specifierattribute-specifier*trailing-return-type?
        => elements -> ['{noexcept-specifier}', '[attribute-specifier]...', '[trailing-return-type]']
            => alternative -> {noexcept-specifier} [attribute-specifier]... [trailing-return-type]
        exitLabeledAlt: noexcept-specifierattribute-specifier*trailing-return-type?
        enterLabeledAlt: trailing-return-type?
          enterAlternative: trailing-return-type?
            enterElement: trailing-return-type?
              => element -> [trailing-return-type]
              enterAtom: trailing-return-type
                enterRuleref: trailing-return-type
                exitRuleref: trailing-return-type
              exitAtom: trailing-return-type
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: trailing-return-type?
          exitAlternative: trailing-return-type?
        => elements -> ['[trailing-return-type]']
            => alternative -> [trailing-return-type]
        exitLabeledAlt: trailing-return-type?
        enterLabeledAlt: '('parameter-declaration-clause')'lambda-specifier*noexcept-specifier?attribute-specifier*trailing-return-type?requires-clause?
          enterAlternative: '('parameter-declaration-clause')'lambda-specifier*noexcept-specifier?attribute-specifier*trailing-return-type?requires-clause?
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: parameter-declaration-clause
              => element -> {parameter-declaration-clause}
              enterAtom: parameter-declaration-clause
                enterRuleref: parameter-declaration-clause
                exitRuleref: parameter-declaration-clause
              exitAtom: parameter-declaration-clause
            exitElement: parameter-declaration-clause
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
            enterElement: lambda-specifier*
              => element -> [lambda-specifier]...
              enterAtom: lambda-specifier
                enterRuleref: lambda-specifier
                exitRuleref: lambda-specifier
              exitAtom: lambda-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: lambda-specifier*
            enterElement: noexcept-specifier?
              => element -> [noexcept-specifier]
              enterAtom: noexcept-specifier
                enterRuleref: noexcept-specifier
                exitRuleref: noexcept-specifier
              exitAtom: noexcept-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: noexcept-specifier?
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: trailing-return-type?
              => element -> [trailing-return-type]
              enterAtom: trailing-return-type
                enterRuleref: trailing-return-type
                exitRuleref: trailing-return-type
              exitAtom: trailing-return-type
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: trailing-return-type?
            enterElement: requires-clause?
              => element -> [requires-clause]
              enterAtom: requires-clause
                enterRuleref: requires-clause
                exitRuleref: requires-clause
              exitAtom: requires-clause
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: requires-clause?
          exitAlternative: '('parameter-declaration-clause')'lambda-specifier*noexcept-specifier?attribute-specifier*trailing-return-type?requires-clause?
        => elements -> ['(', '{parameter-declaration-clause}', ')', '[lambda-specifier]...', '[noexcept-specifier]', '[attribute-specifier]...', '[trailing-return-type]', '[requires-clause]']
            => alternative -> ( {parameter-declaration-clause} ) [lambda-specifier]... [noexcept-specifier] [attribute-specifier]... [trailing-return-type] [requires-clause]
        exitLabeledAlt: '('parameter-declaration-clause')'lambda-specifier*noexcept-specifier?attribute-specifier*trailing-return-type?requires-clause?
      exitRuleAltList: lambda-specifier+noexcept-specifier?attribute-specifier*trailing-return-type?|noexcept-specifierattribute-specifier*trailing-return-type?|trailing-return-type?|'('parameter-declaration-clause')'lambda-specifier*noexcept-specifier?attribute-specifier*trailing-return-type?requires-clause?
    exitRuleBlock: lambda-specifier+noexcept-specifier?attribute-specifier*trailing-return-type?|noexcept-specifierattribute-specifier*trailing-return-type?|trailing-return-type?|'('parameter-declaration-clause')'lambda-specifier*noexcept-specifier?attribute-specifier*trailing-return-type?requires-clause?
  exitRuleSpec: lambda-declarator:lambda-specifier+noexcept-specifier?attribute-specifier*trailing-return-type?|noexcept-specifierattribute-specifier*trailing-return-type?|trailing-return-type?|'('parameter-declaration-clause')'lambda-specifier*noexcept-specifier?attribute-specifier*trailing-return-type?requires-clause?;

  enterRuleSpec: lambda-specifier:'consteval'|'constexpr'|'mutable'|'static';
    enterRuleBlock: 'consteval'|'constexpr'|'mutable'|'static'
      enterRuleAltList: 'consteval'|'constexpr'|'mutable'|'static'
        enterLabeledAlt: 'consteval'
          enterAlternative: 'consteval'
            enterElement: 'consteval'
              => element -> consteval
              enterAtom: 'consteval'
                enterTerminal: 'consteval'
                exitTerminal: 'consteval'
              exitAtom: 'consteval'
            exitElement: 'consteval'
          exitAlternative: 'consteval'
        => elements -> ['consteval']
            => alternative -> consteval
        exitLabeledAlt: 'consteval'
        enterLabeledAlt: 'constexpr'
          enterAlternative: 'constexpr'
            enterElement: 'constexpr'
              => element -> constexpr
              enterAtom: 'constexpr'
                enterTerminal: 'constexpr'
                exitTerminal: 'constexpr'
              exitAtom: 'constexpr'
            exitElement: 'constexpr'
          exitAlternative: 'constexpr'
        => elements -> ['constexpr']
            => alternative -> constexpr
        exitLabeledAlt: 'constexpr'
        enterLabeledAlt: 'mutable'
          enterAlternative: 'mutable'
            enterElement: 'mutable'
              => element -> mutable
              enterAtom: 'mutable'
                enterTerminal: 'mutable'
                exitTerminal: 'mutable'
              exitAtom: 'mutable'
            exitElement: 'mutable'
          exitAlternative: 'mutable'
        => elements -> ['mutable']
            => alternative -> mutable
        exitLabeledAlt: 'mutable'
        enterLabeledAlt: 'static'
          enterAlternative: 'static'
            enterElement: 'static'
              => element -> static
              enterAtom: 'static'
                enterTerminal: 'static'
                exitTerminal: 'static'
              exitAtom: 'static'
            exitElement: 'static'
          exitAlternative: 'static'
        => elements -> ['static']
            => alternative -> static
        exitLabeledAlt: 'static'
      exitRuleAltList: 'consteval'|'constexpr'|'mutable'|'static'
    exitRuleBlock: 'consteval'|'constexpr'|'mutable'|'static'
  exitRuleSpec: lambda-specifier:'consteval'|'constexpr'|'mutable'|'static';

  enterRuleSpec: lambda-capture:capture-default|capture-list|capture-default','capture-list;
    enterRuleBlock: capture-default|capture-list|capture-default','capture-list
      enterRuleAltList: capture-default|capture-list|capture-default','capture-list
        enterLabeledAlt: capture-default
          enterAlternative: capture-default
            enterElement: capture-default
              => element -> {capture-default}
              enterAtom: capture-default
                enterRuleref: capture-default
                exitRuleref: capture-default
              exitAtom: capture-default
            exitElement: capture-default
          exitAlternative: capture-default
        => elements -> ['{capture-default}']
            => alternative -> {capture-default}
        exitLabeledAlt: capture-default
        enterLabeledAlt: capture-list
          enterAlternative: capture-list
            enterElement: capture-list
              => element -> {capture-list}
              enterAtom: capture-list
                enterRuleref: capture-list
                exitRuleref: capture-list
              exitAtom: capture-list
            exitElement: capture-list
          exitAlternative: capture-list
        => elements -> ['{capture-list}']
            => alternative -> {capture-list}
        exitLabeledAlt: capture-list
        enterLabeledAlt: capture-default','capture-list
          enterAlternative: capture-default','capture-list
            enterElement: capture-default
              => element -> {capture-default}
              enterAtom: capture-default
                enterRuleref: capture-default
                exitRuleref: capture-default
              exitAtom: capture-default
            exitElement: capture-default
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: capture-list
              => element -> {capture-list}
              enterAtom: capture-list
                enterRuleref: capture-list
                exitRuleref: capture-list
              exitAtom: capture-list
            exitElement: capture-list
          exitAlternative: capture-default','capture-list
        => elements -> ['{capture-default}', ',', '{capture-list}']
            => alternative -> {capture-default} , {capture-list}
        exitLabeledAlt: capture-default','capture-list
      exitRuleAltList: capture-default|capture-list|capture-default','capture-list
    exitRuleBlock: capture-default|capture-list|capture-default','capture-list
  exitRuleSpec: lambda-capture:capture-default|capture-list|capture-default','capture-list;

  enterRuleSpec: capture-default:'&'|'=';
    enterRuleBlock: '&'|'='
      enterRuleAltList: '&'|'='
        enterLabeledAlt: '&'
          enterAlternative: '&'
            enterElement: '&'
              => element -> &
              enterAtom: '&'
                enterTerminal: '&'
                exitTerminal: '&'
              exitAtom: '&'
            exitElement: '&'
          exitAlternative: '&'
        => elements -> ['&']
            => alternative -> &
        exitLabeledAlt: '&'
        enterLabeledAlt: '='
          enterAlternative: '='
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
          exitAlternative: '='
        => elements -> ['=']
            => alternative -> =
        exitLabeledAlt: '='
      exitRuleAltList: '&'|'='
    exitRuleBlock: '&'|'='
  exitRuleSpec: capture-default:'&'|'=';

  enterRuleSpec: capture-list:capture|capture-list','capture;
    enterRuleBlock: capture|capture-list','capture
      enterRuleAltList: capture|capture-list','capture
        enterLabeledAlt: capture
          enterAlternative: capture
            enterElement: capture
              => element -> {capture}
              enterAtom: capture
                enterRuleref: capture
                exitRuleref: capture
              exitAtom: capture
            exitElement: capture
          exitAlternative: capture
        => elements -> ['{capture}']
            => alternative -> {capture}
        exitLabeledAlt: capture
        enterLabeledAlt: capture-list','capture
          enterAlternative: capture-list','capture
            enterElement: capture-list
              => element -> {capture-list}
              enterAtom: capture-list
                enterRuleref: capture-list
                exitRuleref: capture-list
              exitAtom: capture-list
            exitElement: capture-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: capture
              => element -> {capture}
              enterAtom: capture
                enterRuleref: capture
                exitRuleref: capture
              exitAtom: capture
            exitElement: capture
          exitAlternative: capture-list','capture
        => elements -> ['{capture-list}', ',', '{capture}']
            => alternative -> {capture-list} , {capture}
        exitLabeledAlt: capture-list','capture
      exitRuleAltList: capture|capture-list','capture
    exitRuleBlock: capture|capture-list','capture
  exitRuleSpec: capture-list:capture|capture-list','capture;

  enterRuleSpec: capture:simple-capture|init-capture;
    enterRuleBlock: simple-capture|init-capture
      enterRuleAltList: simple-capture|init-capture
        enterLabeledAlt: simple-capture
          enterAlternative: simple-capture
            enterElement: simple-capture
              => element -> {simple-capture}
              enterAtom: simple-capture
                enterRuleref: simple-capture
                exitRuleref: simple-capture
              exitAtom: simple-capture
            exitElement: simple-capture
          exitAlternative: simple-capture
        => elements -> ['{simple-capture}']
            => alternative -> {simple-capture}
        exitLabeledAlt: simple-capture
        enterLabeledAlt: init-capture
          enterAlternative: init-capture
            enterElement: init-capture
              => element -> {init-capture}
              enterAtom: init-capture
                enterRuleref: init-capture
                exitRuleref: init-capture
              exitAtom: init-capture
            exitElement: init-capture
          exitAlternative: init-capture
        => elements -> ['{init-capture}']
            => alternative -> {init-capture}
        exitLabeledAlt: init-capture
      exitRuleAltList: simple-capture|init-capture
    exitRuleBlock: simple-capture|init-capture
  exitRuleSpec: capture:simple-capture|init-capture;

  enterRuleSpec: simple-capture:identifierthree-dots?|'&'identifierthree-dots?|'this'|'*this';
    enterRuleBlock: identifierthree-dots?|'&'identifierthree-dots?|'this'|'*this'
      enterRuleAltList: identifierthree-dots?|'&'identifierthree-dots?|'this'|'*this'
        enterLabeledAlt: identifierthree-dots?
          enterAlternative: identifierthree-dots?
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
          exitAlternative: identifierthree-dots?
        => elements -> ['{identifier}', '[three-dots]']
            => alternative -> {identifier} [three-dots]
        exitLabeledAlt: identifierthree-dots?
        enterLabeledAlt: '&'identifierthree-dots?
          enterAlternative: '&'identifierthree-dots?
            enterElement: '&'
              => element -> &
              enterAtom: '&'
                enterTerminal: '&'
                exitTerminal: '&'
              exitAtom: '&'
            exitElement: '&'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
          exitAlternative: '&'identifierthree-dots?
        => elements -> ['&', '{identifier}', '[three-dots]']
            => alternative -> & {identifier} [three-dots]
        exitLabeledAlt: '&'identifierthree-dots?
        enterLabeledAlt: 'this'
          enterAlternative: 'this'
            enterElement: 'this'
              => element -> this
              enterAtom: 'this'
                enterTerminal: 'this'
                exitTerminal: 'this'
              exitAtom: 'this'
            exitElement: 'this'
          exitAlternative: 'this'
        => elements -> ['this']
            => alternative -> this
        exitLabeledAlt: 'this'
        enterLabeledAlt: '*this'
          enterAlternative: '*this'
            enterElement: '*this'
              => element -> *this
              enterAtom: '*this'
                enterTerminal: '*this'
                exitTerminal: '*this'
              exitAtom: '*this'
            exitElement: '*this'
          exitAlternative: '*this'
        => elements -> ['*this']
            => alternative -> *this
        exitLabeledAlt: '*this'
      exitRuleAltList: identifierthree-dots?|'&'identifierthree-dots?|'this'|'*this'
    exitRuleBlock: identifierthree-dots?|'&'identifierthree-dots?|'this'|'*this'
  exitRuleSpec: simple-capture:identifierthree-dots?|'&'identifierthree-dots?|'this'|'*this';

  enterRuleSpec: and-three-dots:'& ...';
    enterRuleBlock: '& ...'
      enterRuleAltList: '& ...'
        enterLabeledAlt: '& ...'
          enterAlternative: '& ...'
            enterElement: '& ...'
              => element -> & ...
              enterAtom: '& ...'
                enterTerminal: '& ...'
                exitTerminal: '& ...'
              exitAtom: '& ...'
            exitElement: '& ...'
          exitAlternative: '& ...'
        => elements -> ['& ...']
            => alternative -> & ...
        exitLabeledAlt: '& ...'
      exitRuleAltList: '& ...'
    exitRuleBlock: '& ...'
  exitRuleSpec: and-three-dots:'& ...';

  enterRuleSpec: init-capture:three-dots?identifierinitializer|and-three-dots?identifierinitializer;
    enterRuleBlock: three-dots?identifierinitializer|and-three-dots?identifierinitializer
      enterRuleAltList: three-dots?identifierinitializer|and-three-dots?identifierinitializer
        enterLabeledAlt: three-dots?identifierinitializer
          enterAlternative: three-dots?identifierinitializer
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: initializer
              => element -> {initializer}
              enterAtom: initializer
                enterRuleref: initializer
                exitRuleref: initializer
              exitAtom: initializer
            exitElement: initializer
          exitAlternative: three-dots?identifierinitializer
        => elements -> ['[three-dots]', '{identifier}', '{initializer}']
            => alternative -> [three-dots] {identifier} {initializer}
        exitLabeledAlt: three-dots?identifierinitializer
        enterLabeledAlt: and-three-dots?identifierinitializer
          enterAlternative: and-three-dots?identifierinitializer
            enterElement: and-three-dots?
              => element -> [and-three-dots]
              enterAtom: and-three-dots
                enterRuleref: and-three-dots
                exitRuleref: and-three-dots
              exitAtom: and-three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: and-three-dots?
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: initializer
              => element -> {initializer}
              enterAtom: initializer
                enterRuleref: initializer
                exitRuleref: initializer
              exitAtom: initializer
            exitElement: initializer
          exitAlternative: and-three-dots?identifierinitializer
        => elements -> ['[and-three-dots]', '{identifier}', '{initializer}']
            => alternative -> [and-three-dots] {identifier} {initializer}
        exitLabeledAlt: and-three-dots?identifierinitializer
      exitRuleAltList: three-dots?identifierinitializer|and-three-dots?identifierinitializer
    exitRuleBlock: three-dots?identifierinitializer|and-three-dots?identifierinitializer
  exitRuleSpec: init-capture:three-dots?identifierinitializer|and-three-dots?identifierinitializer;

  enterRuleSpec: fold-expression:'('cast-expressionfold-operator'...)'|'(...'fold-operatorcast-expression')'|'('cast-expressionfold-operator'...'fold-operatorcast-expression')';
    enterRuleBlock: '('cast-expressionfold-operator'...)'|'(...'fold-operatorcast-expression')'|'('cast-expressionfold-operator'...'fold-operatorcast-expression')'
      enterRuleAltList: '('cast-expressionfold-operator'...)'|'(...'fold-operatorcast-expression')'|'('cast-expressionfold-operator'...'fold-operatorcast-expression')'
        enterLabeledAlt: '('cast-expressionfold-operator'...)'
          enterAlternative: '('cast-expressionfold-operator'...)'
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
            enterElement: fold-operator
              => element -> {fold-operator}
              enterAtom: fold-operator
                enterRuleref: fold-operator
                exitRuleref: fold-operator
              exitAtom: fold-operator
            exitElement: fold-operator
            enterElement: '...)'
              => element -> ...)
              enterAtom: '...)'
                enterTerminal: '...)'
                exitTerminal: '...)'
              exitAtom: '...)'
            exitElement: '...)'
          exitAlternative: '('cast-expressionfold-operator'...)'
        => elements -> ['(', '{cast-expression}', '{fold-operator}', '...)']
            => alternative -> ( {cast-expression} {fold-operator} ...)
        exitLabeledAlt: '('cast-expressionfold-operator'...)'
        enterLabeledAlt: '(...'fold-operatorcast-expression')'
          enterAlternative: '(...'fold-operatorcast-expression')'
            enterElement: '(...'
              => element -> (...
              enterAtom: '(...'
                enterTerminal: '(...'
                exitTerminal: '(...'
              exitAtom: '(...'
            exitElement: '(...'
            enterElement: fold-operator
              => element -> {fold-operator}
              enterAtom: fold-operator
                enterRuleref: fold-operator
                exitRuleref: fold-operator
              exitAtom: fold-operator
            exitElement: fold-operator
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '(...'fold-operatorcast-expression')'
        => elements -> ['(...', '{fold-operator}', '{cast-expression}', ')']
            => alternative -> (... {fold-operator} {cast-expression} )
        exitLabeledAlt: '(...'fold-operatorcast-expression')'
        enterLabeledAlt: '('cast-expressionfold-operator'...'fold-operatorcast-expression')'
          enterAlternative: '('cast-expressionfold-operator'...'fold-operatorcast-expression')'
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
            enterElement: fold-operator
              => element -> {fold-operator}
              enterAtom: fold-operator
                enterRuleref: fold-operator
                exitRuleref: fold-operator
              exitAtom: fold-operator
            exitElement: fold-operator
            enterElement: '...'
              => element -> ...
              enterAtom: '...'
                enterTerminal: '...'
                exitTerminal: '...'
              exitAtom: '...'
            exitElement: '...'
            enterElement: fold-operator
              => element -> {fold-operator}
              enterAtom: fold-operator
                enterRuleref: fold-operator
                exitRuleref: fold-operator
              exitAtom: fold-operator
            exitElement: fold-operator
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '('cast-expressionfold-operator'...'fold-operatorcast-expression')'
        => elements -> ['(', '{cast-expression}', '{fold-operator}', '...', '{fold-operator}', '{cast-expression}', ')']
            => alternative -> ( {cast-expression} {fold-operator} ... {fold-operator} {cast-expression} )
        exitLabeledAlt: '('cast-expressionfold-operator'...'fold-operatorcast-expression')'
      exitRuleAltList: '('cast-expressionfold-operator'...)'|'(...'fold-operatorcast-expression')'|'('cast-expressionfold-operator'...'fold-operatorcast-expression')'
    exitRuleBlock: '('cast-expressionfold-operator'...)'|'(...'fold-operatorcast-expression')'|'('cast-expressionfold-operator'...'fold-operatorcast-expression')'
  exitRuleSpec: fold-expression:'('cast-expressionfold-operator'...)'|'(...'fold-operatorcast-expression')'|'('cast-expressionfold-operator'...'fold-operatorcast-expression')';

  enterRuleSpec: fold-operator:'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'<<'|'>>'|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'<<='|'>>='|'='|'=='|'!='|'<'|'>'|'<='|'>='|'&&'|'||'|','|'.*'|'->*';
    enterRuleBlock: '+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'<<'|'>>'|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'<<='|'>>='|'='|'=='|'!='|'<'|'>'|'<='|'>='|'&&'|'||'|','|'.*'|'->*'
      enterRuleAltList: '+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'<<'|'>>'|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'<<='|'>>='|'='|'=='|'!='|'<'|'>'|'<='|'>='|'&&'|'||'|','|'.*'|'->*'
        enterLabeledAlt: '+'
          enterAlternative: '+'
            enterElement: '+'
              => element -> +
              enterAtom: '+'
                enterTerminal: '+'
                exitTerminal: '+'
              exitAtom: '+'
            exitElement: '+'
          exitAlternative: '+'
        => elements -> ['+']
            => alternative -> +
        exitLabeledAlt: '+'
        enterLabeledAlt: '-'
          enterAlternative: '-'
            enterElement: '-'
              => element -> -
              enterAtom: '-'
                enterTerminal: '-'
                exitTerminal: '-'
              exitAtom: '-'
            exitElement: '-'
          exitAlternative: '-'
        => elements -> ['-']
            => alternative -> -
        exitLabeledAlt: '-'
        enterLabeledAlt: '*'
          enterAlternative: '*'
            enterElement: '*'
              => element -> *
              enterAtom: '*'
                enterTerminal: '*'
                exitTerminal: '*'
              exitAtom: '*'
            exitElement: '*'
          exitAlternative: '*'
        => elements -> ['*']
            => alternative -> *
        exitLabeledAlt: '*'
        enterLabeledAlt: '/'
          enterAlternative: '/'
            enterElement: '/'
              => element -> /
              enterAtom: '/'
                enterTerminal: '/'
                exitTerminal: '/'
              exitAtom: '/'
            exitElement: '/'
          exitAlternative: '/'
        => elements -> ['/']
            => alternative -> /
        exitLabeledAlt: '/'
        enterLabeledAlt: '%'
          enterAlternative: '%'
            enterElement: '%'
              => element -> %
              enterAtom: '%'
                enterTerminal: '%'
                exitTerminal: '%'
              exitAtom: '%'
            exitElement: '%'
          exitAlternative: '%'
        => elements -> ['%']
            => alternative -> %
        exitLabeledAlt: '%'
        enterLabeledAlt: '^'
          enterAlternative: '^'
            enterElement: '^'
              => element -> ^
              enterAtom: '^'
                enterTerminal: '^'
                exitTerminal: '^'
              exitAtom: '^'
            exitElement: '^'
          exitAlternative: '^'
        => elements -> ['^']
            => alternative -> ^
        exitLabeledAlt: '^'
        enterLabeledAlt: '&'
          enterAlternative: '&'
            enterElement: '&'
              => element -> &
              enterAtom: '&'
                enterTerminal: '&'
                exitTerminal: '&'
              exitAtom: '&'
            exitElement: '&'
          exitAlternative: '&'
        => elements -> ['&']
            => alternative -> &
        exitLabeledAlt: '&'
        enterLabeledAlt: '|'
          enterAlternative: '|'
            enterElement: '|'
              => element -> |
              enterAtom: '|'
                enterTerminal: '|'
                exitTerminal: '|'
              exitAtom: '|'
            exitElement: '|'
          exitAlternative: '|'
        => elements -> ['|']
            => alternative -> |
        exitLabeledAlt: '|'
        enterLabeledAlt: '<<'
          enterAlternative: '<<'
            enterElement: '<<'
              => element -> <<
              enterAtom: '<<'
                enterTerminal: '<<'
                exitTerminal: '<<'
              exitAtom: '<<'
            exitElement: '<<'
          exitAlternative: '<<'
        => elements -> ['<<']
            => alternative -> <<
        exitLabeledAlt: '<<'
        enterLabeledAlt: '>>'
          enterAlternative: '>>'
            enterElement: '>>'
              => element -> >>
              enterAtom: '>>'
                enterTerminal: '>>'
                exitTerminal: '>>'
              exitAtom: '>>'
            exitElement: '>>'
          exitAlternative: '>>'
        => elements -> ['>>']
            => alternative -> >>
        exitLabeledAlt: '>>'
        enterLabeledAlt: '+='
          enterAlternative: '+='
            enterElement: '+='
              => element -> +=
              enterAtom: '+='
                enterTerminal: '+='
                exitTerminal: '+='
              exitAtom: '+='
            exitElement: '+='
          exitAlternative: '+='
        => elements -> ['+=']
            => alternative -> +=
        exitLabeledAlt: '+='
        enterLabeledAlt: '-='
          enterAlternative: '-='
            enterElement: '-='
              => element -> -=
              enterAtom: '-='
                enterTerminal: '-='
                exitTerminal: '-='
              exitAtom: '-='
            exitElement: '-='
          exitAlternative: '-='
        => elements -> ['-=']
            => alternative -> -=
        exitLabeledAlt: '-='
        enterLabeledAlt: '*='
          enterAlternative: '*='
            enterElement: '*='
              => element -> *=
              enterAtom: '*='
                enterTerminal: '*='
                exitTerminal: '*='
              exitAtom: '*='
            exitElement: '*='
          exitAlternative: '*='
        => elements -> ['*=']
            => alternative -> *=
        exitLabeledAlt: '*='
        enterLabeledAlt: '/='
          enterAlternative: '/='
            enterElement: '/='
              => element -> /=
              enterAtom: '/='
                enterTerminal: '/='
                exitTerminal: '/='
              exitAtom: '/='
            exitElement: '/='
          exitAlternative: '/='
        => elements -> ['/=']
            => alternative -> /=
        exitLabeledAlt: '/='
        enterLabeledAlt: '%='
          enterAlternative: '%='
            enterElement: '%='
              => element -> %=
              enterAtom: '%='
                enterTerminal: '%='
                exitTerminal: '%='
              exitAtom: '%='
            exitElement: '%='
          exitAlternative: '%='
        => elements -> ['%=']
            => alternative -> %=
        exitLabeledAlt: '%='
        enterLabeledAlt: '^='
          enterAlternative: '^='
            enterElement: '^='
              => element -> ^=
              enterAtom: '^='
                enterTerminal: '^='
                exitTerminal: '^='
              exitAtom: '^='
            exitElement: '^='
          exitAlternative: '^='
        => elements -> ['^=']
            => alternative -> ^=
        exitLabeledAlt: '^='
        enterLabeledAlt: '&='
          enterAlternative: '&='
            enterElement: '&='
              => element -> &=
              enterAtom: '&='
                enterTerminal: '&='
                exitTerminal: '&='
              exitAtom: '&='
            exitElement: '&='
          exitAlternative: '&='
        => elements -> ['&=']
            => alternative -> &=
        exitLabeledAlt: '&='
        enterLabeledAlt: '|='
          enterAlternative: '|='
            enterElement: '|='
              => element -> |=
              enterAtom: '|='
                enterTerminal: '|='
                exitTerminal: '|='
              exitAtom: '|='
            exitElement: '|='
          exitAlternative: '|='
        => elements -> ['|=']
            => alternative -> |=
        exitLabeledAlt: '|='
        enterLabeledAlt: '<<='
          enterAlternative: '<<='
            enterElement: '<<='
              => element -> <<=
              enterAtom: '<<='
                enterTerminal: '<<='
                exitTerminal: '<<='
              exitAtom: '<<='
            exitElement: '<<='
          exitAlternative: '<<='
        => elements -> ['<<=']
            => alternative -> <<=
        exitLabeledAlt: '<<='
        enterLabeledAlt: '>>='
          enterAlternative: '>>='
            enterElement: '>>='
              => element -> >>=
              enterAtom: '>>='
                enterTerminal: '>>='
                exitTerminal: '>>='
              exitAtom: '>>='
            exitElement: '>>='
          exitAlternative: '>>='
        => elements -> ['>>=']
            => alternative -> >>=
        exitLabeledAlt: '>>='
        enterLabeledAlt: '='
          enterAlternative: '='
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
          exitAlternative: '='
        => elements -> ['=']
            => alternative -> =
        exitLabeledAlt: '='
        enterLabeledAlt: '=='
          enterAlternative: '=='
            enterElement: '=='
              => element -> ==
              enterAtom: '=='
                enterTerminal: '=='
                exitTerminal: '=='
              exitAtom: '=='
            exitElement: '=='
          exitAlternative: '=='
        => elements -> ['==']
            => alternative -> ==
        exitLabeledAlt: '=='
        enterLabeledAlt: '!='
          enterAlternative: '!='
            enterElement: '!='
              => element -> !=
              enterAtom: '!='
                enterTerminal: '!='
                exitTerminal: '!='
              exitAtom: '!='
            exitElement: '!='
          exitAlternative: '!='
        => elements -> ['!=']
            => alternative -> !=
        exitLabeledAlt: '!='
        enterLabeledAlt: '<'
          enterAlternative: '<'
            enterElement: '<'
              => element -> <
              enterAtom: '<'
                enterTerminal: '<'
                exitTerminal: '<'
              exitAtom: '<'
            exitElement: '<'
          exitAlternative: '<'
        => elements -> ['<']
            => alternative -> <
        exitLabeledAlt: '<'
        enterLabeledAlt: '>'
          enterAlternative: '>'
            enterElement: '>'
              => element -> >
              enterAtom: '>'
                enterTerminal: '>'
                exitTerminal: '>'
              exitAtom: '>'
            exitElement: '>'
          exitAlternative: '>'
        => elements -> ['>']
            => alternative -> >
        exitLabeledAlt: '>'
        enterLabeledAlt: '<='
          enterAlternative: '<='
            enterElement: '<='
              => element -> <=
              enterAtom: '<='
                enterTerminal: '<='
                exitTerminal: '<='
              exitAtom: '<='
            exitElement: '<='
          exitAlternative: '<='
        => elements -> ['<=']
            => alternative -> <=
        exitLabeledAlt: '<='
        enterLabeledAlt: '>='
          enterAlternative: '>='
            enterElement: '>='
              => element -> >=
              enterAtom: '>='
                enterTerminal: '>='
                exitTerminal: '>='
              exitAtom: '>='
            exitElement: '>='
          exitAlternative: '>='
        => elements -> ['>=']
            => alternative -> >=
        exitLabeledAlt: '>='
        enterLabeledAlt: '&&'
          enterAlternative: '&&'
            enterElement: '&&'
              => element -> &&
              enterAtom: '&&'
                enterTerminal: '&&'
                exitTerminal: '&&'
              exitAtom: '&&'
            exitElement: '&&'
          exitAlternative: '&&'
        => elements -> ['&&']
            => alternative -> &&
        exitLabeledAlt: '&&'
        enterLabeledAlt: '||'
          enterAlternative: '||'
            enterElement: '||'
              => element -> ||
              enterAtom: '||'
                enterTerminal: '||'
                exitTerminal: '||'
              exitAtom: '||'
            exitElement: '||'
          exitAlternative: '||'
        => elements -> ['||']
            => alternative -> ||
        exitLabeledAlt: '||'
        enterLabeledAlt: ','
          enterAlternative: ','
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
          exitAlternative: ','
        => elements -> [',']
            => alternative -> ,
        exitLabeledAlt: ','
        enterLabeledAlt: '.*'
          enterAlternative: '.*'
            enterElement: '.*'
              => element -> .*
              enterAtom: '.*'
                enterTerminal: '.*'
                exitTerminal: '.*'
              exitAtom: '.*'
            exitElement: '.*'
          exitAlternative: '.*'
        => elements -> ['.*']
            => alternative -> .*
        exitLabeledAlt: '.*'
        enterLabeledAlt: '->*'
          enterAlternative: '->*'
            enterElement: '->*'
              => element -> ->*
              enterAtom: '->*'
                enterTerminal: '->*'
                exitTerminal: '->*'
              exitAtom: '->*'
            exitElement: '->*'
          exitAlternative: '->*'
        => elements -> ['->*']
            => alternative -> ->*
        exitLabeledAlt: '->*'
      exitRuleAltList: '+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'<<'|'>>'|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'<<='|'>>='|'='|'=='|'!='|'<'|'>'|'<='|'>='|'&&'|'||'|','|'.*'|'->*'
    exitRuleBlock: '+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'<<'|'>>'|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'<<='|'>>='|'='|'=='|'!='|'<'|'>'|'<='|'>='|'&&'|'||'|','|'.*'|'->*'
  exitRuleSpec: fold-operator:'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'<<'|'>>'|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'<<='|'>>='|'='|'=='|'!='|'<'|'>'|'<='|'>='|'&&'|'||'|','|'.*'|'->*';

  enterRuleSpec: requires-expression:'requires'requirement-parameter-list?requirement-body;
    enterRuleBlock: 'requires'requirement-parameter-list?requirement-body
      enterRuleAltList: 'requires'requirement-parameter-list?requirement-body
        enterLabeledAlt: 'requires'requirement-parameter-list?requirement-body
          enterAlternative: 'requires'requirement-parameter-list?requirement-body
            enterElement: 'requires'
              => element -> requires
              enterAtom: 'requires'
                enterTerminal: 'requires'
                exitTerminal: 'requires'
              exitAtom: 'requires'
            exitElement: 'requires'
            enterElement: requirement-parameter-list?
              => element -> [requirement-parameter-list]
              enterAtom: requirement-parameter-list
                enterRuleref: requirement-parameter-list
                exitRuleref: requirement-parameter-list
              exitAtom: requirement-parameter-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: requirement-parameter-list?
            enterElement: requirement-body
              => element -> {requirement-body}
              enterAtom: requirement-body
                enterRuleref: requirement-body
                exitRuleref: requirement-body
              exitAtom: requirement-body
            exitElement: requirement-body
          exitAlternative: 'requires'requirement-parameter-list?requirement-body
        => elements -> ['requires', '[requirement-parameter-list]', '{requirement-body}']
            => alternative -> requires [requirement-parameter-list] {requirement-body}
        exitLabeledAlt: 'requires'requirement-parameter-list?requirement-body
      exitRuleAltList: 'requires'requirement-parameter-list?requirement-body
    exitRuleBlock: 'requires'requirement-parameter-list?requirement-body
  exitRuleSpec: requires-expression:'requires'requirement-parameter-list?requirement-body;

  enterRuleSpec: requirement-parameter-list:'('parameter-declaration-clause')';
    enterRuleBlock: '('parameter-declaration-clause')'
      enterRuleAltList: '('parameter-declaration-clause')'
        enterLabeledAlt: '('parameter-declaration-clause')'
          enterAlternative: '('parameter-declaration-clause')'
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: parameter-declaration-clause
              => element -> {parameter-declaration-clause}
              enterAtom: parameter-declaration-clause
                enterRuleref: parameter-declaration-clause
                exitRuleref: parameter-declaration-clause
              exitAtom: parameter-declaration-clause
            exitElement: parameter-declaration-clause
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '('parameter-declaration-clause')'
        => elements -> ['(', '{parameter-declaration-clause}', ')']
            => alternative -> ( {parameter-declaration-clause} )
        exitLabeledAlt: '('parameter-declaration-clause')'
      exitRuleAltList: '('parameter-declaration-clause')'
    exitRuleBlock: '('parameter-declaration-clause')'
  exitRuleSpec: requirement-parameter-list:'('parameter-declaration-clause')';

  enterRuleSpec: requirement-body:'{'requirement+'}';
    enterRuleBlock: '{'requirement+'}'
      enterRuleAltList: '{'requirement+'}'
        enterLabeledAlt: '{'requirement+'}'
          enterAlternative: '{'requirement+'}'
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
            enterElement: requirement+
              => element -> {requirement}...
              enterAtom: requirement
                enterRuleref: requirement
                exitRuleref: requirement
              exitAtom: requirement
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: requirement+
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: '{'requirement+'}'
        => elements -> ['{', '{requirement}...', '}']
            => alternative -> { {requirement}... }
        exitLabeledAlt: '{'requirement+'}'
      exitRuleAltList: '{'requirement+'}'
    exitRuleBlock: '{'requirement+'}'
  exitRuleSpec: requirement-body:'{'requirement+'}';

  enterRuleSpec: requirement:simple-requirement|type-requirement|compound-requirement|nested-requirement;
    enterRuleBlock: simple-requirement|type-requirement|compound-requirement|nested-requirement
      enterRuleAltList: simple-requirement|type-requirement|compound-requirement|nested-requirement
        enterLabeledAlt: simple-requirement
          enterAlternative: simple-requirement
            enterElement: simple-requirement
              => element -> {simple-requirement}
              enterAtom: simple-requirement
                enterRuleref: simple-requirement
                exitRuleref: simple-requirement
              exitAtom: simple-requirement
            exitElement: simple-requirement
          exitAlternative: simple-requirement
        => elements -> ['{simple-requirement}']
            => alternative -> {simple-requirement}
        exitLabeledAlt: simple-requirement
        enterLabeledAlt: type-requirement
          enterAlternative: type-requirement
            enterElement: type-requirement
              => element -> {type-requirement}
              enterAtom: type-requirement
                enterRuleref: type-requirement
                exitRuleref: type-requirement
              exitAtom: type-requirement
            exitElement: type-requirement
          exitAlternative: type-requirement
        => elements -> ['{type-requirement}']
            => alternative -> {type-requirement}
        exitLabeledAlt: type-requirement
        enterLabeledAlt: compound-requirement
          enterAlternative: compound-requirement
            enterElement: compound-requirement
              => element -> {compound-requirement}
              enterAtom: compound-requirement
                enterRuleref: compound-requirement
                exitRuleref: compound-requirement
              exitAtom: compound-requirement
            exitElement: compound-requirement
          exitAlternative: compound-requirement
        => elements -> ['{compound-requirement}']
            => alternative -> {compound-requirement}
        exitLabeledAlt: compound-requirement
        enterLabeledAlt: nested-requirement
          enterAlternative: nested-requirement
            enterElement: nested-requirement
              => element -> {nested-requirement}
              enterAtom: nested-requirement
                enterRuleref: nested-requirement
                exitRuleref: nested-requirement
              exitAtom: nested-requirement
            exitElement: nested-requirement
          exitAlternative: nested-requirement
        => elements -> ['{nested-requirement}']
            => alternative -> {nested-requirement}
        exitLabeledAlt: nested-requirement
      exitRuleAltList: simple-requirement|type-requirement|compound-requirement|nested-requirement
    exitRuleBlock: simple-requirement|type-requirement|compound-requirement|nested-requirement
  exitRuleSpec: requirement:simple-requirement|type-requirement|compound-requirement|nested-requirement;

  enterRuleSpec: simple-requirement:expression';';
    enterRuleBlock: expression';'
      enterRuleAltList: expression';'
        enterLabeledAlt: expression';'
          enterAlternative: expression';'
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: expression';'
        => elements -> ['{expression}', ';']
            => alternative -> {expression} ;
        exitLabeledAlt: expression';'
      exitRuleAltList: expression';'
    exitRuleBlock: expression';'
  exitRuleSpec: simple-requirement:expression';';

  enterRuleSpec: type-requirement:'typename'nested-name-specifier?type-name';';
    enterRuleBlock: 'typename'nested-name-specifier?type-name';'
      enterRuleAltList: 'typename'nested-name-specifier?type-name';'
        enterLabeledAlt: 'typename'nested-name-specifier?type-name';'
          enterAlternative: 'typename'nested-name-specifier?type-name';'
            enterElement: 'typename'
              => element -> typename
              enterAtom: 'typename'
                enterTerminal: 'typename'
                exitTerminal: 'typename'
              exitAtom: 'typename'
            exitElement: 'typename'
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: type-name
              => element -> {type-name}
              enterAtom: type-name
                enterRuleref: type-name
                exitRuleref: type-name
              exitAtom: type-name
            exitElement: type-name
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: 'typename'nested-name-specifier?type-name';'
        => elements -> ['typename', '[nested-name-specifier]', '{type-name}', ';']
            => alternative -> typename [nested-name-specifier] {type-name} ;
        exitLabeledAlt: 'typename'nested-name-specifier?type-name';'
      exitRuleAltList: 'typename'nested-name-specifier?type-name';'
    exitRuleBlock: 'typename'nested-name-specifier?type-name';'
  exitRuleSpec: type-requirement:'typename'nested-name-specifier?type-name';';

  enterRuleSpec: compound-requirement:'{'expression'}'noexcept?return-type-requirement?';';
    enterRuleBlock: '{'expression'}'noexcept?return-type-requirement?';'
      enterRuleAltList: '{'expression'}'noexcept?return-type-requirement?';'
        enterLabeledAlt: '{'expression'}'noexcept?return-type-requirement?';'
          enterAlternative: '{'expression'}'noexcept?return-type-requirement?';'
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
            enterElement: noexcept?
              => element -> [noexcept]
              enterAtom: noexcept
                enterRuleref: noexcept
                exitRuleref: noexcept
              exitAtom: noexcept
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: noexcept?
            enterElement: return-type-requirement?
              => element -> [return-type-requirement]
              enterAtom: return-type-requirement
                enterRuleref: return-type-requirement
                exitRuleref: return-type-requirement
              exitAtom: return-type-requirement
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: return-type-requirement?
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: '{'expression'}'noexcept?return-type-requirement?';'
        => elements -> ['{', '{expression}', '}', '[noexcept]', '[return-type-requirement]', ';']
            => alternative -> { {expression} } [noexcept] [return-type-requirement] ;
        exitLabeledAlt: '{'expression'}'noexcept?return-type-requirement?';'
      exitRuleAltList: '{'expression'}'noexcept?return-type-requirement?';'
    exitRuleBlock: '{'expression'}'noexcept?return-type-requirement?';'
  exitRuleSpec: compound-requirement:'{'expression'}'noexcept?return-type-requirement?';';

  enterRuleSpec: return-type-requirement:'->'type-constraint;
    enterRuleBlock: '->'type-constraint
      enterRuleAltList: '->'type-constraint
        enterLabeledAlt: '->'type-constraint
          enterAlternative: '->'type-constraint
            enterElement: '->'
              => element -> ->
              enterAtom: '->'
                enterTerminal: '->'
                exitTerminal: '->'
              exitAtom: '->'
            exitElement: '->'
            enterElement: type-constraint
              => element -> {type-constraint}
              enterAtom: type-constraint
                enterRuleref: type-constraint
                exitRuleref: type-constraint
              exitAtom: type-constraint
            exitElement: type-constraint
          exitAlternative: '->'type-constraint
        => elements -> ['->', '{type-constraint}']
            => alternative -> -> {type-constraint}
        exitLabeledAlt: '->'type-constraint
      exitRuleAltList: '->'type-constraint
    exitRuleBlock: '->'type-constraint
  exitRuleSpec: return-type-requirement:'->'type-constraint;

  enterRuleSpec: nested-requirement:'requires'constraint-expression';';
    enterRuleBlock: 'requires'constraint-expression';'
      enterRuleAltList: 'requires'constraint-expression';'
        enterLabeledAlt: 'requires'constraint-expression';'
          enterAlternative: 'requires'constraint-expression';'
            enterElement: 'requires'
              => element -> requires
              enterAtom: 'requires'
                enterTerminal: 'requires'
                exitTerminal: 'requires'
              exitAtom: 'requires'
            exitElement: 'requires'
            enterElement: constraint-expression
              => element -> {constraint-expression}
              enterAtom: constraint-expression
                enterRuleref: constraint-expression
                exitRuleref: constraint-expression
              exitAtom: constraint-expression
            exitElement: constraint-expression
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: 'requires'constraint-expression';'
        => elements -> ['requires', '{constraint-expression}', ';']
            => alternative -> requires {constraint-expression} ;
        exitLabeledAlt: 'requires'constraint-expression';'
      exitRuleAltList: 'requires'constraint-expression';'
    exitRuleBlock: 'requires'constraint-expression';'
  exitRuleSpec: nested-requirement:'requires'constraint-expression';';

  enterRuleSpec: dot-template:'.template';
    enterRuleBlock: '.template'
      enterRuleAltList: '.template'
        enterLabeledAlt: '.template'
          enterAlternative: '.template'
            enterElement: '.template'
              => element -> .template
              enterAtom: '.template'
                enterTerminal: '.template'
                exitTerminal: '.template'
              exitAtom: '.template'
            exitElement: '.template'
          exitAlternative: '.template'
        => elements -> ['.template']
            => alternative -> .template
        exitLabeledAlt: '.template'
      exitRuleAltList: '.template'
    exitRuleBlock: '.template'
  exitRuleSpec: dot-template:'.template';

  enterRuleSpec: arrow-template:'->template';
    enterRuleBlock: '->template'
      enterRuleAltList: '->template'
        enterLabeledAlt: '->template'
          enterAlternative: '->template'
            enterElement: '->template'
              => element -> ->template
              enterAtom: '->template'
                enterTerminal: '->template'
                exitTerminal: '->template'
              exitAtom: '->template'
            exitElement: '->template'
          exitAlternative: '->template'
        => elements -> ['->template']
            => alternative -> ->template
        exitLabeledAlt: '->template'
      exitRuleAltList: '->template'
    exitRuleBlock: '->template'
  exitRuleSpec: arrow-template:'->template';

  enterRuleSpec: postfix-expression:primary-expression|postfix-expression'['expression-list?']'|postfix-expression'('expression-list?')'|simple-type-specifier'('expression-list?')'|typename-specifier'('expression-list?')'|simple-type-specifierbraced-init-list|typename-specifierbraced-init-list|postfix-expressiondot-template?id-expression|postfix-expressionarrow-template?id-expression|postfix-expression'++'|postfix-expression'--'|'dynamic-cast<'type-id'>('expression')'|'static-cast<'type-id'>('expression')'|'reinterpret-cast<'type-id'>('expression')'|'const-cast<'type-id'>('expression')'|'typeid('expression')'|'typeid('type-id')';
    enterRuleBlock: primary-expression|postfix-expression'['expression-list?']'|postfix-expression'('expression-list?')'|simple-type-specifier'('expression-list?')'|typename-specifier'('expression-list?')'|simple-type-specifierbraced-init-list|typename-specifierbraced-init-list|postfix-expressiondot-template?id-expression|postfix-expressionarrow-template?id-expression|postfix-expression'++'|postfix-expression'--'|'dynamic-cast<'type-id'>('expression')'|'static-cast<'type-id'>('expression')'|'reinterpret-cast<'type-id'>('expression')'|'const-cast<'type-id'>('expression')'|'typeid('expression')'|'typeid('type-id')'
      enterRuleAltList: primary-expression|postfix-expression'['expression-list?']'|postfix-expression'('expression-list?')'|simple-type-specifier'('expression-list?')'|typename-specifier'('expression-list?')'|simple-type-specifierbraced-init-list|typename-specifierbraced-init-list|postfix-expressiondot-template?id-expression|postfix-expressionarrow-template?id-expression|postfix-expression'++'|postfix-expression'--'|'dynamic-cast<'type-id'>('expression')'|'static-cast<'type-id'>('expression')'|'reinterpret-cast<'type-id'>('expression')'|'const-cast<'type-id'>('expression')'|'typeid('expression')'|'typeid('type-id')'
        enterLabeledAlt: primary-expression
          enterAlternative: primary-expression
            enterElement: primary-expression
              => element -> {primary-expression}
              enterAtom: primary-expression
                enterRuleref: primary-expression
                exitRuleref: primary-expression
              exitAtom: primary-expression
            exitElement: primary-expression
          exitAlternative: primary-expression
        => elements -> ['{primary-expression}']
            => alternative -> {primary-expression}
        exitLabeledAlt: primary-expression
        enterLabeledAlt: postfix-expression'['expression-list?']'
          enterAlternative: postfix-expression'['expression-list?']'
            enterElement: postfix-expression
              => element -> {postfix-expression}
              enterAtom: postfix-expression
                enterRuleref: postfix-expression
                exitRuleref: postfix-expression
              exitAtom: postfix-expression
            exitElement: postfix-expression
            enterElement: '['
              => element -> [
              enterAtom: '['
                enterTerminal: '['
                exitTerminal: '['
              exitAtom: '['
            exitElement: '['
            enterElement: expression-list?
              => element -> [expression-list]
              enterAtom: expression-list
                enterRuleref: expression-list
                exitRuleref: expression-list
              exitAtom: expression-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: expression-list?
            enterElement: ']'
              => element -> ]
              enterAtom: ']'
                enterTerminal: ']'
                exitTerminal: ']'
              exitAtom: ']'
            exitElement: ']'
          exitAlternative: postfix-expression'['expression-list?']'
        => elements -> ['{postfix-expression}', '[', '[expression-list]', ']']
            => alternative -> {postfix-expression} [ [expression-list] ]
        exitLabeledAlt: postfix-expression'['expression-list?']'
        enterLabeledAlt: postfix-expression'('expression-list?')'
          enterAlternative: postfix-expression'('expression-list?')'
            enterElement: postfix-expression
              => element -> {postfix-expression}
              enterAtom: postfix-expression
                enterRuleref: postfix-expression
                exitRuleref: postfix-expression
              exitAtom: postfix-expression
            exitElement: postfix-expression
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: expression-list?
              => element -> [expression-list]
              enterAtom: expression-list
                enterRuleref: expression-list
                exitRuleref: expression-list
              exitAtom: expression-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: expression-list?
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: postfix-expression'('expression-list?')'
        => elements -> ['{postfix-expression}', '(', '[expression-list]', ')']
            => alternative -> {postfix-expression} ( [expression-list] )
        exitLabeledAlt: postfix-expression'('expression-list?')'
        enterLabeledAlt: simple-type-specifier'('expression-list?')'
          enterAlternative: simple-type-specifier'('expression-list?')'
            enterElement: simple-type-specifier
              => element -> {simple-type-specifier}
              enterAtom: simple-type-specifier
                enterRuleref: simple-type-specifier
                exitRuleref: simple-type-specifier
              exitAtom: simple-type-specifier
            exitElement: simple-type-specifier
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: expression-list?
              => element -> [expression-list]
              enterAtom: expression-list
                enterRuleref: expression-list
                exitRuleref: expression-list
              exitAtom: expression-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: expression-list?
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: simple-type-specifier'('expression-list?')'
        => elements -> ['{simple-type-specifier}', '(', '[expression-list]', ')']
            => alternative -> {simple-type-specifier} ( [expression-list] )
        exitLabeledAlt: simple-type-specifier'('expression-list?')'
        enterLabeledAlt: typename-specifier'('expression-list?')'
          enterAlternative: typename-specifier'('expression-list?')'
            enterElement: typename-specifier
              => element -> {typename-specifier}
              enterAtom: typename-specifier
                enterRuleref: typename-specifier
                exitRuleref: typename-specifier
              exitAtom: typename-specifier
            exitElement: typename-specifier
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: expression-list?
              => element -> [expression-list]
              enterAtom: expression-list
                enterRuleref: expression-list
                exitRuleref: expression-list
              exitAtom: expression-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: expression-list?
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: typename-specifier'('expression-list?')'
        => elements -> ['{typename-specifier}', '(', '[expression-list]', ')']
            => alternative -> {typename-specifier} ( [expression-list] )
        exitLabeledAlt: typename-specifier'('expression-list?')'
        enterLabeledAlt: simple-type-specifierbraced-init-list
          enterAlternative: simple-type-specifierbraced-init-list
            enterElement: simple-type-specifier
              => element -> {simple-type-specifier}
              enterAtom: simple-type-specifier
                enterRuleref: simple-type-specifier
                exitRuleref: simple-type-specifier
              exitAtom: simple-type-specifier
            exitElement: simple-type-specifier
            enterElement: braced-init-list
              => element -> {braced-init-list}
              enterAtom: braced-init-list
                enterRuleref: braced-init-list
                exitRuleref: braced-init-list
              exitAtom: braced-init-list
            exitElement: braced-init-list
          exitAlternative: simple-type-specifierbraced-init-list
        => elements -> ['{simple-type-specifier}', '{braced-init-list}']
            => alternative -> {simple-type-specifier} {braced-init-list}
        exitLabeledAlt: simple-type-specifierbraced-init-list
        enterLabeledAlt: typename-specifierbraced-init-list
          enterAlternative: typename-specifierbraced-init-list
            enterElement: typename-specifier
              => element -> {typename-specifier}
              enterAtom: typename-specifier
                enterRuleref: typename-specifier
                exitRuleref: typename-specifier
              exitAtom: typename-specifier
            exitElement: typename-specifier
            enterElement: braced-init-list
              => element -> {braced-init-list}
              enterAtom: braced-init-list
                enterRuleref: braced-init-list
                exitRuleref: braced-init-list
              exitAtom: braced-init-list
            exitElement: braced-init-list
          exitAlternative: typename-specifierbraced-init-list
        => elements -> ['{typename-specifier}', '{braced-init-list}']
            => alternative -> {typename-specifier} {braced-init-list}
        exitLabeledAlt: typename-specifierbraced-init-list
        enterLabeledAlt: postfix-expressiondot-template?id-expression
          enterAlternative: postfix-expressiondot-template?id-expression
            enterElement: postfix-expression
              => element -> {postfix-expression}
              enterAtom: postfix-expression
                enterRuleref: postfix-expression
                exitRuleref: postfix-expression
              exitAtom: postfix-expression
            exitElement: postfix-expression
            enterElement: dot-template?
              => element -> [dot-template]
              enterAtom: dot-template
                enterRuleref: dot-template
                exitRuleref: dot-template
              exitAtom: dot-template
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: dot-template?
            enterElement: id-expression
              => element -> {id-expression}
              enterAtom: id-expression
                enterRuleref: id-expression
                exitRuleref: id-expression
              exitAtom: id-expression
            exitElement: id-expression
          exitAlternative: postfix-expressiondot-template?id-expression
        => elements -> ['{postfix-expression}', '[dot-template]', '{id-expression}']
            => alternative -> {postfix-expression} [dot-template] {id-expression}
        exitLabeledAlt: postfix-expressiondot-template?id-expression
        enterLabeledAlt: postfix-expressionarrow-template?id-expression
          enterAlternative: postfix-expressionarrow-template?id-expression
            enterElement: postfix-expression
              => element -> {postfix-expression}
              enterAtom: postfix-expression
                enterRuleref: postfix-expression
                exitRuleref: postfix-expression
              exitAtom: postfix-expression
            exitElement: postfix-expression
            enterElement: arrow-template?
              => element -> [arrow-template]
              enterAtom: arrow-template
                enterRuleref: arrow-template
                exitRuleref: arrow-template
              exitAtom: arrow-template
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: arrow-template?
            enterElement: id-expression
              => element -> {id-expression}
              enterAtom: id-expression
                enterRuleref: id-expression
                exitRuleref: id-expression
              exitAtom: id-expression
            exitElement: id-expression
          exitAlternative: postfix-expressionarrow-template?id-expression
        => elements -> ['{postfix-expression}', '[arrow-template]', '{id-expression}']
            => alternative -> {postfix-expression} [arrow-template] {id-expression}
        exitLabeledAlt: postfix-expressionarrow-template?id-expression
        enterLabeledAlt: postfix-expression'++'
          enterAlternative: postfix-expression'++'
            enterElement: postfix-expression
              => element -> {postfix-expression}
              enterAtom: postfix-expression
                enterRuleref: postfix-expression
                exitRuleref: postfix-expression
              exitAtom: postfix-expression
            exitElement: postfix-expression
            enterElement: '++'
              => element -> ++
              enterAtom: '++'
                enterTerminal: '++'
                exitTerminal: '++'
              exitAtom: '++'
            exitElement: '++'
          exitAlternative: postfix-expression'++'
        => elements -> ['{postfix-expression}', '++']
            => alternative -> {postfix-expression} ++
        exitLabeledAlt: postfix-expression'++'
        enterLabeledAlt: postfix-expression'--'
          enterAlternative: postfix-expression'--'
            enterElement: postfix-expression
              => element -> {postfix-expression}
              enterAtom: postfix-expression
                enterRuleref: postfix-expression
                exitRuleref: postfix-expression
              exitAtom: postfix-expression
            exitElement: postfix-expression
            enterElement: '--'
              => element -> --
              enterAtom: '--'
                enterTerminal: '--'
                exitTerminal: '--'
              exitAtom: '--'
            exitElement: '--'
          exitAlternative: postfix-expression'--'
        => elements -> ['{postfix-expression}', '--']
            => alternative -> {postfix-expression} --
        exitLabeledAlt: postfix-expression'--'
        enterLabeledAlt: 'dynamic-cast<'type-id'>('expression')'
          enterAlternative: 'dynamic-cast<'type-id'>('expression')'
            enterElement: 'dynamic-cast<'
              => element -> dynamic-cast<
              enterAtom: 'dynamic-cast<'
                enterTerminal: 'dynamic-cast<'
                exitTerminal: 'dynamic-cast<'
              exitAtom: 'dynamic-cast<'
            exitElement: 'dynamic-cast<'
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
            enterElement: '>('
              => element -> >(
              enterAtom: '>('
                enterTerminal: '>('
                exitTerminal: '>('
              exitAtom: '>('
            exitElement: '>('
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'dynamic-cast<'type-id'>('expression')'
        => elements -> ['dynamic-cast<', '{type-id}', '>(', '{expression}', ')']
            => alternative -> dynamic-cast< {type-id} >( {expression} )
        exitLabeledAlt: 'dynamic-cast<'type-id'>('expression')'
        enterLabeledAlt: 'static-cast<'type-id'>('expression')'
          enterAlternative: 'static-cast<'type-id'>('expression')'
            enterElement: 'static-cast<'
              => element -> static-cast<
              enterAtom: 'static-cast<'
                enterTerminal: 'static-cast<'
                exitTerminal: 'static-cast<'
              exitAtom: 'static-cast<'
            exitElement: 'static-cast<'
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
            enterElement: '>('
              => element -> >(
              enterAtom: '>('
                enterTerminal: '>('
                exitTerminal: '>('
              exitAtom: '>('
            exitElement: '>('
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'static-cast<'type-id'>('expression')'
        => elements -> ['static-cast<', '{type-id}', '>(', '{expression}', ')']
            => alternative -> static-cast< {type-id} >( {expression} )
        exitLabeledAlt: 'static-cast<'type-id'>('expression')'
        enterLabeledAlt: 'reinterpret-cast<'type-id'>('expression')'
          enterAlternative: 'reinterpret-cast<'type-id'>('expression')'
            enterElement: 'reinterpret-cast<'
              => element -> reinterpret-cast<
              enterAtom: 'reinterpret-cast<'
                enterTerminal: 'reinterpret-cast<'
                exitTerminal: 'reinterpret-cast<'
              exitAtom: 'reinterpret-cast<'
            exitElement: 'reinterpret-cast<'
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
            enterElement: '>('
              => element -> >(
              enterAtom: '>('
                enterTerminal: '>('
                exitTerminal: '>('
              exitAtom: '>('
            exitElement: '>('
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'reinterpret-cast<'type-id'>('expression')'
        => elements -> ['reinterpret-cast<', '{type-id}', '>(', '{expression}', ')']
            => alternative -> reinterpret-cast< {type-id} >( {expression} )
        exitLabeledAlt: 'reinterpret-cast<'type-id'>('expression')'
        enterLabeledAlt: 'const-cast<'type-id'>('expression')'
          enterAlternative: 'const-cast<'type-id'>('expression')'
            enterElement: 'const-cast<'
              => element -> const-cast<
              enterAtom: 'const-cast<'
                enterTerminal: 'const-cast<'
                exitTerminal: 'const-cast<'
              exitAtom: 'const-cast<'
            exitElement: 'const-cast<'
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
            enterElement: '>('
              => element -> >(
              enterAtom: '>('
                enterTerminal: '>('
                exitTerminal: '>('
              exitAtom: '>('
            exitElement: '>('
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'const-cast<'type-id'>('expression')'
        => elements -> ['const-cast<', '{type-id}', '>(', '{expression}', ')']
            => alternative -> const-cast< {type-id} >( {expression} )
        exitLabeledAlt: 'const-cast<'type-id'>('expression')'
        enterLabeledAlt: 'typeid('expression')'
          enterAlternative: 'typeid('expression')'
            enterElement: 'typeid('
              => element -> typeid(
              enterAtom: 'typeid('
                enterTerminal: 'typeid('
                exitTerminal: 'typeid('
              exitAtom: 'typeid('
            exitElement: 'typeid('
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'typeid('expression')'
        => elements -> ['typeid(', '{expression}', ')']
            => alternative -> typeid( {expression} )
        exitLabeledAlt: 'typeid('expression')'
        enterLabeledAlt: 'typeid('type-id')'
          enterAlternative: 'typeid('type-id')'
            enterElement: 'typeid('
              => element -> typeid(
              enterAtom: 'typeid('
                enterTerminal: 'typeid('
                exitTerminal: 'typeid('
              exitAtom: 'typeid('
            exitElement: 'typeid('
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'typeid('type-id')'
        => elements -> ['typeid(', '{type-id}', ')']
            => alternative -> typeid( {type-id} )
        exitLabeledAlt: 'typeid('type-id')'
      exitRuleAltList: primary-expression|postfix-expression'['expression-list?']'|postfix-expression'('expression-list?')'|simple-type-specifier'('expression-list?')'|typename-specifier'('expression-list?')'|simple-type-specifierbraced-init-list|typename-specifierbraced-init-list|postfix-expressiondot-template?id-expression|postfix-expressionarrow-template?id-expression|postfix-expression'++'|postfix-expression'--'|'dynamic-cast<'type-id'>('expression')'|'static-cast<'type-id'>('expression')'|'reinterpret-cast<'type-id'>('expression')'|'const-cast<'type-id'>('expression')'|'typeid('expression')'|'typeid('type-id')'
    exitRuleBlock: primary-expression|postfix-expression'['expression-list?']'|postfix-expression'('expression-list?')'|simple-type-specifier'('expression-list?')'|typename-specifier'('expression-list?')'|simple-type-specifierbraced-init-list|typename-specifierbraced-init-list|postfix-expressiondot-template?id-expression|postfix-expressionarrow-template?id-expression|postfix-expression'++'|postfix-expression'--'|'dynamic-cast<'type-id'>('expression')'|'static-cast<'type-id'>('expression')'|'reinterpret-cast<'type-id'>('expression')'|'const-cast<'type-id'>('expression')'|'typeid('expression')'|'typeid('type-id')'
  exitRuleSpec: postfix-expression:primary-expression|postfix-expression'['expression-list?']'|postfix-expression'('expression-list?')'|simple-type-specifier'('expression-list?')'|typename-specifier'('expression-list?')'|simple-type-specifierbraced-init-list|typename-specifierbraced-init-list|postfix-expressiondot-template?id-expression|postfix-expressionarrow-template?id-expression|postfix-expression'++'|postfix-expression'--'|'dynamic-cast<'type-id'>('expression')'|'static-cast<'type-id'>('expression')'|'reinterpret-cast<'type-id'>('expression')'|'const-cast<'type-id'>('expression')'|'typeid('expression')'|'typeid('type-id')';

  enterRuleSpec: expression-list:initializer-list;
    enterRuleBlock: initializer-list
      enterRuleAltList: initializer-list
        enterLabeledAlt: initializer-list
          enterAlternative: initializer-list
            enterElement: initializer-list
              => element -> {initializer-list}
              enterAtom: initializer-list
                enterRuleref: initializer-list
                exitRuleref: initializer-list
              exitAtom: initializer-list
            exitElement: initializer-list
          exitAlternative: initializer-list
        => elements -> ['{initializer-list}']
            => alternative -> {initializer-list}
        exitLabeledAlt: initializer-list
      exitRuleAltList: initializer-list
    exitRuleBlock: initializer-list
  exitRuleSpec: expression-list:initializer-list;

  enterRuleSpec: unary-expression:postfix-expression|unary-operatorcast-expression|'++'cast-expression|'--'cast-expression|await-expression|'sizeof'unary-expression|'sizeof('type-id')'|'sizeof...('identifier')'|'alignof('type-id')'|noexcept-expression|new-expression|delete-expression;
    enterRuleBlock: postfix-expression|unary-operatorcast-expression|'++'cast-expression|'--'cast-expression|await-expression|'sizeof'unary-expression|'sizeof('type-id')'|'sizeof...('identifier')'|'alignof('type-id')'|noexcept-expression|new-expression|delete-expression
      enterRuleAltList: postfix-expression|unary-operatorcast-expression|'++'cast-expression|'--'cast-expression|await-expression|'sizeof'unary-expression|'sizeof('type-id')'|'sizeof...('identifier')'|'alignof('type-id')'|noexcept-expression|new-expression|delete-expression
        enterLabeledAlt: postfix-expression
          enterAlternative: postfix-expression
            enterElement: postfix-expression
              => element -> {postfix-expression}
              enterAtom: postfix-expression
                enterRuleref: postfix-expression
                exitRuleref: postfix-expression
              exitAtom: postfix-expression
            exitElement: postfix-expression
          exitAlternative: postfix-expression
        => elements -> ['{postfix-expression}']
            => alternative -> {postfix-expression}
        exitLabeledAlt: postfix-expression
        enterLabeledAlt: unary-operatorcast-expression
          enterAlternative: unary-operatorcast-expression
            enterElement: unary-operator
              => element -> {unary-operator}
              enterAtom: unary-operator
                enterRuleref: unary-operator
                exitRuleref: unary-operator
              exitAtom: unary-operator
            exitElement: unary-operator
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
          exitAlternative: unary-operatorcast-expression
        => elements -> ['{unary-operator}', '{cast-expression}']
            => alternative -> {unary-operator} {cast-expression}
        exitLabeledAlt: unary-operatorcast-expression
        enterLabeledAlt: '++'cast-expression
          enterAlternative: '++'cast-expression
            enterElement: '++'
              => element -> ++
              enterAtom: '++'
                enterTerminal: '++'
                exitTerminal: '++'
              exitAtom: '++'
            exitElement: '++'
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
          exitAlternative: '++'cast-expression
        => elements -> ['++', '{cast-expression}']
            => alternative -> ++ {cast-expression}
        exitLabeledAlt: '++'cast-expression
        enterLabeledAlt: '--'cast-expression
          enterAlternative: '--'cast-expression
            enterElement: '--'
              => element -> --
              enterAtom: '--'
                enterTerminal: '--'
                exitTerminal: '--'
              exitAtom: '--'
            exitElement: '--'
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
          exitAlternative: '--'cast-expression
        => elements -> ['--', '{cast-expression}']
            => alternative -> -- {cast-expression}
        exitLabeledAlt: '--'cast-expression
        enterLabeledAlt: await-expression
          enterAlternative: await-expression
            enterElement: await-expression
              => element -> {await-expression}
              enterAtom: await-expression
                enterRuleref: await-expression
                exitRuleref: await-expression
              exitAtom: await-expression
            exitElement: await-expression
          exitAlternative: await-expression
        => elements -> ['{await-expression}']
            => alternative -> {await-expression}
        exitLabeledAlt: await-expression
        enterLabeledAlt: 'sizeof'unary-expression
          enterAlternative: 'sizeof'unary-expression
            enterElement: 'sizeof'
              => element -> sizeof
              enterAtom: 'sizeof'
                enterTerminal: 'sizeof'
                exitTerminal: 'sizeof'
              exitAtom: 'sizeof'
            exitElement: 'sizeof'
            enterElement: unary-expression
              => element -> {unary-expression}
              enterAtom: unary-expression
                enterRuleref: unary-expression
                exitRuleref: unary-expression
              exitAtom: unary-expression
            exitElement: unary-expression
          exitAlternative: 'sizeof'unary-expression
        => elements -> ['sizeof', '{unary-expression}']
            => alternative -> sizeof {unary-expression}
        exitLabeledAlt: 'sizeof'unary-expression
        enterLabeledAlt: 'sizeof('type-id')'
          enterAlternative: 'sizeof('type-id')'
            enterElement: 'sizeof('
              => element -> sizeof(
              enterAtom: 'sizeof('
                enterTerminal: 'sizeof('
                exitTerminal: 'sizeof('
              exitAtom: 'sizeof('
            exitElement: 'sizeof('
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'sizeof('type-id')'
        => elements -> ['sizeof(', '{type-id}', ')']
            => alternative -> sizeof( {type-id} )
        exitLabeledAlt: 'sizeof('type-id')'
        enterLabeledAlt: 'sizeof...('identifier')'
          enterAlternative: 'sizeof...('identifier')'
            enterElement: 'sizeof...('
              => element -> sizeof...(
              enterAtom: 'sizeof...('
                enterTerminal: 'sizeof...('
                exitTerminal: 'sizeof...('
              exitAtom: 'sizeof...('
            exitElement: 'sizeof...('
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'sizeof...('identifier')'
        => elements -> ['sizeof...(', '{identifier}', ')']
            => alternative -> sizeof...( {identifier} )
        exitLabeledAlt: 'sizeof...('identifier')'
        enterLabeledAlt: 'alignof('type-id')'
          enterAlternative: 'alignof('type-id')'
            enterElement: 'alignof('
              => element -> alignof(
              enterAtom: 'alignof('
                enterTerminal: 'alignof('
                exitTerminal: 'alignof('
              exitAtom: 'alignof('
            exitElement: 'alignof('
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'alignof('type-id')'
        => elements -> ['alignof(', '{type-id}', ')']
            => alternative -> alignof( {type-id} )
        exitLabeledAlt: 'alignof('type-id')'
        enterLabeledAlt: noexcept-expression
          enterAlternative: noexcept-expression
            enterElement: noexcept-expression
              => element -> {noexcept-expression}
              enterAtom: noexcept-expression
                enterRuleref: noexcept-expression
                exitRuleref: noexcept-expression
              exitAtom: noexcept-expression
            exitElement: noexcept-expression
          exitAlternative: noexcept-expression
        => elements -> ['{noexcept-expression}']
            => alternative -> {noexcept-expression}
        exitLabeledAlt: noexcept-expression
        enterLabeledAlt: new-expression
          enterAlternative: new-expression
            enterElement: new-expression
              => element -> {new-expression}
              enterAtom: new-expression
                enterRuleref: new-expression
                exitRuleref: new-expression
              exitAtom: new-expression
            exitElement: new-expression
          exitAlternative: new-expression
        => elements -> ['{new-expression}']
            => alternative -> {new-expression}
        exitLabeledAlt: new-expression
        enterLabeledAlt: delete-expression
          enterAlternative: delete-expression
            enterElement: delete-expression
              => element -> {delete-expression}
              enterAtom: delete-expression
                enterRuleref: delete-expression
                exitRuleref: delete-expression
              exitAtom: delete-expression
            exitElement: delete-expression
          exitAlternative: delete-expression
        => elements -> ['{delete-expression}']
            => alternative -> {delete-expression}
        exitLabeledAlt: delete-expression
      exitRuleAltList: postfix-expression|unary-operatorcast-expression|'++'cast-expression|'--'cast-expression|await-expression|'sizeof'unary-expression|'sizeof('type-id')'|'sizeof...('identifier')'|'alignof('type-id')'|noexcept-expression|new-expression|delete-expression
    exitRuleBlock: postfix-expression|unary-operatorcast-expression|'++'cast-expression|'--'cast-expression|await-expression|'sizeof'unary-expression|'sizeof('type-id')'|'sizeof...('identifier')'|'alignof('type-id')'|noexcept-expression|new-expression|delete-expression
  exitRuleSpec: unary-expression:postfix-expression|unary-operatorcast-expression|'++'cast-expression|'--'cast-expression|await-expression|'sizeof'unary-expression|'sizeof('type-id')'|'sizeof...('identifier')'|'alignof('type-id')'|noexcept-expression|new-expression|delete-expression;

  enterRuleSpec: unary-operator:'*'|'&'|'+'|'-'|'!'|'~';
    enterRuleBlock: '*'|'&'|'+'|'-'|'!'|'~'
      enterRuleAltList: '*'|'&'|'+'|'-'|'!'|'~'
        enterLabeledAlt: '*'
          enterAlternative: '*'
            enterElement: '*'
              => element -> *
              enterAtom: '*'
                enterTerminal: '*'
                exitTerminal: '*'
              exitAtom: '*'
            exitElement: '*'
          exitAlternative: '*'
        => elements -> ['*']
            => alternative -> *
        exitLabeledAlt: '*'
        enterLabeledAlt: '&'
          enterAlternative: '&'
            enterElement: '&'
              => element -> &
              enterAtom: '&'
                enterTerminal: '&'
                exitTerminal: '&'
              exitAtom: '&'
            exitElement: '&'
          exitAlternative: '&'
        => elements -> ['&']
            => alternative -> &
        exitLabeledAlt: '&'
        enterLabeledAlt: '+'
          enterAlternative: '+'
            enterElement: '+'
              => element -> +
              enterAtom: '+'
                enterTerminal: '+'
                exitTerminal: '+'
              exitAtom: '+'
            exitElement: '+'
          exitAlternative: '+'
        => elements -> ['+']
            => alternative -> +
        exitLabeledAlt: '+'
        enterLabeledAlt: '-'
          enterAlternative: '-'
            enterElement: '-'
              => element -> -
              enterAtom: '-'
                enterTerminal: '-'
                exitTerminal: '-'
              exitAtom: '-'
            exitElement: '-'
          exitAlternative: '-'
        => elements -> ['-']
            => alternative -> -
        exitLabeledAlt: '-'
        enterLabeledAlt: '!'
          enterAlternative: '!'
            enterElement: '!'
              => element -> !
              enterAtom: '!'
                enterTerminal: '!'
                exitTerminal: '!'
              exitAtom: '!'
            exitElement: '!'
          exitAlternative: '!'
        => elements -> ['!']
            => alternative -> !
        exitLabeledAlt: '!'
        enterLabeledAlt: '~'
          enterAlternative: '~'
            enterElement: '~'
              => element -> ~
              enterAtom: '~'
                enterTerminal: '~'
                exitTerminal: '~'
              exitAtom: '~'
            exitElement: '~'
          exitAlternative: '~'
        => elements -> ['~']
            => alternative -> ~
        exitLabeledAlt: '~'
      exitRuleAltList: '*'|'&'|'+'|'-'|'!'|'~'
    exitRuleBlock: '*'|'&'|'+'|'-'|'!'|'~'
  exitRuleSpec: unary-operator:'*'|'&'|'+'|'-'|'!'|'~';

  enterRuleSpec: await-expression:'co_await'cast-expression;
    enterRuleBlock: 'co_await'cast-expression
      enterRuleAltList: 'co_await'cast-expression
        enterLabeledAlt: 'co_await'cast-expression
          enterAlternative: 'co_await'cast-expression
            enterElement: 'co_await'
              => element -> co_await
              enterAtom: 'co_await'
                enterTerminal: 'co_await'
                exitTerminal: 'co_await'
              exitAtom: 'co_await'
            exitElement: 'co_await'
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
          exitAlternative: 'co_await'cast-expression
        => elements -> ['co_await', '{cast-expression}']
            => alternative -> co_await {cast-expression}
        exitLabeledAlt: 'co_await'cast-expression
      exitRuleAltList: 'co_await'cast-expression
    exitRuleBlock: 'co_await'cast-expression
  exitRuleSpec: await-expression:'co_await'cast-expression;

  enterRuleSpec: noexcept-expression:'noexcept('expression')';
    enterRuleBlock: 'noexcept('expression')'
      enterRuleAltList: 'noexcept('expression')'
        enterLabeledAlt: 'noexcept('expression')'
          enterAlternative: 'noexcept('expression')'
            enterElement: 'noexcept('
              => element -> noexcept(
              enterAtom: 'noexcept('
                enterTerminal: 'noexcept('
                exitTerminal: 'noexcept('
              exitAtom: 'noexcept('
            exitElement: 'noexcept('
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'noexcept('expression')'
        => elements -> ['noexcept(', '{expression}', ')']
            => alternative -> noexcept( {expression} )
        exitLabeledAlt: 'noexcept('expression')'
      exitRuleAltList: 'noexcept('expression')'
    exitRuleBlock: 'noexcept('expression')'
  exitRuleSpec: noexcept-expression:'noexcept('expression')';

  enterRuleSpec: nesting-operator:'::';
    enterRuleBlock: '::'
      enterRuleAltList: '::'
        enterLabeledAlt: '::'
          enterAlternative: '::'
            enterElement: '::'
              => element -> ::
              enterAtom: '::'
                enterTerminal: '::'
                exitTerminal: '::'
              exitAtom: '::'
            exitElement: '::'
          exitAlternative: '::'
        => elements -> ['::']
            => alternative -> ::
        exitLabeledAlt: '::'
      exitRuleAltList: '::'
    exitRuleBlock: '::'
  exitRuleSpec: nesting-operator:'::';

  enterRuleSpec: new-expression:nesting-operator?'new'new-placement?new-type-idnew-initializer?|nesting-operator?'new'new-placement?'('type-id')'new-initializer?;
    enterRuleBlock: nesting-operator?'new'new-placement?new-type-idnew-initializer?|nesting-operator?'new'new-placement?'('type-id')'new-initializer?
      enterRuleAltList: nesting-operator?'new'new-placement?new-type-idnew-initializer?|nesting-operator?'new'new-placement?'('type-id')'new-initializer?
        enterLabeledAlt: nesting-operator?'new'new-placement?new-type-idnew-initializer?
          enterAlternative: nesting-operator?'new'new-placement?new-type-idnew-initializer?
            enterElement: nesting-operator?
              => element -> [nesting-operator]
              enterAtom: nesting-operator
                enterRuleref: nesting-operator
                exitRuleref: nesting-operator
              exitAtom: nesting-operator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nesting-operator?
            enterElement: 'new'
              => element -> new
              enterAtom: 'new'
                enterTerminal: 'new'
                exitTerminal: 'new'
              exitAtom: 'new'
            exitElement: 'new'
            enterElement: new-placement?
              => element -> [new-placement]
              enterAtom: new-placement
                enterRuleref: new-placement
                exitRuleref: new-placement
              exitAtom: new-placement
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: new-placement?
            enterElement: new-type-id
              => element -> {new-type-id}
              enterAtom: new-type-id
                enterRuleref: new-type-id
                exitRuleref: new-type-id
              exitAtom: new-type-id
            exitElement: new-type-id
            enterElement: new-initializer?
              => element -> [new-initializer]
              enterAtom: new-initializer
                enterRuleref: new-initializer
                exitRuleref: new-initializer
              exitAtom: new-initializer
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: new-initializer?
          exitAlternative: nesting-operator?'new'new-placement?new-type-idnew-initializer?
        => elements -> ['[nesting-operator]', 'new', '[new-placement]', '{new-type-id}', '[new-initializer]']
            => alternative -> [nesting-operator] new [new-placement] {new-type-id} [new-initializer]
        exitLabeledAlt: nesting-operator?'new'new-placement?new-type-idnew-initializer?
        enterLabeledAlt: nesting-operator?'new'new-placement?'('type-id')'new-initializer?
          enterAlternative: nesting-operator?'new'new-placement?'('type-id')'new-initializer?
            enterElement: nesting-operator?
              => element -> [nesting-operator]
              enterAtom: nesting-operator
                enterRuleref: nesting-operator
                exitRuleref: nesting-operator
              exitAtom: nesting-operator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nesting-operator?
            enterElement: 'new'
              => element -> new
              enterAtom: 'new'
                enterTerminal: 'new'
                exitTerminal: 'new'
              exitAtom: 'new'
            exitElement: 'new'
            enterElement: new-placement?
              => element -> [new-placement]
              enterAtom: new-placement
                enterRuleref: new-placement
                exitRuleref: new-placement
              exitAtom: new-placement
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: new-placement?
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
            enterElement: new-initializer?
              => element -> [new-initializer]
              enterAtom: new-initializer
                enterRuleref: new-initializer
                exitRuleref: new-initializer
              exitAtom: new-initializer
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: new-initializer?
          exitAlternative: nesting-operator?'new'new-placement?'('type-id')'new-initializer?
        => elements -> ['[nesting-operator]', 'new', '[new-placement]', '(', '{type-id}', ')', '[new-initializer]']
            => alternative -> [nesting-operator] new [new-placement] ( {type-id} ) [new-initializer]
        exitLabeledAlt: nesting-operator?'new'new-placement?'('type-id')'new-initializer?
      exitRuleAltList: nesting-operator?'new'new-placement?new-type-idnew-initializer?|nesting-operator?'new'new-placement?'('type-id')'new-initializer?
    exitRuleBlock: nesting-operator?'new'new-placement?new-type-idnew-initializer?|nesting-operator?'new'new-placement?'('type-id')'new-initializer?
  exitRuleSpec: new-expression:nesting-operator?'new'new-placement?new-type-idnew-initializer?|nesting-operator?'new'new-placement?'('type-id')'new-initializer?;

  enterRuleSpec: new-placement:'('expression-list')';
    enterRuleBlock: '('expression-list')'
      enterRuleAltList: '('expression-list')'
        enterLabeledAlt: '('expression-list')'
          enterAlternative: '('expression-list')'
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: expression-list
              => element -> {expression-list}
              enterAtom: expression-list
                enterRuleref: expression-list
                exitRuleref: expression-list
              exitAtom: expression-list
            exitElement: expression-list
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '('expression-list')'
        => elements -> ['(', '{expression-list}', ')']
            => alternative -> ( {expression-list} )
        exitLabeledAlt: '('expression-list')'
      exitRuleAltList: '('expression-list')'
    exitRuleBlock: '('expression-list')'
  exitRuleSpec: new-placement:'('expression-list')';

  enterRuleSpec: new-type-id:type-specifier-seqnew-declarator?;
    enterRuleBlock: type-specifier-seqnew-declarator?
      enterRuleAltList: type-specifier-seqnew-declarator?
        enterLabeledAlt: type-specifier-seqnew-declarator?
          enterAlternative: type-specifier-seqnew-declarator?
            enterElement: type-specifier-seq
              => element -> {type-specifier-seq}
              enterAtom: type-specifier-seq
                enterRuleref: type-specifier-seq
                exitRuleref: type-specifier-seq
              exitAtom: type-specifier-seq
            exitElement: type-specifier-seq
            enterElement: new-declarator?
              => element -> [new-declarator]
              enterAtom: new-declarator
                enterRuleref: new-declarator
                exitRuleref: new-declarator
              exitAtom: new-declarator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: new-declarator?
          exitAlternative: type-specifier-seqnew-declarator?
        => elements -> ['{type-specifier-seq}', '[new-declarator]']
            => alternative -> {type-specifier-seq} [new-declarator]
        exitLabeledAlt: type-specifier-seqnew-declarator?
      exitRuleAltList: type-specifier-seqnew-declarator?
    exitRuleBlock: type-specifier-seqnew-declarator?
  exitRuleSpec: new-type-id:type-specifier-seqnew-declarator?;

  enterRuleSpec: new-declarator:ptr-operatornew-declarator?|noptr-new-declarator;
    enterRuleBlock: ptr-operatornew-declarator?|noptr-new-declarator
      enterRuleAltList: ptr-operatornew-declarator?|noptr-new-declarator
        enterLabeledAlt: ptr-operatornew-declarator?
          enterAlternative: ptr-operatornew-declarator?
            enterElement: ptr-operator
              => element -> {ptr-operator}
              enterAtom: ptr-operator
                enterRuleref: ptr-operator
                exitRuleref: ptr-operator
              exitAtom: ptr-operator
            exitElement: ptr-operator
            enterElement: new-declarator?
              => element -> [new-declarator]
              enterAtom: new-declarator
                enterRuleref: new-declarator
                exitRuleref: new-declarator
              exitAtom: new-declarator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: new-declarator?
          exitAlternative: ptr-operatornew-declarator?
        => elements -> ['{ptr-operator}', '[new-declarator]']
            => alternative -> {ptr-operator} [new-declarator]
        exitLabeledAlt: ptr-operatornew-declarator?
        enterLabeledAlt: noptr-new-declarator
          enterAlternative: noptr-new-declarator
            enterElement: noptr-new-declarator
              => element -> {noptr-new-declarator}
              enterAtom: noptr-new-declarator
                enterRuleref: noptr-new-declarator
                exitRuleref: noptr-new-declarator
              exitAtom: noptr-new-declarator
            exitElement: noptr-new-declarator
          exitAlternative: noptr-new-declarator
        => elements -> ['{noptr-new-declarator}']
            => alternative -> {noptr-new-declarator}
        exitLabeledAlt: noptr-new-declarator
      exitRuleAltList: ptr-operatornew-declarator?|noptr-new-declarator
    exitRuleBlock: ptr-operatornew-declarator?|noptr-new-declarator
  exitRuleSpec: new-declarator:ptr-operatornew-declarator?|noptr-new-declarator;

  enterRuleSpec: noptr-new-declarator:'['expression?']'attribute-specifier*|noptr-new-declarator'['constant-expression']'attribute-specifier*;
    enterRuleBlock: '['expression?']'attribute-specifier*|noptr-new-declarator'['constant-expression']'attribute-specifier*
      enterRuleAltList: '['expression?']'attribute-specifier*|noptr-new-declarator'['constant-expression']'attribute-specifier*
        enterLabeledAlt: '['expression?']'attribute-specifier*
          enterAlternative: '['expression?']'attribute-specifier*
            enterElement: '['
              => element -> [
              enterAtom: '['
                enterTerminal: '['
                exitTerminal: '['
              exitAtom: '['
            exitElement: '['
            enterElement: expression?
              => element -> [expression]
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: expression?
            enterElement: ']'
              => element -> ]
              enterAtom: ']'
                enterTerminal: ']'
                exitTerminal: ']'
              exitAtom: ']'
            exitElement: ']'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
          exitAlternative: '['expression?']'attribute-specifier*
        => elements -> ['[', '[expression]', ']', '[attribute-specifier]...']
            => alternative -> [ [expression] ] [attribute-specifier]...
        exitLabeledAlt: '['expression?']'attribute-specifier*
        enterLabeledAlt: noptr-new-declarator'['constant-expression']'attribute-specifier*
          enterAlternative: noptr-new-declarator'['constant-expression']'attribute-specifier*
            enterElement: noptr-new-declarator
              => element -> {noptr-new-declarator}
              enterAtom: noptr-new-declarator
                enterRuleref: noptr-new-declarator
                exitRuleref: noptr-new-declarator
              exitAtom: noptr-new-declarator
            exitElement: noptr-new-declarator
            enterElement: '['
              => element -> [
              enterAtom: '['
                enterTerminal: '['
                exitTerminal: '['
              exitAtom: '['
            exitElement: '['
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
            enterElement: ']'
              => element -> ]
              enterAtom: ']'
                enterTerminal: ']'
                exitTerminal: ']'
              exitAtom: ']'
            exitElement: ']'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
          exitAlternative: noptr-new-declarator'['constant-expression']'attribute-specifier*
        => elements -> ['{noptr-new-declarator}', '[', '{constant-expression}', ']', '[attribute-specifier]...']
            => alternative -> {noptr-new-declarator} [ {constant-expression} ] [attribute-specifier]...
        exitLabeledAlt: noptr-new-declarator'['constant-expression']'attribute-specifier*
      exitRuleAltList: '['expression?']'attribute-specifier*|noptr-new-declarator'['constant-expression']'attribute-specifier*
    exitRuleBlock: '['expression?']'attribute-specifier*|noptr-new-declarator'['constant-expression']'attribute-specifier*
  exitRuleSpec: noptr-new-declarator:'['expression?']'attribute-specifier*|noptr-new-declarator'['constant-expression']'attribute-specifier*;

  enterRuleSpec: new-initializer:'('expression-list?')'|braced-init-list;
    enterRuleBlock: '('expression-list?')'|braced-init-list
      enterRuleAltList: '('expression-list?')'|braced-init-list
        enterLabeledAlt: '('expression-list?')'
          enterAlternative: '('expression-list?')'
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: expression-list?
              => element -> [expression-list]
              enterAtom: expression-list
                enterRuleref: expression-list
                exitRuleref: expression-list
              exitAtom: expression-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: expression-list?
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '('expression-list?')'
        => elements -> ['(', '[expression-list]', ')']
            => alternative -> ( [expression-list] )
        exitLabeledAlt: '('expression-list?')'
        enterLabeledAlt: braced-init-list
          enterAlternative: braced-init-list
            enterElement: braced-init-list
              => element -> {braced-init-list}
              enterAtom: braced-init-list
                enterRuleref: braced-init-list
                exitRuleref: braced-init-list
              exitAtom: braced-init-list
            exitElement: braced-init-list
          exitAlternative: braced-init-list
        => elements -> ['{braced-init-list}']
            => alternative -> {braced-init-list}
        exitLabeledAlt: braced-init-list
      exitRuleAltList: '('expression-list?')'|braced-init-list
    exitRuleBlock: '('expression-list?')'|braced-init-list
  exitRuleSpec: new-initializer:'('expression-list?')'|braced-init-list;

  enterRuleSpec: delete-expression:nesting-operator?'delete'cast-expression|nesting-operator?'delete[]'cast-expression;
    enterRuleBlock: nesting-operator?'delete'cast-expression|nesting-operator?'delete[]'cast-expression
      enterRuleAltList: nesting-operator?'delete'cast-expression|nesting-operator?'delete[]'cast-expression
        enterLabeledAlt: nesting-operator?'delete'cast-expression
          enterAlternative: nesting-operator?'delete'cast-expression
            enterElement: nesting-operator?
              => element -> [nesting-operator]
              enterAtom: nesting-operator
                enterRuleref: nesting-operator
                exitRuleref: nesting-operator
              exitAtom: nesting-operator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nesting-operator?
            enterElement: 'delete'
              => element -> delete
              enterAtom: 'delete'
                enterTerminal: 'delete'
                exitTerminal: 'delete'
              exitAtom: 'delete'
            exitElement: 'delete'
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
          exitAlternative: nesting-operator?'delete'cast-expression
        => elements -> ['[nesting-operator]', 'delete', '{cast-expression}']
            => alternative -> [nesting-operator] delete {cast-expression}
        exitLabeledAlt: nesting-operator?'delete'cast-expression
        enterLabeledAlt: nesting-operator?'delete[]'cast-expression
          enterAlternative: nesting-operator?'delete[]'cast-expression
            enterElement: nesting-operator?
              => element -> [nesting-operator]
              enterAtom: nesting-operator
                enterRuleref: nesting-operator
                exitRuleref: nesting-operator
              exitAtom: nesting-operator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nesting-operator?
            enterElement: 'delete[]'
              => element -> delete[]
              enterAtom: 'delete[]'
                enterTerminal: 'delete[]'
                exitTerminal: 'delete[]'
              exitAtom: 'delete[]'
            exitElement: 'delete[]'
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
          exitAlternative: nesting-operator?'delete[]'cast-expression
        => elements -> ['[nesting-operator]', 'delete[]', '{cast-expression}']
            => alternative -> [nesting-operator] delete[] {cast-expression}
        exitLabeledAlt: nesting-operator?'delete[]'cast-expression
      exitRuleAltList: nesting-operator?'delete'cast-expression|nesting-operator?'delete[]'cast-expression
    exitRuleBlock: nesting-operator?'delete'cast-expression|nesting-operator?'delete[]'cast-expression
  exitRuleSpec: delete-expression:nesting-operator?'delete'cast-expression|nesting-operator?'delete[]'cast-expression;

  enterRuleSpec: cast-expression:unary-expression|'('type-id')'cast-expression;
    enterRuleBlock: unary-expression|'('type-id')'cast-expression
      enterRuleAltList: unary-expression|'('type-id')'cast-expression
        enterLabeledAlt: unary-expression
          enterAlternative: unary-expression
            enterElement: unary-expression
              => element -> {unary-expression}
              enterAtom: unary-expression
                enterRuleref: unary-expression
                exitRuleref: unary-expression
              exitAtom: unary-expression
            exitElement: unary-expression
          exitAlternative: unary-expression
        => elements -> ['{unary-expression}']
            => alternative -> {unary-expression}
        exitLabeledAlt: unary-expression
        enterLabeledAlt: '('type-id')'cast-expression
          enterAlternative: '('type-id')'cast-expression
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
          exitAlternative: '('type-id')'cast-expression
        => elements -> ['(', '{type-id}', ')', '{cast-expression}']
            => alternative -> ( {type-id} ) {cast-expression}
        exitLabeledAlt: '('type-id')'cast-expression
      exitRuleAltList: unary-expression|'('type-id')'cast-expression
    exitRuleBlock: unary-expression|'('type-id')'cast-expression
  exitRuleSpec: cast-expression:unary-expression|'('type-id')'cast-expression;

  enterRuleSpec: pm-expression:cast-expression|pm-expression'.*'cast-expression|pm-expression'->*'cast-expression;
    enterRuleBlock: cast-expression|pm-expression'.*'cast-expression|pm-expression'->*'cast-expression
      enterRuleAltList: cast-expression|pm-expression'.*'cast-expression|pm-expression'->*'cast-expression
        enterLabeledAlt: cast-expression
          enterAlternative: cast-expression
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
          exitAlternative: cast-expression
        => elements -> ['{cast-expression}']
            => alternative -> {cast-expression}
        exitLabeledAlt: cast-expression
        enterLabeledAlt: pm-expression'.*'cast-expression
          enterAlternative: pm-expression'.*'cast-expression
            enterElement: pm-expression
              => element -> {pm-expression}
              enterAtom: pm-expression
                enterRuleref: pm-expression
                exitRuleref: pm-expression
              exitAtom: pm-expression
            exitElement: pm-expression
            enterElement: '.*'
              => element -> .*
              enterAtom: '.*'
                enterTerminal: '.*'
                exitTerminal: '.*'
              exitAtom: '.*'
            exitElement: '.*'
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
          exitAlternative: pm-expression'.*'cast-expression
        => elements -> ['{pm-expression}', '.*', '{cast-expression}']
            => alternative -> {pm-expression} .* {cast-expression}
        exitLabeledAlt: pm-expression'.*'cast-expression
        enterLabeledAlt: pm-expression'->*'cast-expression
          enterAlternative: pm-expression'->*'cast-expression
            enterElement: pm-expression
              => element -> {pm-expression}
              enterAtom: pm-expression
                enterRuleref: pm-expression
                exitRuleref: pm-expression
              exitAtom: pm-expression
            exitElement: pm-expression
            enterElement: '->*'
              => element -> ->*
              enterAtom: '->*'
                enterTerminal: '->*'
                exitTerminal: '->*'
              exitAtom: '->*'
            exitElement: '->*'
            enterElement: cast-expression
              => element -> {cast-expression}
              enterAtom: cast-expression
                enterRuleref: cast-expression
                exitRuleref: cast-expression
              exitAtom: cast-expression
            exitElement: cast-expression
          exitAlternative: pm-expression'->*'cast-expression
        => elements -> ['{pm-expression}', '->*', '{cast-expression}']
            => alternative -> {pm-expression} ->* {cast-expression}
        exitLabeledAlt: pm-expression'->*'cast-expression
      exitRuleAltList: cast-expression|pm-expression'.*'cast-expression|pm-expression'->*'cast-expression
    exitRuleBlock: cast-expression|pm-expression'.*'cast-expression|pm-expression'->*'cast-expression
  exitRuleSpec: pm-expression:cast-expression|pm-expression'.*'cast-expression|pm-expression'->*'cast-expression;

  enterRuleSpec: multiplicative-expression:pm-expression|multiplicative-expression'*'pm-expression|multiplicative-expression'/'pm-expression|multiplicative-expression'%'pm-expression;
    enterRuleBlock: pm-expression|multiplicative-expression'*'pm-expression|multiplicative-expression'/'pm-expression|multiplicative-expression'%'pm-expression
      enterRuleAltList: pm-expression|multiplicative-expression'*'pm-expression|multiplicative-expression'/'pm-expression|multiplicative-expression'%'pm-expression
        enterLabeledAlt: pm-expression
          enterAlternative: pm-expression
            enterElement: pm-expression
              => element -> {pm-expression}
              enterAtom: pm-expression
                enterRuleref: pm-expression
                exitRuleref: pm-expression
              exitAtom: pm-expression
            exitElement: pm-expression
          exitAlternative: pm-expression
        => elements -> ['{pm-expression}']
            => alternative -> {pm-expression}
        exitLabeledAlt: pm-expression
        enterLabeledAlt: multiplicative-expression'*'pm-expression
          enterAlternative: multiplicative-expression'*'pm-expression
            enterElement: multiplicative-expression
              => element -> {multiplicative-expression}
              enterAtom: multiplicative-expression
                enterRuleref: multiplicative-expression
                exitRuleref: multiplicative-expression
              exitAtom: multiplicative-expression
            exitElement: multiplicative-expression
            enterElement: '*'
              => element -> *
              enterAtom: '*'
                enterTerminal: '*'
                exitTerminal: '*'
              exitAtom: '*'
            exitElement: '*'
            enterElement: pm-expression
              => element -> {pm-expression}
              enterAtom: pm-expression
                enterRuleref: pm-expression
                exitRuleref: pm-expression
              exitAtom: pm-expression
            exitElement: pm-expression
          exitAlternative: multiplicative-expression'*'pm-expression
        => elements -> ['{multiplicative-expression}', '*', '{pm-expression}']
            => alternative -> {multiplicative-expression} * {pm-expression}
        exitLabeledAlt: multiplicative-expression'*'pm-expression
        enterLabeledAlt: multiplicative-expression'/'pm-expression
          enterAlternative: multiplicative-expression'/'pm-expression
            enterElement: multiplicative-expression
              => element -> {multiplicative-expression}
              enterAtom: multiplicative-expression
                enterRuleref: multiplicative-expression
                exitRuleref: multiplicative-expression
              exitAtom: multiplicative-expression
            exitElement: multiplicative-expression
            enterElement: '/'
              => element -> /
              enterAtom: '/'
                enterTerminal: '/'
                exitTerminal: '/'
              exitAtom: '/'
            exitElement: '/'
            enterElement: pm-expression
              => element -> {pm-expression}
              enterAtom: pm-expression
                enterRuleref: pm-expression
                exitRuleref: pm-expression
              exitAtom: pm-expression
            exitElement: pm-expression
          exitAlternative: multiplicative-expression'/'pm-expression
        => elements -> ['{multiplicative-expression}', '/', '{pm-expression}']
            => alternative -> {multiplicative-expression} / {pm-expression}
        exitLabeledAlt: multiplicative-expression'/'pm-expression
        enterLabeledAlt: multiplicative-expression'%'pm-expression
          enterAlternative: multiplicative-expression'%'pm-expression
            enterElement: multiplicative-expression
              => element -> {multiplicative-expression}
              enterAtom: multiplicative-expression
                enterRuleref: multiplicative-expression
                exitRuleref: multiplicative-expression
              exitAtom: multiplicative-expression
            exitElement: multiplicative-expression
            enterElement: '%'
              => element -> %
              enterAtom: '%'
                enterTerminal: '%'
                exitTerminal: '%'
              exitAtom: '%'
            exitElement: '%'
            enterElement: pm-expression
              => element -> {pm-expression}
              enterAtom: pm-expression
                enterRuleref: pm-expression
                exitRuleref: pm-expression
              exitAtom: pm-expression
            exitElement: pm-expression
          exitAlternative: multiplicative-expression'%'pm-expression
        => elements -> ['{multiplicative-expression}', '%', '{pm-expression}']
            => alternative -> {multiplicative-expression} % {pm-expression}
        exitLabeledAlt: multiplicative-expression'%'pm-expression
      exitRuleAltList: pm-expression|multiplicative-expression'*'pm-expression|multiplicative-expression'/'pm-expression|multiplicative-expression'%'pm-expression
    exitRuleBlock: pm-expression|multiplicative-expression'*'pm-expression|multiplicative-expression'/'pm-expression|multiplicative-expression'%'pm-expression
  exitRuleSpec: multiplicative-expression:pm-expression|multiplicative-expression'*'pm-expression|multiplicative-expression'/'pm-expression|multiplicative-expression'%'pm-expression;

  enterRuleSpec: additive-expression:multiplicative-expression|additive-expression'+'multiplicative-expression|additive-expression'-'multiplicative-expression;
    enterRuleBlock: multiplicative-expression|additive-expression'+'multiplicative-expression|additive-expression'-'multiplicative-expression
      enterRuleAltList: multiplicative-expression|additive-expression'+'multiplicative-expression|additive-expression'-'multiplicative-expression
        enterLabeledAlt: multiplicative-expression
          enterAlternative: multiplicative-expression
            enterElement: multiplicative-expression
              => element -> {multiplicative-expression}
              enterAtom: multiplicative-expression
                enterRuleref: multiplicative-expression
                exitRuleref: multiplicative-expression
              exitAtom: multiplicative-expression
            exitElement: multiplicative-expression
          exitAlternative: multiplicative-expression
        => elements -> ['{multiplicative-expression}']
            => alternative -> {multiplicative-expression}
        exitLabeledAlt: multiplicative-expression
        enterLabeledAlt: additive-expression'+'multiplicative-expression
          enterAlternative: additive-expression'+'multiplicative-expression
            enterElement: additive-expression
              => element -> {additive-expression}
              enterAtom: additive-expression
                enterRuleref: additive-expression
                exitRuleref: additive-expression
              exitAtom: additive-expression
            exitElement: additive-expression
            enterElement: '+'
              => element -> +
              enterAtom: '+'
                enterTerminal: '+'
                exitTerminal: '+'
              exitAtom: '+'
            exitElement: '+'
            enterElement: multiplicative-expression
              => element -> {multiplicative-expression}
              enterAtom: multiplicative-expression
                enterRuleref: multiplicative-expression
                exitRuleref: multiplicative-expression
              exitAtom: multiplicative-expression
            exitElement: multiplicative-expression
          exitAlternative: additive-expression'+'multiplicative-expression
        => elements -> ['{additive-expression}', '+', '{multiplicative-expression}']
            => alternative -> {additive-expression} + {multiplicative-expression}
        exitLabeledAlt: additive-expression'+'multiplicative-expression
        enterLabeledAlt: additive-expression'-'multiplicative-expression
          enterAlternative: additive-expression'-'multiplicative-expression
            enterElement: additive-expression
              => element -> {additive-expression}
              enterAtom: additive-expression
                enterRuleref: additive-expression
                exitRuleref: additive-expression
              exitAtom: additive-expression
            exitElement: additive-expression
            enterElement: '-'
              => element -> -
              enterAtom: '-'
                enterTerminal: '-'
                exitTerminal: '-'
              exitAtom: '-'
            exitElement: '-'
            enterElement: multiplicative-expression
              => element -> {multiplicative-expression}
              enterAtom: multiplicative-expression
                enterRuleref: multiplicative-expression
                exitRuleref: multiplicative-expression
              exitAtom: multiplicative-expression
            exitElement: multiplicative-expression
          exitAlternative: additive-expression'-'multiplicative-expression
        => elements -> ['{additive-expression}', '-', '{multiplicative-expression}']
            => alternative -> {additive-expression} - {multiplicative-expression}
        exitLabeledAlt: additive-expression'-'multiplicative-expression
      exitRuleAltList: multiplicative-expression|additive-expression'+'multiplicative-expression|additive-expression'-'multiplicative-expression
    exitRuleBlock: multiplicative-expression|additive-expression'+'multiplicative-expression|additive-expression'-'multiplicative-expression
  exitRuleSpec: additive-expression:multiplicative-expression|additive-expression'+'multiplicative-expression|additive-expression'-'multiplicative-expression;

  enterRuleSpec: shift-expression:additive-expression|shift-expression'<<'additive-expression|shift-expression'>>'additive-expression;
    enterRuleBlock: additive-expression|shift-expression'<<'additive-expression|shift-expression'>>'additive-expression
      enterRuleAltList: additive-expression|shift-expression'<<'additive-expression|shift-expression'>>'additive-expression
        enterLabeledAlt: additive-expression
          enterAlternative: additive-expression
            enterElement: additive-expression
              => element -> {additive-expression}
              enterAtom: additive-expression
                enterRuleref: additive-expression
                exitRuleref: additive-expression
              exitAtom: additive-expression
            exitElement: additive-expression
          exitAlternative: additive-expression
        => elements -> ['{additive-expression}']
            => alternative -> {additive-expression}
        exitLabeledAlt: additive-expression
        enterLabeledAlt: shift-expression'<<'additive-expression
          enterAlternative: shift-expression'<<'additive-expression
            enterElement: shift-expression
              => element -> {shift-expression}
              enterAtom: shift-expression
                enterRuleref: shift-expression
                exitRuleref: shift-expression
              exitAtom: shift-expression
            exitElement: shift-expression
            enterElement: '<<'
              => element -> <<
              enterAtom: '<<'
                enterTerminal: '<<'
                exitTerminal: '<<'
              exitAtom: '<<'
            exitElement: '<<'
            enterElement: additive-expression
              => element -> {additive-expression}
              enterAtom: additive-expression
                enterRuleref: additive-expression
                exitRuleref: additive-expression
              exitAtom: additive-expression
            exitElement: additive-expression
          exitAlternative: shift-expression'<<'additive-expression
        => elements -> ['{shift-expression}', '<<', '{additive-expression}']
            => alternative -> {shift-expression} << {additive-expression}
        exitLabeledAlt: shift-expression'<<'additive-expression
        enterLabeledAlt: shift-expression'>>'additive-expression
          enterAlternative: shift-expression'>>'additive-expression
            enterElement: shift-expression
              => element -> {shift-expression}
              enterAtom: shift-expression
                enterRuleref: shift-expression
                exitRuleref: shift-expression
              exitAtom: shift-expression
            exitElement: shift-expression
            enterElement: '>>'
              => element -> >>
              enterAtom: '>>'
                enterTerminal: '>>'
                exitTerminal: '>>'
              exitAtom: '>>'
            exitElement: '>>'
            enterElement: additive-expression
              => element -> {additive-expression}
              enterAtom: additive-expression
                enterRuleref: additive-expression
                exitRuleref: additive-expression
              exitAtom: additive-expression
            exitElement: additive-expression
          exitAlternative: shift-expression'>>'additive-expression
        => elements -> ['{shift-expression}', '>>', '{additive-expression}']
            => alternative -> {shift-expression} >> {additive-expression}
        exitLabeledAlt: shift-expression'>>'additive-expression
      exitRuleAltList: additive-expression|shift-expression'<<'additive-expression|shift-expression'>>'additive-expression
    exitRuleBlock: additive-expression|shift-expression'<<'additive-expression|shift-expression'>>'additive-expression
  exitRuleSpec: shift-expression:additive-expression|shift-expression'<<'additive-expression|shift-expression'>>'additive-expression;

  enterRuleSpec: compare-expression:shift-expression|compare-expression'<=>'shift-expression;
    enterRuleBlock: shift-expression|compare-expression'<=>'shift-expression
      enterRuleAltList: shift-expression|compare-expression'<=>'shift-expression
        enterLabeledAlt: shift-expression
          enterAlternative: shift-expression
            enterElement: shift-expression
              => element -> {shift-expression}
              enterAtom: shift-expression
                enterRuleref: shift-expression
                exitRuleref: shift-expression
              exitAtom: shift-expression
            exitElement: shift-expression
          exitAlternative: shift-expression
        => elements -> ['{shift-expression}']
            => alternative -> {shift-expression}
        exitLabeledAlt: shift-expression
        enterLabeledAlt: compare-expression'<=>'shift-expression
          enterAlternative: compare-expression'<=>'shift-expression
            enterElement: compare-expression
              => element -> {compare-expression}
              enterAtom: compare-expression
                enterRuleref: compare-expression
                exitRuleref: compare-expression
              exitAtom: compare-expression
            exitElement: compare-expression
            enterElement: '<=>'
              => element -> <=>
              enterAtom: '<=>'
                enterTerminal: '<=>'
                exitTerminal: '<=>'
              exitAtom: '<=>'
            exitElement: '<=>'
            enterElement: shift-expression
              => element -> {shift-expression}
              enterAtom: shift-expression
                enterRuleref: shift-expression
                exitRuleref: shift-expression
              exitAtom: shift-expression
            exitElement: shift-expression
          exitAlternative: compare-expression'<=>'shift-expression
        => elements -> ['{compare-expression}', '<=>', '{shift-expression}']
            => alternative -> {compare-expression} <=> {shift-expression}
        exitLabeledAlt: compare-expression'<=>'shift-expression
      exitRuleAltList: shift-expression|compare-expression'<=>'shift-expression
    exitRuleBlock: shift-expression|compare-expression'<=>'shift-expression
  exitRuleSpec: compare-expression:shift-expression|compare-expression'<=>'shift-expression;

  enterRuleSpec: relational-expression:compare-expression|relational-expression'<'compare-expression|relational-expression'>'compare-expression|relational-expression'<='compare-expression|relational-expression'>='compare-expression;
    enterRuleBlock: compare-expression|relational-expression'<'compare-expression|relational-expression'>'compare-expression|relational-expression'<='compare-expression|relational-expression'>='compare-expression
      enterRuleAltList: compare-expression|relational-expression'<'compare-expression|relational-expression'>'compare-expression|relational-expression'<='compare-expression|relational-expression'>='compare-expression
        enterLabeledAlt: compare-expression
          enterAlternative: compare-expression
            enterElement: compare-expression
              => element -> {compare-expression}
              enterAtom: compare-expression
                enterRuleref: compare-expression
                exitRuleref: compare-expression
              exitAtom: compare-expression
            exitElement: compare-expression
          exitAlternative: compare-expression
        => elements -> ['{compare-expression}']
            => alternative -> {compare-expression}
        exitLabeledAlt: compare-expression
        enterLabeledAlt: relational-expression'<'compare-expression
          enterAlternative: relational-expression'<'compare-expression
            enterElement: relational-expression
              => element -> {relational-expression}
              enterAtom: relational-expression
                enterRuleref: relational-expression
                exitRuleref: relational-expression
              exitAtom: relational-expression
            exitElement: relational-expression
            enterElement: '<'
              => element -> <
              enterAtom: '<'
                enterTerminal: '<'
                exitTerminal: '<'
              exitAtom: '<'
            exitElement: '<'
            enterElement: compare-expression
              => element -> {compare-expression}
              enterAtom: compare-expression
                enterRuleref: compare-expression
                exitRuleref: compare-expression
              exitAtom: compare-expression
            exitElement: compare-expression
          exitAlternative: relational-expression'<'compare-expression
        => elements -> ['{relational-expression}', '<', '{compare-expression}']
            => alternative -> {relational-expression} < {compare-expression}
        exitLabeledAlt: relational-expression'<'compare-expression
        enterLabeledAlt: relational-expression'>'compare-expression
          enterAlternative: relational-expression'>'compare-expression
            enterElement: relational-expression
              => element -> {relational-expression}
              enterAtom: relational-expression
                enterRuleref: relational-expression
                exitRuleref: relational-expression
              exitAtom: relational-expression
            exitElement: relational-expression
            enterElement: '>'
              => element -> >
              enterAtom: '>'
                enterTerminal: '>'
                exitTerminal: '>'
              exitAtom: '>'
            exitElement: '>'
            enterElement: compare-expression
              => element -> {compare-expression}
              enterAtom: compare-expression
                enterRuleref: compare-expression
                exitRuleref: compare-expression
              exitAtom: compare-expression
            exitElement: compare-expression
          exitAlternative: relational-expression'>'compare-expression
        => elements -> ['{relational-expression}', '>', '{compare-expression}']
            => alternative -> {relational-expression} > {compare-expression}
        exitLabeledAlt: relational-expression'>'compare-expression
        enterLabeledAlt: relational-expression'<='compare-expression
          enterAlternative: relational-expression'<='compare-expression
            enterElement: relational-expression
              => element -> {relational-expression}
              enterAtom: relational-expression
                enterRuleref: relational-expression
                exitRuleref: relational-expression
              exitAtom: relational-expression
            exitElement: relational-expression
            enterElement: '<='
              => element -> <=
              enterAtom: '<='
                enterTerminal: '<='
                exitTerminal: '<='
              exitAtom: '<='
            exitElement: '<='
            enterElement: compare-expression
              => element -> {compare-expression}
              enterAtom: compare-expression
                enterRuleref: compare-expression
                exitRuleref: compare-expression
              exitAtom: compare-expression
            exitElement: compare-expression
          exitAlternative: relational-expression'<='compare-expression
        => elements -> ['{relational-expression}', '<=', '{compare-expression}']
            => alternative -> {relational-expression} <= {compare-expression}
        exitLabeledAlt: relational-expression'<='compare-expression
        enterLabeledAlt: relational-expression'>='compare-expression
          enterAlternative: relational-expression'>='compare-expression
            enterElement: relational-expression
              => element -> {relational-expression}
              enterAtom: relational-expression
                enterRuleref: relational-expression
                exitRuleref: relational-expression
              exitAtom: relational-expression
            exitElement: relational-expression
            enterElement: '>='
              => element -> >=
              enterAtom: '>='
                enterTerminal: '>='
                exitTerminal: '>='
              exitAtom: '>='
            exitElement: '>='
            enterElement: compare-expression
              => element -> {compare-expression}
              enterAtom: compare-expression
                enterRuleref: compare-expression
                exitRuleref: compare-expression
              exitAtom: compare-expression
            exitElement: compare-expression
          exitAlternative: relational-expression'>='compare-expression
        => elements -> ['{relational-expression}', '>=', '{compare-expression}']
            => alternative -> {relational-expression} >= {compare-expression}
        exitLabeledAlt: relational-expression'>='compare-expression
      exitRuleAltList: compare-expression|relational-expression'<'compare-expression|relational-expression'>'compare-expression|relational-expression'<='compare-expression|relational-expression'>='compare-expression
    exitRuleBlock: compare-expression|relational-expression'<'compare-expression|relational-expression'>'compare-expression|relational-expression'<='compare-expression|relational-expression'>='compare-expression
  exitRuleSpec: relational-expression:compare-expression|relational-expression'<'compare-expression|relational-expression'>'compare-expression|relational-expression'<='compare-expression|relational-expression'>='compare-expression;

  enterRuleSpec: equality-expression:relational-expression|equality-expression'=='relational-expression|equality-expression'!='relational-expression;
    enterRuleBlock: relational-expression|equality-expression'=='relational-expression|equality-expression'!='relational-expression
      enterRuleAltList: relational-expression|equality-expression'=='relational-expression|equality-expression'!='relational-expression
        enterLabeledAlt: relational-expression
          enterAlternative: relational-expression
            enterElement: relational-expression
              => element -> {relational-expression}
              enterAtom: relational-expression
                enterRuleref: relational-expression
                exitRuleref: relational-expression
              exitAtom: relational-expression
            exitElement: relational-expression
          exitAlternative: relational-expression
        => elements -> ['{relational-expression}']
            => alternative -> {relational-expression}
        exitLabeledAlt: relational-expression
        enterLabeledAlt: equality-expression'=='relational-expression
          enterAlternative: equality-expression'=='relational-expression
            enterElement: equality-expression
              => element -> {equality-expression}
              enterAtom: equality-expression
                enterRuleref: equality-expression
                exitRuleref: equality-expression
              exitAtom: equality-expression
            exitElement: equality-expression
            enterElement: '=='
              => element -> ==
              enterAtom: '=='
                enterTerminal: '=='
                exitTerminal: '=='
              exitAtom: '=='
            exitElement: '=='
            enterElement: relational-expression
              => element -> {relational-expression}
              enterAtom: relational-expression
                enterRuleref: relational-expression
                exitRuleref: relational-expression
              exitAtom: relational-expression
            exitElement: relational-expression
          exitAlternative: equality-expression'=='relational-expression
        => elements -> ['{equality-expression}', '==', '{relational-expression}']
            => alternative -> {equality-expression} == {relational-expression}
        exitLabeledAlt: equality-expression'=='relational-expression
        enterLabeledAlt: equality-expression'!='relational-expression
          enterAlternative: equality-expression'!='relational-expression
            enterElement: equality-expression
              => element -> {equality-expression}
              enterAtom: equality-expression
                enterRuleref: equality-expression
                exitRuleref: equality-expression
              exitAtom: equality-expression
            exitElement: equality-expression
            enterElement: '!='
              => element -> !=
              enterAtom: '!='
                enterTerminal: '!='
                exitTerminal: '!='
              exitAtom: '!='
            exitElement: '!='
            enterElement: relational-expression
              => element -> {relational-expression}
              enterAtom: relational-expression
                enterRuleref: relational-expression
                exitRuleref: relational-expression
              exitAtom: relational-expression
            exitElement: relational-expression
          exitAlternative: equality-expression'!='relational-expression
        => elements -> ['{equality-expression}', '!=', '{relational-expression}']
            => alternative -> {equality-expression} != {relational-expression}
        exitLabeledAlt: equality-expression'!='relational-expression
      exitRuleAltList: relational-expression|equality-expression'=='relational-expression|equality-expression'!='relational-expression
    exitRuleBlock: relational-expression|equality-expression'=='relational-expression|equality-expression'!='relational-expression
  exitRuleSpec: equality-expression:relational-expression|equality-expression'=='relational-expression|equality-expression'!='relational-expression;

  enterRuleSpec: and-expression:equality-expression|and-expression'&'equality-expression;
    enterRuleBlock: equality-expression|and-expression'&'equality-expression
      enterRuleAltList: equality-expression|and-expression'&'equality-expression
        enterLabeledAlt: equality-expression
          enterAlternative: equality-expression
            enterElement: equality-expression
              => element -> {equality-expression}
              enterAtom: equality-expression
                enterRuleref: equality-expression
                exitRuleref: equality-expression
              exitAtom: equality-expression
            exitElement: equality-expression
          exitAlternative: equality-expression
        => elements -> ['{equality-expression}']
            => alternative -> {equality-expression}
        exitLabeledAlt: equality-expression
        enterLabeledAlt: and-expression'&'equality-expression
          enterAlternative: and-expression'&'equality-expression
            enterElement: and-expression
              => element -> {and-expression}
              enterAtom: and-expression
                enterRuleref: and-expression
                exitRuleref: and-expression
              exitAtom: and-expression
            exitElement: and-expression
            enterElement: '&'
              => element -> &
              enterAtom: '&'
                enterTerminal: '&'
                exitTerminal: '&'
              exitAtom: '&'
            exitElement: '&'
            enterElement: equality-expression
              => element -> {equality-expression}
              enterAtom: equality-expression
                enterRuleref: equality-expression
                exitRuleref: equality-expression
              exitAtom: equality-expression
            exitElement: equality-expression
          exitAlternative: and-expression'&'equality-expression
        => elements -> ['{and-expression}', '&', '{equality-expression}']
            => alternative -> {and-expression} & {equality-expression}
        exitLabeledAlt: and-expression'&'equality-expression
      exitRuleAltList: equality-expression|and-expression'&'equality-expression
    exitRuleBlock: equality-expression|and-expression'&'equality-expression
  exitRuleSpec: and-expression:equality-expression|and-expression'&'equality-expression;

  enterRuleSpec: exclusive-or-expression:and-expression|exclusive-or-expression'^'and-expression;
    enterRuleBlock: and-expression|exclusive-or-expression'^'and-expression
      enterRuleAltList: and-expression|exclusive-or-expression'^'and-expression
        enterLabeledAlt: and-expression
          enterAlternative: and-expression
            enterElement: and-expression
              => element -> {and-expression}
              enterAtom: and-expression
                enterRuleref: and-expression
                exitRuleref: and-expression
              exitAtom: and-expression
            exitElement: and-expression
          exitAlternative: and-expression
        => elements -> ['{and-expression}']
            => alternative -> {and-expression}
        exitLabeledAlt: and-expression
        enterLabeledAlt: exclusive-or-expression'^'and-expression
          enterAlternative: exclusive-or-expression'^'and-expression
            enterElement: exclusive-or-expression
              => element -> {exclusive-or-expression}
              enterAtom: exclusive-or-expression
                enterRuleref: exclusive-or-expression
                exitRuleref: exclusive-or-expression
              exitAtom: exclusive-or-expression
            exitElement: exclusive-or-expression
            enterElement: '^'
              => element -> ^
              enterAtom: '^'
                enterTerminal: '^'
                exitTerminal: '^'
              exitAtom: '^'
            exitElement: '^'
            enterElement: and-expression
              => element -> {and-expression}
              enterAtom: and-expression
                enterRuleref: and-expression
                exitRuleref: and-expression
              exitAtom: and-expression
            exitElement: and-expression
          exitAlternative: exclusive-or-expression'^'and-expression
        => elements -> ['{exclusive-or-expression}', '^', '{and-expression}']
            => alternative -> {exclusive-or-expression} ^ {and-expression}
        exitLabeledAlt: exclusive-or-expression'^'and-expression
      exitRuleAltList: and-expression|exclusive-or-expression'^'and-expression
    exitRuleBlock: and-expression|exclusive-or-expression'^'and-expression
  exitRuleSpec: exclusive-or-expression:and-expression|exclusive-or-expression'^'and-expression;

  enterRuleSpec: inclusive-or-expression:exclusive-or-expression|inclusive-or-expression'|'exclusive-or-expression;
    enterRuleBlock: exclusive-or-expression|inclusive-or-expression'|'exclusive-or-expression
      enterRuleAltList: exclusive-or-expression|inclusive-or-expression'|'exclusive-or-expression
        enterLabeledAlt: exclusive-or-expression
          enterAlternative: exclusive-or-expression
            enterElement: exclusive-or-expression
              => element -> {exclusive-or-expression}
              enterAtom: exclusive-or-expression
                enterRuleref: exclusive-or-expression
                exitRuleref: exclusive-or-expression
              exitAtom: exclusive-or-expression
            exitElement: exclusive-or-expression
          exitAlternative: exclusive-or-expression
        => elements -> ['{exclusive-or-expression}']
            => alternative -> {exclusive-or-expression}
        exitLabeledAlt: exclusive-or-expression
        enterLabeledAlt: inclusive-or-expression'|'exclusive-or-expression
          enterAlternative: inclusive-or-expression'|'exclusive-or-expression
            enterElement: inclusive-or-expression
              => element -> {inclusive-or-expression}
              enterAtom: inclusive-or-expression
                enterRuleref: inclusive-or-expression
                exitRuleref: inclusive-or-expression
              exitAtom: inclusive-or-expression
            exitElement: inclusive-or-expression
            enterElement: '|'
              => element -> |
              enterAtom: '|'
                enterTerminal: '|'
                exitTerminal: '|'
              exitAtom: '|'
            exitElement: '|'
            enterElement: exclusive-or-expression
              => element -> {exclusive-or-expression}
              enterAtom: exclusive-or-expression
                enterRuleref: exclusive-or-expression
                exitRuleref: exclusive-or-expression
              exitAtom: exclusive-or-expression
            exitElement: exclusive-or-expression
          exitAlternative: inclusive-or-expression'|'exclusive-or-expression
        => elements -> ['{inclusive-or-expression}', '|', '{exclusive-or-expression}']
            => alternative -> {inclusive-or-expression} | {exclusive-or-expression}
        exitLabeledAlt: inclusive-or-expression'|'exclusive-or-expression
      exitRuleAltList: exclusive-or-expression|inclusive-or-expression'|'exclusive-or-expression
    exitRuleBlock: exclusive-or-expression|inclusive-or-expression'|'exclusive-or-expression
  exitRuleSpec: inclusive-or-expression:exclusive-or-expression|inclusive-or-expression'|'exclusive-or-expression;

  enterRuleSpec: logical-and-expression:inclusive-or-expression|logical-and-expression'&&'inclusive-or-expression;
    enterRuleBlock: inclusive-or-expression|logical-and-expression'&&'inclusive-or-expression
      enterRuleAltList: inclusive-or-expression|logical-and-expression'&&'inclusive-or-expression
        enterLabeledAlt: inclusive-or-expression
          enterAlternative: inclusive-or-expression
            enterElement: inclusive-or-expression
              => element -> {inclusive-or-expression}
              enterAtom: inclusive-or-expression
                enterRuleref: inclusive-or-expression
                exitRuleref: inclusive-or-expression
              exitAtom: inclusive-or-expression
            exitElement: inclusive-or-expression
          exitAlternative: inclusive-or-expression
        => elements -> ['{inclusive-or-expression}']
            => alternative -> {inclusive-or-expression}
        exitLabeledAlt: inclusive-or-expression
        enterLabeledAlt: logical-and-expression'&&'inclusive-or-expression
          enterAlternative: logical-and-expression'&&'inclusive-or-expression
            enterElement: logical-and-expression
              => element -> {logical-and-expression}
              enterAtom: logical-and-expression
                enterRuleref: logical-and-expression
                exitRuleref: logical-and-expression
              exitAtom: logical-and-expression
            exitElement: logical-and-expression
            enterElement: '&&'
              => element -> &&
              enterAtom: '&&'
                enterTerminal: '&&'
                exitTerminal: '&&'
              exitAtom: '&&'
            exitElement: '&&'
            enterElement: inclusive-or-expression
              => element -> {inclusive-or-expression}
              enterAtom: inclusive-or-expression
                enterRuleref: inclusive-or-expression
                exitRuleref: inclusive-or-expression
              exitAtom: inclusive-or-expression
            exitElement: inclusive-or-expression
          exitAlternative: logical-and-expression'&&'inclusive-or-expression
        => elements -> ['{logical-and-expression}', '&&', '{inclusive-or-expression}']
            => alternative -> {logical-and-expression} && {inclusive-or-expression}
        exitLabeledAlt: logical-and-expression'&&'inclusive-or-expression
      exitRuleAltList: inclusive-or-expression|logical-and-expression'&&'inclusive-or-expression
    exitRuleBlock: inclusive-or-expression|logical-and-expression'&&'inclusive-or-expression
  exitRuleSpec: logical-and-expression:inclusive-or-expression|logical-and-expression'&&'inclusive-or-expression;

  enterRuleSpec: logical-or-expression:logical-and-expression|logical-or-expression'||'logical-and-expression;
    enterRuleBlock: logical-and-expression|logical-or-expression'||'logical-and-expression
      enterRuleAltList: logical-and-expression|logical-or-expression'||'logical-and-expression
        enterLabeledAlt: logical-and-expression
          enterAlternative: logical-and-expression
            enterElement: logical-and-expression
              => element -> {logical-and-expression}
              enterAtom: logical-and-expression
                enterRuleref: logical-and-expression
                exitRuleref: logical-and-expression
              exitAtom: logical-and-expression
            exitElement: logical-and-expression
          exitAlternative: logical-and-expression
        => elements -> ['{logical-and-expression}']
            => alternative -> {logical-and-expression}
        exitLabeledAlt: logical-and-expression
        enterLabeledAlt: logical-or-expression'||'logical-and-expression
          enterAlternative: logical-or-expression'||'logical-and-expression
            enterElement: logical-or-expression
              => element -> {logical-or-expression}
              enterAtom: logical-or-expression
                enterRuleref: logical-or-expression
                exitRuleref: logical-or-expression
              exitAtom: logical-or-expression
            exitElement: logical-or-expression
            enterElement: '||'
              => element -> ||
              enterAtom: '||'
                enterTerminal: '||'
                exitTerminal: '||'
              exitAtom: '||'
            exitElement: '||'
            enterElement: logical-and-expression
              => element -> {logical-and-expression}
              enterAtom: logical-and-expression
                enterRuleref: logical-and-expression
                exitRuleref: logical-and-expression
              exitAtom: logical-and-expression
            exitElement: logical-and-expression
          exitAlternative: logical-or-expression'||'logical-and-expression
        => elements -> ['{logical-or-expression}', '||', '{logical-and-expression}']
            => alternative -> {logical-or-expression} || {logical-and-expression}
        exitLabeledAlt: logical-or-expression'||'logical-and-expression
      exitRuleAltList: logical-and-expression|logical-or-expression'||'logical-and-expression
    exitRuleBlock: logical-and-expression|logical-or-expression'||'logical-and-expression
  exitRuleSpec: logical-or-expression:logical-and-expression|logical-or-expression'||'logical-and-expression;

  enterRuleSpec: conditional-expression:logical-or-expression|logical-or-expression'?'expression':'assignment-expression;
    enterRuleBlock: logical-or-expression|logical-or-expression'?'expression':'assignment-expression
      enterRuleAltList: logical-or-expression|logical-or-expression'?'expression':'assignment-expression
        enterLabeledAlt: logical-or-expression
          enterAlternative: logical-or-expression
            enterElement: logical-or-expression
              => element -> {logical-or-expression}
              enterAtom: logical-or-expression
                enterRuleref: logical-or-expression
                exitRuleref: logical-or-expression
              exitAtom: logical-or-expression
            exitElement: logical-or-expression
          exitAlternative: logical-or-expression
        => elements -> ['{logical-or-expression}']
            => alternative -> {logical-or-expression}
        exitLabeledAlt: logical-or-expression
        enterLabeledAlt: logical-or-expression'?'expression':'assignment-expression
          enterAlternative: logical-or-expression'?'expression':'assignment-expression
            enterElement: logical-or-expression
              => element -> {logical-or-expression}
              enterAtom: logical-or-expression
                enterRuleref: logical-or-expression
                exitRuleref: logical-or-expression
              exitAtom: logical-or-expression
            exitElement: logical-or-expression
            enterElement: '?'
              => element -> ?
              enterAtom: '?'
                enterTerminal: '?'
                exitTerminal: '?'
              exitAtom: '?'
            exitElement: '?'
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
            enterElement: ':'
              => element -> :
              enterAtom: ':'
                enterTerminal: ':'
                exitTerminal: ':'
              exitAtom: ':'
            exitElement: ':'
            enterElement: assignment-expression
              => element -> {assignment-expression}
              enterAtom: assignment-expression
                enterRuleref: assignment-expression
                exitRuleref: assignment-expression
              exitAtom: assignment-expression
            exitElement: assignment-expression
          exitAlternative: logical-or-expression'?'expression':'assignment-expression
        => elements -> ['{logical-or-expression}', '?', '{expression}', ':', '{assignment-expression}']
            => alternative -> {logical-or-expression} ? {expression} : {assignment-expression}
        exitLabeledAlt: logical-or-expression'?'expression':'assignment-expression
      exitRuleAltList: logical-or-expression|logical-or-expression'?'expression':'assignment-expression
    exitRuleBlock: logical-or-expression|logical-or-expression'?'expression':'assignment-expression
  exitRuleSpec: conditional-expression:logical-or-expression|logical-or-expression'?'expression':'assignment-expression;

  enterRuleSpec: yield-expression:'co_yield'assignment-expression|'co_yield'braced-init-list;
    enterRuleBlock: 'co_yield'assignment-expression|'co_yield'braced-init-list
      enterRuleAltList: 'co_yield'assignment-expression|'co_yield'braced-init-list
        enterLabeledAlt: 'co_yield'assignment-expression
          enterAlternative: 'co_yield'assignment-expression
            enterElement: 'co_yield'
              => element -> co_yield
              enterAtom: 'co_yield'
                enterTerminal: 'co_yield'
                exitTerminal: 'co_yield'
              exitAtom: 'co_yield'
            exitElement: 'co_yield'
            enterElement: assignment-expression
              => element -> {assignment-expression}
              enterAtom: assignment-expression
                enterRuleref: assignment-expression
                exitRuleref: assignment-expression
              exitAtom: assignment-expression
            exitElement: assignment-expression
          exitAlternative: 'co_yield'assignment-expression
        => elements -> ['co_yield', '{assignment-expression}']
            => alternative -> co_yield {assignment-expression}
        exitLabeledAlt: 'co_yield'assignment-expression
        enterLabeledAlt: 'co_yield'braced-init-list
          enterAlternative: 'co_yield'braced-init-list
            enterElement: 'co_yield'
              => element -> co_yield
              enterAtom: 'co_yield'
                enterTerminal: 'co_yield'
                exitTerminal: 'co_yield'
              exitAtom: 'co_yield'
            exitElement: 'co_yield'
            enterElement: braced-init-list
              => element -> {braced-init-list}
              enterAtom: braced-init-list
                enterRuleref: braced-init-list
                exitRuleref: braced-init-list
              exitAtom: braced-init-list
            exitElement: braced-init-list
          exitAlternative: 'co_yield'braced-init-list
        => elements -> ['co_yield', '{braced-init-list}']
            => alternative -> co_yield {braced-init-list}
        exitLabeledAlt: 'co_yield'braced-init-list
      exitRuleAltList: 'co_yield'assignment-expression|'co_yield'braced-init-list
    exitRuleBlock: 'co_yield'assignment-expression|'co_yield'braced-init-list
  exitRuleSpec: yield-expression:'co_yield'assignment-expression|'co_yield'braced-init-list;

  enterRuleSpec: throw-expression:'throw'assignment-expression?;
    enterRuleBlock: 'throw'assignment-expression?
      enterRuleAltList: 'throw'assignment-expression?
        enterLabeledAlt: 'throw'assignment-expression?
          enterAlternative: 'throw'assignment-expression?
            enterElement: 'throw'
              => element -> throw
              enterAtom: 'throw'
                enterTerminal: 'throw'
                exitTerminal: 'throw'
              exitAtom: 'throw'
            exitElement: 'throw'
            enterElement: assignment-expression?
              => element -> [assignment-expression]
              enterAtom: assignment-expression
                enterRuleref: assignment-expression
                exitRuleref: assignment-expression
              exitAtom: assignment-expression
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: assignment-expression?
          exitAlternative: 'throw'assignment-expression?
        => elements -> ['throw', '[assignment-expression]']
            => alternative -> throw [assignment-expression]
        exitLabeledAlt: 'throw'assignment-expression?
      exitRuleAltList: 'throw'assignment-expression?
    exitRuleBlock: 'throw'assignment-expression?
  exitRuleSpec: throw-expression:'throw'assignment-expression?;

  enterRuleSpec: assignment-expression:conditional-expression|yield-expression|throw-expression|logical-or-expressionassignment-operatorinitializer-clause;
    enterRuleBlock: conditional-expression|yield-expression|throw-expression|logical-or-expressionassignment-operatorinitializer-clause
      enterRuleAltList: conditional-expression|yield-expression|throw-expression|logical-or-expressionassignment-operatorinitializer-clause
        enterLabeledAlt: conditional-expression
          enterAlternative: conditional-expression
            enterElement: conditional-expression
              => element -> {conditional-expression}
              enterAtom: conditional-expression
                enterRuleref: conditional-expression
                exitRuleref: conditional-expression
              exitAtom: conditional-expression
            exitElement: conditional-expression
          exitAlternative: conditional-expression
        => elements -> ['{conditional-expression}']
            => alternative -> {conditional-expression}
        exitLabeledAlt: conditional-expression
        enterLabeledAlt: yield-expression
          enterAlternative: yield-expression
            enterElement: yield-expression
              => element -> {yield-expression}
              enterAtom: yield-expression
                enterRuleref: yield-expression
                exitRuleref: yield-expression
              exitAtom: yield-expression
            exitElement: yield-expression
          exitAlternative: yield-expression
        => elements -> ['{yield-expression}']
            => alternative -> {yield-expression}
        exitLabeledAlt: yield-expression
        enterLabeledAlt: throw-expression
          enterAlternative: throw-expression
            enterElement: throw-expression
              => element -> {throw-expression}
              enterAtom: throw-expression
                enterRuleref: throw-expression
                exitRuleref: throw-expression
              exitAtom: throw-expression
            exitElement: throw-expression
          exitAlternative: throw-expression
        => elements -> ['{throw-expression}']
            => alternative -> {throw-expression}
        exitLabeledAlt: throw-expression
        enterLabeledAlt: logical-or-expressionassignment-operatorinitializer-clause
          enterAlternative: logical-or-expressionassignment-operatorinitializer-clause
            enterElement: logical-or-expression
              => element -> {logical-or-expression}
              enterAtom: logical-or-expression
                enterRuleref: logical-or-expression
                exitRuleref: logical-or-expression
              exitAtom: logical-or-expression
            exitElement: logical-or-expression
            enterElement: assignment-operator
              => element -> {assignment-operator}
              enterAtom: assignment-operator
                enterRuleref: assignment-operator
                exitRuleref: assignment-operator
              exitAtom: assignment-operator
            exitElement: assignment-operator
            enterElement: initializer-clause
              => element -> {initializer-clause}
              enterAtom: initializer-clause
                enterRuleref: initializer-clause
                exitRuleref: initializer-clause
              exitAtom: initializer-clause
            exitElement: initializer-clause
          exitAlternative: logical-or-expressionassignment-operatorinitializer-clause
        => elements -> ['{logical-or-expression}', '{assignment-operator}', '{initializer-clause}']
            => alternative -> {logical-or-expression} {assignment-operator} {initializer-clause}
        exitLabeledAlt: logical-or-expressionassignment-operatorinitializer-clause
      exitRuleAltList: conditional-expression|yield-expression|throw-expression|logical-or-expressionassignment-operatorinitializer-clause
    exitRuleBlock: conditional-expression|yield-expression|throw-expression|logical-or-expressionassignment-operatorinitializer-clause
  exitRuleSpec: assignment-expression:conditional-expression|yield-expression|throw-expression|logical-or-expressionassignment-operatorinitializer-clause;

  enterRuleSpec: assignment-operator:'='|'*='|'/='|'%='|'+='|'-='|'>>='|'<<='|'&='|'^='|'|=';
    enterRuleBlock: '='|'*='|'/='|'%='|'+='|'-='|'>>='|'<<='|'&='|'^='|'|='
      enterRuleAltList: '='|'*='|'/='|'%='|'+='|'-='|'>>='|'<<='|'&='|'^='|'|='
        enterLabeledAlt: '='
          enterAlternative: '='
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
          exitAlternative: '='
        => elements -> ['=']
            => alternative -> =
        exitLabeledAlt: '='
        enterLabeledAlt: '*='
          enterAlternative: '*='
            enterElement: '*='
              => element -> *=
              enterAtom: '*='
                enterTerminal: '*='
                exitTerminal: '*='
              exitAtom: '*='
            exitElement: '*='
          exitAlternative: '*='
        => elements -> ['*=']
            => alternative -> *=
        exitLabeledAlt: '*='
        enterLabeledAlt: '/='
          enterAlternative: '/='
            enterElement: '/='
              => element -> /=
              enterAtom: '/='
                enterTerminal: '/='
                exitTerminal: '/='
              exitAtom: '/='
            exitElement: '/='
          exitAlternative: '/='
        => elements -> ['/=']
            => alternative -> /=
        exitLabeledAlt: '/='
        enterLabeledAlt: '%='
          enterAlternative: '%='
            enterElement: '%='
              => element -> %=
              enterAtom: '%='
                enterTerminal: '%='
                exitTerminal: '%='
              exitAtom: '%='
            exitElement: '%='
          exitAlternative: '%='
        => elements -> ['%=']
            => alternative -> %=
        exitLabeledAlt: '%='
        enterLabeledAlt: '+='
          enterAlternative: '+='
            enterElement: '+='
              => element -> +=
              enterAtom: '+='
                enterTerminal: '+='
                exitTerminal: '+='
              exitAtom: '+='
            exitElement: '+='
          exitAlternative: '+='
        => elements -> ['+=']
            => alternative -> +=
        exitLabeledAlt: '+='
        enterLabeledAlt: '-='
          enterAlternative: '-='
            enterElement: '-='
              => element -> -=
              enterAtom: '-='
                enterTerminal: '-='
                exitTerminal: '-='
              exitAtom: '-='
            exitElement: '-='
          exitAlternative: '-='
        => elements -> ['-=']
            => alternative -> -=
        exitLabeledAlt: '-='
        enterLabeledAlt: '>>='
          enterAlternative: '>>='
            enterElement: '>>='
              => element -> >>=
              enterAtom: '>>='
                enterTerminal: '>>='
                exitTerminal: '>>='
              exitAtom: '>>='
            exitElement: '>>='
          exitAlternative: '>>='
        => elements -> ['>>=']
            => alternative -> >>=
        exitLabeledAlt: '>>='
        enterLabeledAlt: '<<='
          enterAlternative: '<<='
            enterElement: '<<='
              => element -> <<=
              enterAtom: '<<='
                enterTerminal: '<<='
                exitTerminal: '<<='
              exitAtom: '<<='
            exitElement: '<<='
          exitAlternative: '<<='
        => elements -> ['<<=']
            => alternative -> <<=
        exitLabeledAlt: '<<='
        enterLabeledAlt: '&='
          enterAlternative: '&='
            enterElement: '&='
              => element -> &=
              enterAtom: '&='
                enterTerminal: '&='
                exitTerminal: '&='
              exitAtom: '&='
            exitElement: '&='
          exitAlternative: '&='
        => elements -> ['&=']
            => alternative -> &=
        exitLabeledAlt: '&='
        enterLabeledAlt: '^='
          enterAlternative: '^='
            enterElement: '^='
              => element -> ^=
              enterAtom: '^='
                enterTerminal: '^='
                exitTerminal: '^='
              exitAtom: '^='
            exitElement: '^='
          exitAlternative: '^='
        => elements -> ['^=']
            => alternative -> ^=
        exitLabeledAlt: '^='
        enterLabeledAlt: '|='
          enterAlternative: '|='
            enterElement: '|='
              => element -> |=
              enterAtom: '|='
                enterTerminal: '|='
                exitTerminal: '|='
              exitAtom: '|='
            exitElement: '|='
          exitAlternative: '|='
        => elements -> ['|=']
            => alternative -> |=
        exitLabeledAlt: '|='
      exitRuleAltList: '='|'*='|'/='|'%='|'+='|'-='|'>>='|'<<='|'&='|'^='|'|='
    exitRuleBlock: '='|'*='|'/='|'%='|'+='|'-='|'>>='|'<<='|'&='|'^='|'|='
  exitRuleSpec: assignment-operator:'='|'*='|'/='|'%='|'+='|'-='|'>>='|'<<='|'&='|'^='|'|=';

  enterRuleSpec: expression:assignment-expression|expression','assignment-expression;
    enterRuleBlock: assignment-expression|expression','assignment-expression
      enterRuleAltList: assignment-expression|expression','assignment-expression
        enterLabeledAlt: assignment-expression
          enterAlternative: assignment-expression
            enterElement: assignment-expression
              => element -> {assignment-expression}
              enterAtom: assignment-expression
                enterRuleref: assignment-expression
                exitRuleref: assignment-expression
              exitAtom: assignment-expression
            exitElement: assignment-expression
          exitAlternative: assignment-expression
        => elements -> ['{assignment-expression}']
            => alternative -> {assignment-expression}
        exitLabeledAlt: assignment-expression
        enterLabeledAlt: expression','assignment-expression
          enterAlternative: expression','assignment-expression
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: assignment-expression
              => element -> {assignment-expression}
              enterAtom: assignment-expression
                enterRuleref: assignment-expression
                exitRuleref: assignment-expression
              exitAtom: assignment-expression
            exitElement: assignment-expression
          exitAlternative: expression','assignment-expression
        => elements -> ['{expression}', ',', '{assignment-expression}']
            => alternative -> {expression} , {assignment-expression}
        exitLabeledAlt: expression','assignment-expression
      exitRuleAltList: assignment-expression|expression','assignment-expression
    exitRuleBlock: assignment-expression|expression','assignment-expression
  exitRuleSpec: expression:assignment-expression|expression','assignment-expression;

  enterRuleSpec: constant-expression:conditional-expression;
    enterRuleBlock: conditional-expression
      enterRuleAltList: conditional-expression
        enterLabeledAlt: conditional-expression
          enterAlternative: conditional-expression
            enterElement: conditional-expression
              => element -> {conditional-expression}
              enterAtom: conditional-expression
                enterRuleref: conditional-expression
                exitRuleref: conditional-expression
              exitAtom: conditional-expression
            exitElement: conditional-expression
          exitAlternative: conditional-expression
        => elements -> ['{conditional-expression}']
            => alternative -> {conditional-expression}
        exitLabeledAlt: conditional-expression
      exitRuleAltList: conditional-expression
    exitRuleBlock: conditional-expression
  exitRuleSpec: constant-expression:conditional-expression;

  enterRuleSpec: statement:labeled-statement|attribute-specifier*expression-statement|attribute-specifier*compound-statement|attribute-specifier*selection-statement|attribute-specifier*iteration-statement|attribute-specifier*jump-statement|declaration-statement|attribute-specifier*try-block;
    enterRuleBlock: labeled-statement|attribute-specifier*expression-statement|attribute-specifier*compound-statement|attribute-specifier*selection-statement|attribute-specifier*iteration-statement|attribute-specifier*jump-statement|declaration-statement|attribute-specifier*try-block
      enterRuleAltList: labeled-statement|attribute-specifier*expression-statement|attribute-specifier*compound-statement|attribute-specifier*selection-statement|attribute-specifier*iteration-statement|attribute-specifier*jump-statement|declaration-statement|attribute-specifier*try-block
        enterLabeledAlt: labeled-statement
          enterAlternative: labeled-statement
            enterElement: labeled-statement
              => element -> {labeled-statement}
              enterAtom: labeled-statement
                enterRuleref: labeled-statement
                exitRuleref: labeled-statement
              exitAtom: labeled-statement
            exitElement: labeled-statement
          exitAlternative: labeled-statement
        => elements -> ['{labeled-statement}']
            => alternative -> {labeled-statement}
        exitLabeledAlt: labeled-statement
        enterLabeledAlt: attribute-specifier*expression-statement
          enterAlternative: attribute-specifier*expression-statement
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: expression-statement
              => element -> {expression-statement}
              enterAtom: expression-statement
                enterRuleref: expression-statement
                exitRuleref: expression-statement
              exitAtom: expression-statement
            exitElement: expression-statement
          exitAlternative: attribute-specifier*expression-statement
        => elements -> ['[attribute-specifier]...', '{expression-statement}']
            => alternative -> [attribute-specifier]... {expression-statement}
        exitLabeledAlt: attribute-specifier*expression-statement
        enterLabeledAlt: attribute-specifier*compound-statement
          enterAlternative: attribute-specifier*compound-statement
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: compound-statement
              => element -> {compound-statement}
              enterAtom: compound-statement
                enterRuleref: compound-statement
                exitRuleref: compound-statement
              exitAtom: compound-statement
            exitElement: compound-statement
          exitAlternative: attribute-specifier*compound-statement
        => elements -> ['[attribute-specifier]...', '{compound-statement}']
            => alternative -> [attribute-specifier]... {compound-statement}
        exitLabeledAlt: attribute-specifier*compound-statement
        enterLabeledAlt: attribute-specifier*selection-statement
          enterAlternative: attribute-specifier*selection-statement
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: selection-statement
              => element -> {selection-statement}
              enterAtom: selection-statement
                enterRuleref: selection-statement
                exitRuleref: selection-statement
              exitAtom: selection-statement
            exitElement: selection-statement
          exitAlternative: attribute-specifier*selection-statement
        => elements -> ['[attribute-specifier]...', '{selection-statement}']
            => alternative -> [attribute-specifier]... {selection-statement}
        exitLabeledAlt: attribute-specifier*selection-statement
        enterLabeledAlt: attribute-specifier*iteration-statement
          enterAlternative: attribute-specifier*iteration-statement
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: iteration-statement
              => element -> {iteration-statement}
              enterAtom: iteration-statement
                enterRuleref: iteration-statement
                exitRuleref: iteration-statement
              exitAtom: iteration-statement
            exitElement: iteration-statement
          exitAlternative: attribute-specifier*iteration-statement
        => elements -> ['[attribute-specifier]...', '{iteration-statement}']
            => alternative -> [attribute-specifier]... {iteration-statement}
        exitLabeledAlt: attribute-specifier*iteration-statement
        enterLabeledAlt: attribute-specifier*jump-statement
          enterAlternative: attribute-specifier*jump-statement
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: jump-statement
              => element -> {jump-statement}
              enterAtom: jump-statement
                enterRuleref: jump-statement
                exitRuleref: jump-statement
              exitAtom: jump-statement
            exitElement: jump-statement
          exitAlternative: attribute-specifier*jump-statement
        => elements -> ['[attribute-specifier]...', '{jump-statement}']
            => alternative -> [attribute-specifier]... {jump-statement}
        exitLabeledAlt: attribute-specifier*jump-statement
        enterLabeledAlt: declaration-statement
          enterAlternative: declaration-statement
            enterElement: declaration-statement
              => element -> {declaration-statement}
              enterAtom: declaration-statement
                enterRuleref: declaration-statement
                exitRuleref: declaration-statement
              exitAtom: declaration-statement
            exitElement: declaration-statement
          exitAlternative: declaration-statement
        => elements -> ['{declaration-statement}']
            => alternative -> {declaration-statement}
        exitLabeledAlt: declaration-statement
        enterLabeledAlt: attribute-specifier*try-block
          enterAlternative: attribute-specifier*try-block
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: try-block
              => element -> {try-block}
              enterAtom: try-block
                enterRuleref: try-block
                exitRuleref: try-block
              exitAtom: try-block
            exitElement: try-block
          exitAlternative: attribute-specifier*try-block
        => elements -> ['[attribute-specifier]...', '{try-block}']
            => alternative -> [attribute-specifier]... {try-block}
        exitLabeledAlt: attribute-specifier*try-block
      exitRuleAltList: labeled-statement|attribute-specifier*expression-statement|attribute-specifier*compound-statement|attribute-specifier*selection-statement|attribute-specifier*iteration-statement|attribute-specifier*jump-statement|declaration-statement|attribute-specifier*try-block
    exitRuleBlock: labeled-statement|attribute-specifier*expression-statement|attribute-specifier*compound-statement|attribute-specifier*selection-statement|attribute-specifier*iteration-statement|attribute-specifier*jump-statement|declaration-statement|attribute-specifier*try-block
  exitRuleSpec: statement:labeled-statement|attribute-specifier*expression-statement|attribute-specifier*compound-statement|attribute-specifier*selection-statement|attribute-specifier*iteration-statement|attribute-specifier*jump-statement|declaration-statement|attribute-specifier*try-block;

  enterRuleSpec: init-statement:expression-statement|simple-declaration|alias-declaration;
    enterRuleBlock: expression-statement|simple-declaration|alias-declaration
      enterRuleAltList: expression-statement|simple-declaration|alias-declaration
        enterLabeledAlt: expression-statement
          enterAlternative: expression-statement
            enterElement: expression-statement
              => element -> {expression-statement}
              enterAtom: expression-statement
                enterRuleref: expression-statement
                exitRuleref: expression-statement
              exitAtom: expression-statement
            exitElement: expression-statement
          exitAlternative: expression-statement
        => elements -> ['{expression-statement}']
            => alternative -> {expression-statement}
        exitLabeledAlt: expression-statement
        enterLabeledAlt: simple-declaration
          enterAlternative: simple-declaration
            enterElement: simple-declaration
              => element -> {simple-declaration}
              enterAtom: simple-declaration
                enterRuleref: simple-declaration
                exitRuleref: simple-declaration
              exitAtom: simple-declaration
            exitElement: simple-declaration
          exitAlternative: simple-declaration
        => elements -> ['{simple-declaration}']
            => alternative -> {simple-declaration}
        exitLabeledAlt: simple-declaration
        enterLabeledAlt: alias-declaration
          enterAlternative: alias-declaration
            enterElement: alias-declaration
              => element -> {alias-declaration}
              enterAtom: alias-declaration
                enterRuleref: alias-declaration
                exitRuleref: alias-declaration
              exitAtom: alias-declaration
            exitElement: alias-declaration
          exitAlternative: alias-declaration
        => elements -> ['{alias-declaration}']
            => alternative -> {alias-declaration}
        exitLabeledAlt: alias-declaration
      exitRuleAltList: expression-statement|simple-declaration|alias-declaration
    exitRuleBlock: expression-statement|simple-declaration|alias-declaration
  exitRuleSpec: init-statement:expression-statement|simple-declaration|alias-declaration;

  enterRuleSpec: condition:expression|attribute-specifier*decl-specifier-seqdeclaratorbrace-or-equal-initializer;
    enterRuleBlock: expression|attribute-specifier*decl-specifier-seqdeclaratorbrace-or-equal-initializer
      enterRuleAltList: expression|attribute-specifier*decl-specifier-seqdeclaratorbrace-or-equal-initializer
        enterLabeledAlt: expression
          enterAlternative: expression
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
          exitAlternative: expression
        => elements -> ['{expression}']
            => alternative -> {expression}
        exitLabeledAlt: expression
        enterLabeledAlt: attribute-specifier*decl-specifier-seqdeclaratorbrace-or-equal-initializer
          enterAlternative: attribute-specifier*decl-specifier-seqdeclaratorbrace-or-equal-initializer
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: decl-specifier-seq
              => element -> {decl-specifier-seq}
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
            exitElement: decl-specifier-seq
            enterElement: declarator
              => element -> {declarator}
              enterAtom: declarator
                enterRuleref: declarator
                exitRuleref: declarator
              exitAtom: declarator
            exitElement: declarator
            enterElement: brace-or-equal-initializer
              => element -> {brace-or-equal-initializer}
              enterAtom: brace-or-equal-initializer
                enterRuleref: brace-or-equal-initializer
                exitRuleref: brace-or-equal-initializer
              exitAtom: brace-or-equal-initializer
            exitElement: brace-or-equal-initializer
          exitAlternative: attribute-specifier*decl-specifier-seqdeclaratorbrace-or-equal-initializer
        => elements -> ['[attribute-specifier]...', '{decl-specifier-seq}', '{declarator}', '{brace-or-equal-initializer}']
            => alternative -> [attribute-specifier]... {decl-specifier-seq} {declarator} {brace-or-equal-initializer}
        exitLabeledAlt: attribute-specifier*decl-specifier-seqdeclaratorbrace-or-equal-initializer
      exitRuleAltList: expression|attribute-specifier*decl-specifier-seqdeclaratorbrace-or-equal-initializer
    exitRuleBlock: expression|attribute-specifier*decl-specifier-seqdeclaratorbrace-or-equal-initializer
  exitRuleSpec: condition:expression|attribute-specifier*decl-specifier-seqdeclaratorbrace-or-equal-initializer;

  enterRuleSpec: label:attribute-specifier*identifier':'|attribute-specifier*'case'constant-expression':'|attribute-specifier*'default:';
    enterRuleBlock: attribute-specifier*identifier':'|attribute-specifier*'case'constant-expression':'|attribute-specifier*'default:'
      enterRuleAltList: attribute-specifier*identifier':'|attribute-specifier*'case'constant-expression':'|attribute-specifier*'default:'
        enterLabeledAlt: attribute-specifier*identifier':'
          enterAlternative: attribute-specifier*identifier':'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: ':'
              => element -> :
              enterAtom: ':'
                enterTerminal: ':'
                exitTerminal: ':'
              exitAtom: ':'
            exitElement: ':'
          exitAlternative: attribute-specifier*identifier':'
        => elements -> ['[attribute-specifier]...', '{identifier}', ':']
            => alternative -> [attribute-specifier]... {identifier} :
        exitLabeledAlt: attribute-specifier*identifier':'
        enterLabeledAlt: attribute-specifier*'case'constant-expression':'
          enterAlternative: attribute-specifier*'case'constant-expression':'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: 'case'
              => element -> case
              enterAtom: 'case'
                enterTerminal: 'case'
                exitTerminal: 'case'
              exitAtom: 'case'
            exitElement: 'case'
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
            enterElement: ':'
              => element -> :
              enterAtom: ':'
                enterTerminal: ':'
                exitTerminal: ':'
              exitAtom: ':'
            exitElement: ':'
          exitAlternative: attribute-specifier*'case'constant-expression':'
        => elements -> ['[attribute-specifier]...', 'case', '{constant-expression}', ':']
            => alternative -> [attribute-specifier]... case {constant-expression} :
        exitLabeledAlt: attribute-specifier*'case'constant-expression':'
        enterLabeledAlt: attribute-specifier*'default:'
          enterAlternative: attribute-specifier*'default:'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: 'default:'
              => element -> default:
              enterAtom: 'default:'
                enterTerminal: 'default:'
                exitTerminal: 'default:'
              exitAtom: 'default:'
            exitElement: 'default:'
          exitAlternative: attribute-specifier*'default:'
        => elements -> ['[attribute-specifier]...', 'default:']
            => alternative -> [attribute-specifier]... default:
        exitLabeledAlt: attribute-specifier*'default:'
      exitRuleAltList: attribute-specifier*identifier':'|attribute-specifier*'case'constant-expression':'|attribute-specifier*'default:'
    exitRuleBlock: attribute-specifier*identifier':'|attribute-specifier*'case'constant-expression':'|attribute-specifier*'default:'
  exitRuleSpec: label:attribute-specifier*identifier':'|attribute-specifier*'case'constant-expression':'|attribute-specifier*'default:';

  enterRuleSpec: labeled-statement:labelstatement;
    enterRuleBlock: labelstatement
      enterRuleAltList: labelstatement
        enterLabeledAlt: labelstatement
          enterAlternative: labelstatement
            enterElement: label
              => element -> {label}
              enterAtom: label
                enterRuleref: label
                exitRuleref: label
              exitAtom: label
            exitElement: label
            enterElement: statement
              => element -> {statement}
              enterAtom: statement
                enterRuleref: statement
                exitRuleref: statement
              exitAtom: statement
            exitElement: statement
          exitAlternative: labelstatement
        => elements -> ['{label}', '{statement}']
            => alternative -> {label} {statement}
        exitLabeledAlt: labelstatement
      exitRuleAltList: labelstatement
    exitRuleBlock: labelstatement
  exitRuleSpec: labeled-statement:labelstatement;

  enterRuleSpec: expression-statement:expression?';';
    enterRuleBlock: expression?';'
      enterRuleAltList: expression?';'
        enterLabeledAlt: expression?';'
          enterAlternative: expression?';'
            enterElement: expression?
              => element -> [expression]
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: expression?
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: expression?';'
        => elements -> ['[expression]', ';']
            => alternative -> [expression] ;
        exitLabeledAlt: expression?';'
      exitRuleAltList: expression?';'
    exitRuleBlock: expression?';'
  exitRuleSpec: expression-statement:expression?';';

  enterRuleSpec: compound-statement:'{'statement*label*'}';
    enterRuleBlock: '{'statement*label*'}'
      enterRuleAltList: '{'statement*label*'}'
        enterLabeledAlt: '{'statement*label*'}'
          enterAlternative: '{'statement*label*'}'
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
            enterElement: statement*
              => element -> [statement]...
              enterAtom: statement
                enterRuleref: statement
                exitRuleref: statement
              exitAtom: statement
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: statement*
            enterElement: label*
              => element -> [label]...
              enterAtom: label
                enterRuleref: label
                exitRuleref: label
              exitAtom: label
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: label*
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: '{'statement*label*'}'
        => elements -> ['{', '[statement]...', '[label]...', '}']
            => alternative -> { [statement]... [label]... }
        exitLabeledAlt: '{'statement*label*'}'
      exitRuleAltList: '{'statement*label*'}'
    exitRuleBlock: '{'statement*label*'}'
  exitRuleSpec: compound-statement:'{'statement*label*'}';

  enterRuleSpec: if-constexpr:'if constexpr';
    enterRuleBlock: 'if constexpr'
      enterRuleAltList: 'if constexpr'
        enterLabeledAlt: 'if constexpr'
          enterAlternative: 'if constexpr'
            enterElement: 'if constexpr'
              => element -> if constexpr
              enterAtom: 'if constexpr'
                enterTerminal: 'if constexpr'
                exitTerminal: 'if constexpr'
              exitAtom: 'if constexpr'
            exitElement: 'if constexpr'
          exitAlternative: 'if constexpr'
        => elements -> ['if constexpr']
            => alternative -> if constexpr
        exitLabeledAlt: 'if constexpr'
      exitRuleAltList: 'if constexpr'
    exitRuleBlock: 'if constexpr'
  exitRuleSpec: if-constexpr:'if constexpr';

  enterRuleSpec: if-exlamation-mark:'if !';
    enterRuleBlock: 'if !'
      enterRuleAltList: 'if !'
        enterLabeledAlt: 'if !'
          enterAlternative: 'if !'
            enterElement: 'if !'
              => element -> if !
              enterAtom: 'if !'
                enterTerminal: 'if !'
                exitTerminal: 'if !'
              exitAtom: 'if !'
            exitElement: 'if !'
          exitAlternative: 'if !'
        => elements -> ['if !']
            => alternative -> if !
        exitLabeledAlt: 'if !'
      exitRuleAltList: 'if !'
    exitRuleBlock: 'if !'
  exitRuleSpec: if-exlamation-mark:'if !';

  enterRuleSpec: selection-statement:if-constexpr?'('init-statement?condition')'statement|if-constexpr?'('init-statement?condition')'statement'else'statement|if-exlamation-mark?'consteval'compound-statement|if-exlamation-mark?'consteval'compound-statement'else'statement|'switch('init-statement?condition')'statement;
    enterRuleBlock: if-constexpr?'('init-statement?condition')'statement|if-constexpr?'('init-statement?condition')'statement'else'statement|if-exlamation-mark?'consteval'compound-statement|if-exlamation-mark?'consteval'compound-statement'else'statement|'switch('init-statement?condition')'statement
      enterRuleAltList: if-constexpr?'('init-statement?condition')'statement|if-constexpr?'('init-statement?condition')'statement'else'statement|if-exlamation-mark?'consteval'compound-statement|if-exlamation-mark?'consteval'compound-statement'else'statement|'switch('init-statement?condition')'statement
        enterLabeledAlt: if-constexpr?'('init-statement?condition')'statement
          enterAlternative: if-constexpr?'('init-statement?condition')'statement
            enterElement: if-constexpr?
              => element -> [if-constexpr]
              enterAtom: if-constexpr
                enterRuleref: if-constexpr
                exitRuleref: if-constexpr
              exitAtom: if-constexpr
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: if-constexpr?
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: init-statement?
              => element -> [init-statement]
              enterAtom: init-statement
                enterRuleref: init-statement
                exitRuleref: init-statement
              exitAtom: init-statement
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: init-statement?
            enterElement: condition
              => element -> {condition}
              enterAtom: condition
                enterRuleref: condition
                exitRuleref: condition
              exitAtom: condition
            exitElement: condition
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
            enterElement: statement
              => element -> {statement}
              enterAtom: statement
                enterRuleref: statement
                exitRuleref: statement
              exitAtom: statement
            exitElement: statement
          exitAlternative: if-constexpr?'('init-statement?condition')'statement
        => elements -> ['[if-constexpr]', '(', '[init-statement]', '{condition}', ')', '{statement}']
            => alternative -> [if-constexpr] ( [init-statement] {condition} ) {statement}
        exitLabeledAlt: if-constexpr?'('init-statement?condition')'statement
        enterLabeledAlt: if-constexpr?'('init-statement?condition')'statement'else'statement
          enterAlternative: if-constexpr?'('init-statement?condition')'statement'else'statement
            enterElement: if-constexpr?
              => element -> [if-constexpr]
              enterAtom: if-constexpr
                enterRuleref: if-constexpr
                exitRuleref: if-constexpr
              exitAtom: if-constexpr
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: if-constexpr?
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: init-statement?
              => element -> [init-statement]
              enterAtom: init-statement
                enterRuleref: init-statement
                exitRuleref: init-statement
              exitAtom: init-statement
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: init-statement?
            enterElement: condition
              => element -> {condition}
              enterAtom: condition
                enterRuleref: condition
                exitRuleref: condition
              exitAtom: condition
            exitElement: condition
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
            enterElement: statement
              => element -> {statement}
              enterAtom: statement
                enterRuleref: statement
                exitRuleref: statement
              exitAtom: statement
            exitElement: statement
            enterElement: 'else'
              => element -> else
              enterAtom: 'else'
                enterTerminal: 'else'
                exitTerminal: 'else'
              exitAtom: 'else'
            exitElement: 'else'
            enterElement: statement
              => element -> {statement}
              enterAtom: statement
                enterRuleref: statement
                exitRuleref: statement
              exitAtom: statement
            exitElement: statement
          exitAlternative: if-constexpr?'('init-statement?condition')'statement'else'statement
        => elements -> ['[if-constexpr]', '(', '[init-statement]', '{condition}', ')', '{statement}', 'else', '{statement}']
            => alternative -> [if-constexpr] ( [init-statement] {condition} ) {statement} else {statement}
        exitLabeledAlt: if-constexpr?'('init-statement?condition')'statement'else'statement
        enterLabeledAlt: if-exlamation-mark?'consteval'compound-statement
          enterAlternative: if-exlamation-mark?'consteval'compound-statement
            enterElement: if-exlamation-mark?
              => element -> [if-exlamation-mark]
              enterAtom: if-exlamation-mark
                enterRuleref: if-exlamation-mark
                exitRuleref: if-exlamation-mark
              exitAtom: if-exlamation-mark
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: if-exlamation-mark?
            enterElement: 'consteval'
              => element -> consteval
              enterAtom: 'consteval'
                enterTerminal: 'consteval'
                exitTerminal: 'consteval'
              exitAtom: 'consteval'
            exitElement: 'consteval'
            enterElement: compound-statement
              => element -> {compound-statement}
              enterAtom: compound-statement
                enterRuleref: compound-statement
                exitRuleref: compound-statement
              exitAtom: compound-statement
            exitElement: compound-statement
          exitAlternative: if-exlamation-mark?'consteval'compound-statement
        => elements -> ['[if-exlamation-mark]', 'consteval', '{compound-statement}']
            => alternative -> [if-exlamation-mark] consteval {compound-statement}
        exitLabeledAlt: if-exlamation-mark?'consteval'compound-statement
        enterLabeledAlt: if-exlamation-mark?'consteval'compound-statement'else'statement
          enterAlternative: if-exlamation-mark?'consteval'compound-statement'else'statement
            enterElement: if-exlamation-mark?
              => element -> [if-exlamation-mark]
              enterAtom: if-exlamation-mark
                enterRuleref: if-exlamation-mark
                exitRuleref: if-exlamation-mark
              exitAtom: if-exlamation-mark
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: if-exlamation-mark?
            enterElement: 'consteval'
              => element -> consteval
              enterAtom: 'consteval'
                enterTerminal: 'consteval'
                exitTerminal: 'consteval'
              exitAtom: 'consteval'
            exitElement: 'consteval'
            enterElement: compound-statement
              => element -> {compound-statement}
              enterAtom: compound-statement
                enterRuleref: compound-statement
                exitRuleref: compound-statement
              exitAtom: compound-statement
            exitElement: compound-statement
            enterElement: 'else'
              => element -> else
              enterAtom: 'else'
                enterTerminal: 'else'
                exitTerminal: 'else'
              exitAtom: 'else'
            exitElement: 'else'
            enterElement: statement
              => element -> {statement}
              enterAtom: statement
                enterRuleref: statement
                exitRuleref: statement
              exitAtom: statement
            exitElement: statement
          exitAlternative: if-exlamation-mark?'consteval'compound-statement'else'statement
        => elements -> ['[if-exlamation-mark]', 'consteval', '{compound-statement}', 'else', '{statement}']
            => alternative -> [if-exlamation-mark] consteval {compound-statement} else {statement}
        exitLabeledAlt: if-exlamation-mark?'consteval'compound-statement'else'statement
        enterLabeledAlt: 'switch('init-statement?condition')'statement
          enterAlternative: 'switch('init-statement?condition')'statement
            enterElement: 'switch('
              => element -> switch(
              enterAtom: 'switch('
                enterTerminal: 'switch('
                exitTerminal: 'switch('
              exitAtom: 'switch('
            exitElement: 'switch('
            enterElement: init-statement?
              => element -> [init-statement]
              enterAtom: init-statement
                enterRuleref: init-statement
                exitRuleref: init-statement
              exitAtom: init-statement
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: init-statement?
            enterElement: condition
              => element -> {condition}
              enterAtom: condition
                enterRuleref: condition
                exitRuleref: condition
              exitAtom: condition
            exitElement: condition
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
            enterElement: statement
              => element -> {statement}
              enterAtom: statement
                enterRuleref: statement
                exitRuleref: statement
              exitAtom: statement
            exitElement: statement
          exitAlternative: 'switch('init-statement?condition')'statement
        => elements -> ['switch(', '[init-statement]', '{condition}', ')', '{statement}']
            => alternative -> switch( [init-statement] {condition} ) {statement}
        exitLabeledAlt: 'switch('init-statement?condition')'statement
      exitRuleAltList: if-constexpr?'('init-statement?condition')'statement|if-constexpr?'('init-statement?condition')'statement'else'statement|if-exlamation-mark?'consteval'compound-statement|if-exlamation-mark?'consteval'compound-statement'else'statement|'switch('init-statement?condition')'statement
    exitRuleBlock: if-constexpr?'('init-statement?condition')'statement|if-constexpr?'('init-statement?condition')'statement'else'statement|if-exlamation-mark?'consteval'compound-statement|if-exlamation-mark?'consteval'compound-statement'else'statement|'switch('init-statement?condition')'statement
  exitRuleSpec: selection-statement:if-constexpr?'('init-statement?condition')'statement|if-constexpr?'('init-statement?condition')'statement'else'statement|if-exlamation-mark?'consteval'compound-statement|if-exlamation-mark?'consteval'compound-statement'else'statement|'switch('init-statement?condition')'statement;

  enterRuleSpec: iteration-statement:'while('condition')'statement|'do'statement'while('expression');'|'for('init-statementcondition?';'expression?')'statement|'for('init-statement?for-range-declaration':'for-range-initializer')'statement;
    enterRuleBlock: 'while('condition')'statement|'do'statement'while('expression');'|'for('init-statementcondition?';'expression?')'statement|'for('init-statement?for-range-declaration':'for-range-initializer')'statement
      enterRuleAltList: 'while('condition')'statement|'do'statement'while('expression');'|'for('init-statementcondition?';'expression?')'statement|'for('init-statement?for-range-declaration':'for-range-initializer')'statement
        enterLabeledAlt: 'while('condition')'statement
          enterAlternative: 'while('condition')'statement
            enterElement: 'while('
              => element -> while(
              enterAtom: 'while('
                enterTerminal: 'while('
                exitTerminal: 'while('
              exitAtom: 'while('
            exitElement: 'while('
            enterElement: condition
              => element -> {condition}
              enterAtom: condition
                enterRuleref: condition
                exitRuleref: condition
              exitAtom: condition
            exitElement: condition
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
            enterElement: statement
              => element -> {statement}
              enterAtom: statement
                enterRuleref: statement
                exitRuleref: statement
              exitAtom: statement
            exitElement: statement
          exitAlternative: 'while('condition')'statement
        => elements -> ['while(', '{condition}', ')', '{statement}']
            => alternative -> while( {condition} ) {statement}
        exitLabeledAlt: 'while('condition')'statement
        enterLabeledAlt: 'do'statement'while('expression');'
          enterAlternative: 'do'statement'while('expression');'
            enterElement: 'do'
              => element -> do
              enterAtom: 'do'
                enterTerminal: 'do'
                exitTerminal: 'do'
              exitAtom: 'do'
            exitElement: 'do'
            enterElement: statement
              => element -> {statement}
              enterAtom: statement
                enterRuleref: statement
                exitRuleref: statement
              exitAtom: statement
            exitElement: statement
            enterElement: 'while('
              => element -> while(
              enterAtom: 'while('
                enterTerminal: 'while('
                exitTerminal: 'while('
              exitAtom: 'while('
            exitElement: 'while('
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
            enterElement: ');'
              => element -> );
              enterAtom: ');'
                enterTerminal: ');'
                exitTerminal: ');'
              exitAtom: ');'
            exitElement: ');'
          exitAlternative: 'do'statement'while('expression');'
        => elements -> ['do', '{statement}', 'while(', '{expression}', ');']
            => alternative -> do {statement} while( {expression} );
        exitLabeledAlt: 'do'statement'while('expression');'
        enterLabeledAlt: 'for('init-statementcondition?';'expression?')'statement
          enterAlternative: 'for('init-statementcondition?';'expression?')'statement
            enterElement: 'for('
              => element -> for(
              enterAtom: 'for('
                enterTerminal: 'for('
                exitTerminal: 'for('
              exitAtom: 'for('
            exitElement: 'for('
            enterElement: init-statement
              => element -> {init-statement}
              enterAtom: init-statement
                enterRuleref: init-statement
                exitRuleref: init-statement
              exitAtom: init-statement
            exitElement: init-statement
            enterElement: condition?
              => element -> [condition]
              enterAtom: condition
                enterRuleref: condition
                exitRuleref: condition
              exitAtom: condition
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: condition?
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
            enterElement: expression?
              => element -> [expression]
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: expression?
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
            enterElement: statement
              => element -> {statement}
              enterAtom: statement
                enterRuleref: statement
                exitRuleref: statement
              exitAtom: statement
            exitElement: statement
          exitAlternative: 'for('init-statementcondition?';'expression?')'statement
        => elements -> ['for(', '{init-statement}', '[condition]', ';', '[expression]', ')', '{statement}']
            => alternative -> for( {init-statement} [condition] ; [expression] ) {statement}
        exitLabeledAlt: 'for('init-statementcondition?';'expression?')'statement
        enterLabeledAlt: 'for('init-statement?for-range-declaration':'for-range-initializer')'statement
          enterAlternative: 'for('init-statement?for-range-declaration':'for-range-initializer')'statement
            enterElement: 'for('
              => element -> for(
              enterAtom: 'for('
                enterTerminal: 'for('
                exitTerminal: 'for('
              exitAtom: 'for('
            exitElement: 'for('
            enterElement: init-statement?
              => element -> [init-statement]
              enterAtom: init-statement
                enterRuleref: init-statement
                exitRuleref: init-statement
              exitAtom: init-statement
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: init-statement?
            enterElement: for-range-declaration
              => element -> {for-range-declaration}
              enterAtom: for-range-declaration
                enterRuleref: for-range-declaration
                exitRuleref: for-range-declaration
              exitAtom: for-range-declaration
            exitElement: for-range-declaration
            enterElement: ':'
              => element -> :
              enterAtom: ':'
                enterTerminal: ':'
                exitTerminal: ':'
              exitAtom: ':'
            exitElement: ':'
            enterElement: for-range-initializer
              => element -> {for-range-initializer}
              enterAtom: for-range-initializer
                enterRuleref: for-range-initializer
                exitRuleref: for-range-initializer
              exitAtom: for-range-initializer
            exitElement: for-range-initializer
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
            enterElement: statement
              => element -> {statement}
              enterAtom: statement
                enterRuleref: statement
                exitRuleref: statement
              exitAtom: statement
            exitElement: statement
          exitAlternative: 'for('init-statement?for-range-declaration':'for-range-initializer')'statement
        => elements -> ['for(', '[init-statement]', '{for-range-declaration}', ':', '{for-range-initializer}', ')', '{statement}']
            => alternative -> for( [init-statement] {for-range-declaration} : {for-range-initializer} ) {statement}
        exitLabeledAlt: 'for('init-statement?for-range-declaration':'for-range-initializer')'statement
      exitRuleAltList: 'while('condition')'statement|'do'statement'while('expression');'|'for('init-statementcondition?';'expression?')'statement|'for('init-statement?for-range-declaration':'for-range-initializer')'statement
    exitRuleBlock: 'while('condition')'statement|'do'statement'while('expression');'|'for('init-statementcondition?';'expression?')'statement|'for('init-statement?for-range-declaration':'for-range-initializer')'statement
  exitRuleSpec: iteration-statement:'while('condition')'statement|'do'statement'while('expression');'|'for('init-statementcondition?';'expression?')'statement|'for('init-statement?for-range-declaration':'for-range-initializer')'statement;

  enterRuleSpec: for-range-declaration:attribute-specifier*decl-specifier-seqdeclarator|attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']';
    enterRuleBlock: attribute-specifier*decl-specifier-seqdeclarator|attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'
      enterRuleAltList: attribute-specifier*decl-specifier-seqdeclarator|attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'
        enterLabeledAlt: attribute-specifier*decl-specifier-seqdeclarator
          enterAlternative: attribute-specifier*decl-specifier-seqdeclarator
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: decl-specifier-seq
              => element -> {decl-specifier-seq}
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
            exitElement: decl-specifier-seq
            enterElement: declarator
              => element -> {declarator}
              enterAtom: declarator
                enterRuleref: declarator
                exitRuleref: declarator
              exitAtom: declarator
            exitElement: declarator
          exitAlternative: attribute-specifier*decl-specifier-seqdeclarator
        => elements -> ['[attribute-specifier]...', '{decl-specifier-seq}', '{declarator}']
            => alternative -> [attribute-specifier]... {decl-specifier-seq} {declarator}
        exitLabeledAlt: attribute-specifier*decl-specifier-seqdeclarator
        enterLabeledAlt: attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'
          enterAlternative: attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: decl-specifier-seq
              => element -> {decl-specifier-seq}
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
            exitElement: decl-specifier-seq
            enterElement: ref-qualifier?
              => element -> [ref-qualifier]
              enterAtom: ref-qualifier
                enterRuleref: ref-qualifier
                exitRuleref: ref-qualifier
              exitAtom: ref-qualifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: ref-qualifier?
            enterElement: '['
              => element -> [
              enterAtom: '['
                enterTerminal: '['
                exitTerminal: '['
              exitAtom: '['
            exitElement: '['
            enterElement: identifier+
              => element -> {identifier}...
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: identifier+
            enterElement: ']'
              => element -> ]
              enterAtom: ']'
                enterTerminal: ']'
                exitTerminal: ']'
              exitAtom: ']'
            exitElement: ']'
          exitAlternative: attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'
        => elements -> ['[attribute-specifier]...', '{decl-specifier-seq}', '[ref-qualifier]', '[', '{identifier}...', ']']
            => alternative -> [attribute-specifier]... {decl-specifier-seq} [ref-qualifier] [ {identifier}... ]
        exitLabeledAlt: attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'
      exitRuleAltList: attribute-specifier*decl-specifier-seqdeclarator|attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'
    exitRuleBlock: attribute-specifier*decl-specifier-seqdeclarator|attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'
  exitRuleSpec: for-range-declaration:attribute-specifier*decl-specifier-seqdeclarator|attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']';

  enterRuleSpec: for-range-initializer:expr-or-braced-init-list;
    enterRuleBlock: expr-or-braced-init-list
      enterRuleAltList: expr-or-braced-init-list
        enterLabeledAlt: expr-or-braced-init-list
          enterAlternative: expr-or-braced-init-list
            enterElement: expr-or-braced-init-list
              => element -> {expr-or-braced-init-list}
              enterAtom: expr-or-braced-init-list
                enterRuleref: expr-or-braced-init-list
                exitRuleref: expr-or-braced-init-list
              exitAtom: expr-or-braced-init-list
            exitElement: expr-or-braced-init-list
          exitAlternative: expr-or-braced-init-list
        => elements -> ['{expr-or-braced-init-list}']
            => alternative -> {expr-or-braced-init-list}
        exitLabeledAlt: expr-or-braced-init-list
      exitRuleAltList: expr-or-braced-init-list
    exitRuleBlock: expr-or-braced-init-list
  exitRuleSpec: for-range-initializer:expr-or-braced-init-list;

  enterRuleSpec: jump-statement:'break;'|'continue;'|'return'expr-or-braced-init-list?';'|coroutine-return-statement|'goto'identifier';';
    enterRuleBlock: 'break;'|'continue;'|'return'expr-or-braced-init-list?';'|coroutine-return-statement|'goto'identifier';'
      enterRuleAltList: 'break;'|'continue;'|'return'expr-or-braced-init-list?';'|coroutine-return-statement|'goto'identifier';'
        enterLabeledAlt: 'break;'
          enterAlternative: 'break;'
            enterElement: 'break;'
              => element -> break;
              enterAtom: 'break;'
                enterTerminal: 'break;'
                exitTerminal: 'break;'
              exitAtom: 'break;'
            exitElement: 'break;'
          exitAlternative: 'break;'
        => elements -> ['break;']
            => alternative -> break;
        exitLabeledAlt: 'break;'
        enterLabeledAlt: 'continue;'
          enterAlternative: 'continue;'
            enterElement: 'continue;'
              => element -> continue;
              enterAtom: 'continue;'
                enterTerminal: 'continue;'
                exitTerminal: 'continue;'
              exitAtom: 'continue;'
            exitElement: 'continue;'
          exitAlternative: 'continue;'
        => elements -> ['continue;']
            => alternative -> continue;
        exitLabeledAlt: 'continue;'
        enterLabeledAlt: 'return'expr-or-braced-init-list?';'
          enterAlternative: 'return'expr-or-braced-init-list?';'
            enterElement: 'return'
              => element -> return
              enterAtom: 'return'
                enterTerminal: 'return'
                exitTerminal: 'return'
              exitAtom: 'return'
            exitElement: 'return'
            enterElement: expr-or-braced-init-list?
              => element -> [expr-or-braced-init-list]
              enterAtom: expr-or-braced-init-list
                enterRuleref: expr-or-braced-init-list
                exitRuleref: expr-or-braced-init-list
              exitAtom: expr-or-braced-init-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: expr-or-braced-init-list?
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: 'return'expr-or-braced-init-list?';'
        => elements -> ['return', '[expr-or-braced-init-list]', ';']
            => alternative -> return [expr-or-braced-init-list] ;
        exitLabeledAlt: 'return'expr-or-braced-init-list?';'
        enterLabeledAlt: coroutine-return-statement
          enterAlternative: coroutine-return-statement
            enterElement: coroutine-return-statement
              => element -> {coroutine-return-statement}
              enterAtom: coroutine-return-statement
                enterRuleref: coroutine-return-statement
                exitRuleref: coroutine-return-statement
              exitAtom: coroutine-return-statement
            exitElement: coroutine-return-statement
          exitAlternative: coroutine-return-statement
        => elements -> ['{coroutine-return-statement}']
            => alternative -> {coroutine-return-statement}
        exitLabeledAlt: coroutine-return-statement
        enterLabeledAlt: 'goto'identifier';'
          enterAlternative: 'goto'identifier';'
            enterElement: 'goto'
              => element -> goto
              enterAtom: 'goto'
                enterTerminal: 'goto'
                exitTerminal: 'goto'
              exitAtom: 'goto'
            exitElement: 'goto'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: 'goto'identifier';'
        => elements -> ['goto', '{identifier}', ';']
            => alternative -> goto {identifier} ;
        exitLabeledAlt: 'goto'identifier';'
      exitRuleAltList: 'break;'|'continue;'|'return'expr-or-braced-init-list?';'|coroutine-return-statement|'goto'identifier';'
    exitRuleBlock: 'break;'|'continue;'|'return'expr-or-braced-init-list?';'|coroutine-return-statement|'goto'identifier';'
  exitRuleSpec: jump-statement:'break;'|'continue;'|'return'expr-or-braced-init-list?';'|coroutine-return-statement|'goto'identifier';';

  enterRuleSpec: coroutine-return-statement:'co_return'expr-or-braced-init-list?';';
    enterRuleBlock: 'co_return'expr-or-braced-init-list?';'
      enterRuleAltList: 'co_return'expr-or-braced-init-list?';'
        enterLabeledAlt: 'co_return'expr-or-braced-init-list?';'
          enterAlternative: 'co_return'expr-or-braced-init-list?';'
            enterElement: 'co_return'
              => element -> co_return
              enterAtom: 'co_return'
                enterTerminal: 'co_return'
                exitTerminal: 'co_return'
              exitAtom: 'co_return'
            exitElement: 'co_return'
            enterElement: expr-or-braced-init-list?
              => element -> [expr-or-braced-init-list]
              enterAtom: expr-or-braced-init-list
                enterRuleref: expr-or-braced-init-list
                exitRuleref: expr-or-braced-init-list
              exitAtom: expr-or-braced-init-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: expr-or-braced-init-list?
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: 'co_return'expr-or-braced-init-list?';'
        => elements -> ['co_return', '[expr-or-braced-init-list]', ';']
            => alternative -> co_return [expr-or-braced-init-list] ;
        exitLabeledAlt: 'co_return'expr-or-braced-init-list?';'
      exitRuleAltList: 'co_return'expr-or-braced-init-list?';'
    exitRuleBlock: 'co_return'expr-or-braced-init-list?';'
  exitRuleSpec: coroutine-return-statement:'co_return'expr-or-braced-init-list?';';

  enterRuleSpec: declaration-statement:block-declaration;
    enterRuleBlock: block-declaration
      enterRuleAltList: block-declaration
        enterLabeledAlt: block-declaration
          enterAlternative: block-declaration
            enterElement: block-declaration
              => element -> {block-declaration}
              enterAtom: block-declaration
                enterRuleref: block-declaration
                exitRuleref: block-declaration
              exitAtom: block-declaration
            exitElement: block-declaration
          exitAlternative: block-declaration
        => elements -> ['{block-declaration}']
            => alternative -> {block-declaration}
        exitLabeledAlt: block-declaration
      exitRuleAltList: block-declaration
    exitRuleBlock: block-declaration
  exitRuleSpec: declaration-statement:block-declaration;

  enterRuleSpec: declaration:name-declaration|special-declaration;
    enterRuleBlock: name-declaration|special-declaration
      enterRuleAltList: name-declaration|special-declaration
        enterLabeledAlt: name-declaration
          enterAlternative: name-declaration
            enterElement: name-declaration
              => element -> {name-declaration}
              enterAtom: name-declaration
                enterRuleref: name-declaration
                exitRuleref: name-declaration
              exitAtom: name-declaration
            exitElement: name-declaration
          exitAlternative: name-declaration
        => elements -> ['{name-declaration}']
            => alternative -> {name-declaration}
        exitLabeledAlt: name-declaration
        enterLabeledAlt: special-declaration
          enterAlternative: special-declaration
            enterElement: special-declaration
              => element -> {special-declaration}
              enterAtom: special-declaration
                enterRuleref: special-declaration
                exitRuleref: special-declaration
              exitAtom: special-declaration
            exitElement: special-declaration
          exitAlternative: special-declaration
        => elements -> ['{special-declaration}']
            => alternative -> {special-declaration}
        exitLabeledAlt: special-declaration
      exitRuleAltList: name-declaration|special-declaration
    exitRuleBlock: name-declaration|special-declaration
  exitRuleSpec: declaration:name-declaration|special-declaration;

  enterRuleSpec: name-declaration:block-declaration|nodeclspec-function-declaration|function-definition|template-declaration|deduction-guide|linkage-specification|namespace-definition|empty-declaration|attribute-declaration|module-import-declaration;
    enterRuleBlock: block-declaration|nodeclspec-function-declaration|function-definition|template-declaration|deduction-guide|linkage-specification|namespace-definition|empty-declaration|attribute-declaration|module-import-declaration
      enterRuleAltList: block-declaration|nodeclspec-function-declaration|function-definition|template-declaration|deduction-guide|linkage-specification|namespace-definition|empty-declaration|attribute-declaration|module-import-declaration
        enterLabeledAlt: block-declaration
          enterAlternative: block-declaration
            enterElement: block-declaration
              => element -> {block-declaration}
              enterAtom: block-declaration
                enterRuleref: block-declaration
                exitRuleref: block-declaration
              exitAtom: block-declaration
            exitElement: block-declaration
          exitAlternative: block-declaration
        => elements -> ['{block-declaration}']
            => alternative -> {block-declaration}
        exitLabeledAlt: block-declaration
        enterLabeledAlt: nodeclspec-function-declaration
          enterAlternative: nodeclspec-function-declaration
            enterElement: nodeclspec-function-declaration
              => element -> {nodeclspec-function-declaration}
              enterAtom: nodeclspec-function-declaration
                enterRuleref: nodeclspec-function-declaration
                exitRuleref: nodeclspec-function-declaration
              exitAtom: nodeclspec-function-declaration
            exitElement: nodeclspec-function-declaration
          exitAlternative: nodeclspec-function-declaration
        => elements -> ['{nodeclspec-function-declaration}']
            => alternative -> {nodeclspec-function-declaration}
        exitLabeledAlt: nodeclspec-function-declaration
        enterLabeledAlt: function-definition
          enterAlternative: function-definition
            enterElement: function-definition
              => element -> {function-definition}
              enterAtom: function-definition
                enterRuleref: function-definition
                exitRuleref: function-definition
              exitAtom: function-definition
            exitElement: function-definition
          exitAlternative: function-definition
        => elements -> ['{function-definition}']
            => alternative -> {function-definition}
        exitLabeledAlt: function-definition
        enterLabeledAlt: template-declaration
          enterAlternative: template-declaration
            enterElement: template-declaration
              => element -> {template-declaration}
              enterAtom: template-declaration
                enterRuleref: template-declaration
                exitRuleref: template-declaration
              exitAtom: template-declaration
            exitElement: template-declaration
          exitAlternative: template-declaration
        => elements -> ['{template-declaration}']
            => alternative -> {template-declaration}
        exitLabeledAlt: template-declaration
        enterLabeledAlt: deduction-guide
          enterAlternative: deduction-guide
            enterElement: deduction-guide
              => element -> {deduction-guide}
              enterAtom: deduction-guide
                enterRuleref: deduction-guide
                exitRuleref: deduction-guide
              exitAtom: deduction-guide
            exitElement: deduction-guide
          exitAlternative: deduction-guide
        => elements -> ['{deduction-guide}']
            => alternative -> {deduction-guide}
        exitLabeledAlt: deduction-guide
        enterLabeledAlt: linkage-specification
          enterAlternative: linkage-specification
            enterElement: linkage-specification
              => element -> {linkage-specification}
              enterAtom: linkage-specification
                enterRuleref: linkage-specification
                exitRuleref: linkage-specification
              exitAtom: linkage-specification
            exitElement: linkage-specification
          exitAlternative: linkage-specification
        => elements -> ['{linkage-specification}']
            => alternative -> {linkage-specification}
        exitLabeledAlt: linkage-specification
        enterLabeledAlt: namespace-definition
          enterAlternative: namespace-definition
            enterElement: namespace-definition
              => element -> {namespace-definition}
              enterAtom: namespace-definition
                enterRuleref: namespace-definition
                exitRuleref: namespace-definition
              exitAtom: namespace-definition
            exitElement: namespace-definition
          exitAlternative: namespace-definition
        => elements -> ['{namespace-definition}']
            => alternative -> {namespace-definition}
        exitLabeledAlt: namespace-definition
        enterLabeledAlt: empty-declaration
          enterAlternative: empty-declaration
            enterElement: empty-declaration
              => element -> {empty-declaration}
              enterAtom: empty-declaration
                enterRuleref: empty-declaration
                exitRuleref: empty-declaration
              exitAtom: empty-declaration
            exitElement: empty-declaration
          exitAlternative: empty-declaration
        => elements -> ['{empty-declaration}']
            => alternative -> {empty-declaration}
        exitLabeledAlt: empty-declaration
        enterLabeledAlt: attribute-declaration
          enterAlternative: attribute-declaration
            enterElement: attribute-declaration
              => element -> {attribute-declaration}
              enterAtom: attribute-declaration
                enterRuleref: attribute-declaration
                exitRuleref: attribute-declaration
              exitAtom: attribute-declaration
            exitElement: attribute-declaration
          exitAlternative: attribute-declaration
        => elements -> ['{attribute-declaration}']
            => alternative -> {attribute-declaration}
        exitLabeledAlt: attribute-declaration
        enterLabeledAlt: module-import-declaration
          enterAlternative: module-import-declaration
            enterElement: module-import-declaration
              => element -> {module-import-declaration}
              enterAtom: module-import-declaration
                enterRuleref: module-import-declaration
                exitRuleref: module-import-declaration
              exitAtom: module-import-declaration
            exitElement: module-import-declaration
          exitAlternative: module-import-declaration
        => elements -> ['{module-import-declaration}']
            => alternative -> {module-import-declaration}
        exitLabeledAlt: module-import-declaration
      exitRuleAltList: block-declaration|nodeclspec-function-declaration|function-definition|template-declaration|deduction-guide|linkage-specification|namespace-definition|empty-declaration|attribute-declaration|module-import-declaration
    exitRuleBlock: block-declaration|nodeclspec-function-declaration|function-definition|template-declaration|deduction-guide|linkage-specification|namespace-definition|empty-declaration|attribute-declaration|module-import-declaration
  exitRuleSpec: name-declaration:block-declaration|nodeclspec-function-declaration|function-definition|template-declaration|deduction-guide|linkage-specification|namespace-definition|empty-declaration|attribute-declaration|module-import-declaration;

  enterRuleSpec: special-declaration:explicit-instantiation|explicit-specialization|export-declaration;
    enterRuleBlock: explicit-instantiation|explicit-specialization|export-declaration
      enterRuleAltList: explicit-instantiation|explicit-specialization|export-declaration
        enterLabeledAlt: explicit-instantiation
          enterAlternative: explicit-instantiation
            enterElement: explicit-instantiation
              => element -> {explicit-instantiation}
              enterAtom: explicit-instantiation
                enterRuleref: explicit-instantiation
                exitRuleref: explicit-instantiation
              exitAtom: explicit-instantiation
            exitElement: explicit-instantiation
          exitAlternative: explicit-instantiation
        => elements -> ['{explicit-instantiation}']
            => alternative -> {explicit-instantiation}
        exitLabeledAlt: explicit-instantiation
        enterLabeledAlt: explicit-specialization
          enterAlternative: explicit-specialization
            enterElement: explicit-specialization
              => element -> {explicit-specialization}
              enterAtom: explicit-specialization
                enterRuleref: explicit-specialization
                exitRuleref: explicit-specialization
              exitAtom: explicit-specialization
            exitElement: explicit-specialization
          exitAlternative: explicit-specialization
        => elements -> ['{explicit-specialization}']
            => alternative -> {explicit-specialization}
        exitLabeledAlt: explicit-specialization
        enterLabeledAlt: export-declaration
          enterAlternative: export-declaration
            enterElement: export-declaration
              => element -> {export-declaration}
              enterAtom: export-declaration
                enterRuleref: export-declaration
                exitRuleref: export-declaration
              exitAtom: export-declaration
            exitElement: export-declaration
          exitAlternative: export-declaration
        => elements -> ['{export-declaration}']
            => alternative -> {export-declaration}
        exitLabeledAlt: export-declaration
      exitRuleAltList: explicit-instantiation|explicit-specialization|export-declaration
    exitRuleBlock: explicit-instantiation|explicit-specialization|export-declaration
  exitRuleSpec: special-declaration:explicit-instantiation|explicit-specialization|export-declaration;

  enterRuleSpec: block-declaration:simple-declaration|asm-declaration|namespace-alias-definition|using-declaration|using-enum-declaration|using-directive|static-assert-declaration|alias-declaration|opaque-enum-declaration;
    enterRuleBlock: simple-declaration|asm-declaration|namespace-alias-definition|using-declaration|using-enum-declaration|using-directive|static-assert-declaration|alias-declaration|opaque-enum-declaration
      enterRuleAltList: simple-declaration|asm-declaration|namespace-alias-definition|using-declaration|using-enum-declaration|using-directive|static-assert-declaration|alias-declaration|opaque-enum-declaration
        enterLabeledAlt: simple-declaration
          enterAlternative: simple-declaration
            enterElement: simple-declaration
              => element -> {simple-declaration}
              enterAtom: simple-declaration
                enterRuleref: simple-declaration
                exitRuleref: simple-declaration
              exitAtom: simple-declaration
            exitElement: simple-declaration
          exitAlternative: simple-declaration
        => elements -> ['{simple-declaration}']
            => alternative -> {simple-declaration}
        exitLabeledAlt: simple-declaration
        enterLabeledAlt: asm-declaration
          enterAlternative: asm-declaration
            enterElement: asm-declaration
              => element -> {asm-declaration}
              enterAtom: asm-declaration
                enterRuleref: asm-declaration
                exitRuleref: asm-declaration
              exitAtom: asm-declaration
            exitElement: asm-declaration
          exitAlternative: asm-declaration
        => elements -> ['{asm-declaration}']
            => alternative -> {asm-declaration}
        exitLabeledAlt: asm-declaration
        enterLabeledAlt: namespace-alias-definition
          enterAlternative: namespace-alias-definition
            enterElement: namespace-alias-definition
              => element -> {namespace-alias-definition}
              enterAtom: namespace-alias-definition
                enterRuleref: namespace-alias-definition
                exitRuleref: namespace-alias-definition
              exitAtom: namespace-alias-definition
            exitElement: namespace-alias-definition
          exitAlternative: namespace-alias-definition
        => elements -> ['{namespace-alias-definition}']
            => alternative -> {namespace-alias-definition}
        exitLabeledAlt: namespace-alias-definition
        enterLabeledAlt: using-declaration
          enterAlternative: using-declaration
            enterElement: using-declaration
              => element -> {using-declaration}
              enterAtom: using-declaration
                enterRuleref: using-declaration
                exitRuleref: using-declaration
              exitAtom: using-declaration
            exitElement: using-declaration
          exitAlternative: using-declaration
        => elements -> ['{using-declaration}']
            => alternative -> {using-declaration}
        exitLabeledAlt: using-declaration
        enterLabeledAlt: using-enum-declaration
          enterAlternative: using-enum-declaration
            enterElement: using-enum-declaration
              => element -> {using-enum-declaration}
              enterAtom: using-enum-declaration
                enterRuleref: using-enum-declaration
                exitRuleref: using-enum-declaration
              exitAtom: using-enum-declaration
            exitElement: using-enum-declaration
          exitAlternative: using-enum-declaration
        => elements -> ['{using-enum-declaration}']
            => alternative -> {using-enum-declaration}
        exitLabeledAlt: using-enum-declaration
        enterLabeledAlt: using-directive
          enterAlternative: using-directive
            enterElement: using-directive
              => element -> {using-directive}
              enterAtom: using-directive
                enterRuleref: using-directive
                exitRuleref: using-directive
              exitAtom: using-directive
            exitElement: using-directive
          exitAlternative: using-directive
        => elements -> ['{using-directive}']
            => alternative -> {using-directive}
        exitLabeledAlt: using-directive
        enterLabeledAlt: static-assert-declaration
          enterAlternative: static-assert-declaration
            enterElement: static-assert-declaration
              => element -> {static-assert-declaration}
              enterAtom: static-assert-declaration
                enterRuleref: static-assert-declaration
                exitRuleref: static-assert-declaration
              exitAtom: static-assert-declaration
            exitElement: static-assert-declaration
          exitAlternative: static-assert-declaration
        => elements -> ['{static-assert-declaration}']
            => alternative -> {static-assert-declaration}
        exitLabeledAlt: static-assert-declaration
        enterLabeledAlt: alias-declaration
          enterAlternative: alias-declaration
            enterElement: alias-declaration
              => element -> {alias-declaration}
              enterAtom: alias-declaration
                enterRuleref: alias-declaration
                exitRuleref: alias-declaration
              exitAtom: alias-declaration
            exitElement: alias-declaration
          exitAlternative: alias-declaration
        => elements -> ['{alias-declaration}']
            => alternative -> {alias-declaration}
        exitLabeledAlt: alias-declaration
        enterLabeledAlt: opaque-enum-declaration
          enterAlternative: opaque-enum-declaration
            enterElement: opaque-enum-declaration
              => element -> {opaque-enum-declaration}
              enterAtom: opaque-enum-declaration
                enterRuleref: opaque-enum-declaration
                exitRuleref: opaque-enum-declaration
              exitAtom: opaque-enum-declaration
            exitElement: opaque-enum-declaration
          exitAlternative: opaque-enum-declaration
        => elements -> ['{opaque-enum-declaration}']
            => alternative -> {opaque-enum-declaration}
        exitLabeledAlt: opaque-enum-declaration
      exitRuleAltList: simple-declaration|asm-declaration|namespace-alias-definition|using-declaration|using-enum-declaration|using-directive|static-assert-declaration|alias-declaration|opaque-enum-declaration
    exitRuleBlock: simple-declaration|asm-declaration|namespace-alias-definition|using-declaration|using-enum-declaration|using-directive|static-assert-declaration|alias-declaration|opaque-enum-declaration
  exitRuleSpec: block-declaration:simple-declaration|asm-declaration|namespace-alias-definition|using-declaration|using-enum-declaration|using-directive|static-assert-declaration|alias-declaration|opaque-enum-declaration;

  enterRuleSpec: nodeclspec-function-declaration:attribute-specifier*declarator';';
    enterRuleBlock: attribute-specifier*declarator';'
      enterRuleAltList: attribute-specifier*declarator';'
        enterLabeledAlt: attribute-specifier*declarator';'
          enterAlternative: attribute-specifier*declarator';'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: declarator
              => element -> {declarator}
              enterAtom: declarator
                enterRuleref: declarator
                exitRuleref: declarator
              exitAtom: declarator
            exitElement: declarator
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: attribute-specifier*declarator';'
        => elements -> ['[attribute-specifier]...', '{declarator}', ';']
            => alternative -> [attribute-specifier]... {declarator} ;
        exitLabeledAlt: attribute-specifier*declarator';'
      exitRuleAltList: attribute-specifier*declarator';'
    exitRuleBlock: attribute-specifier*declarator';'
  exitRuleSpec: nodeclspec-function-declaration:attribute-specifier*declarator';';

  enterRuleSpec: alias-declaration:'using'identifierattribute-specifier*'='defining-type-id';';
    enterRuleBlock: 'using'identifierattribute-specifier*'='defining-type-id';'
      enterRuleAltList: 'using'identifierattribute-specifier*'='defining-type-id';'
        enterLabeledAlt: 'using'identifierattribute-specifier*'='defining-type-id';'
          enterAlternative: 'using'identifierattribute-specifier*'='defining-type-id';'
            enterElement: 'using'
              => element -> using
              enterAtom: 'using'
                enterTerminal: 'using'
                exitTerminal: 'using'
              exitAtom: 'using'
            exitElement: 'using'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
            enterElement: defining-type-id
              => element -> {defining-type-id}
              enterAtom: defining-type-id
                enterRuleref: defining-type-id
                exitRuleref: defining-type-id
              exitAtom: defining-type-id
            exitElement: defining-type-id
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: 'using'identifierattribute-specifier*'='defining-type-id';'
        => elements -> ['using', '{identifier}', '[attribute-specifier]...', '=', '{defining-type-id}', ';']
            => alternative -> using {identifier} [attribute-specifier]... = {defining-type-id} ;
        exitLabeledAlt: 'using'identifierattribute-specifier*'='defining-type-id';'
      exitRuleAltList: 'using'identifierattribute-specifier*'='defining-type-id';'
    exitRuleBlock: 'using'identifierattribute-specifier*'='defining-type-id';'
  exitRuleSpec: alias-declaration:'using'identifierattribute-specifier*'='defining-type-id';';

  enterRuleSpec: simple-declaration:decl-specifier-seqinit-declarator-list?';'|attribute-specifier*decl-specifier-seqinit-declarator-list';'|attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'initializer';';
    enterRuleBlock: decl-specifier-seqinit-declarator-list?';'|attribute-specifier*decl-specifier-seqinit-declarator-list';'|attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'initializer';'
      enterRuleAltList: decl-specifier-seqinit-declarator-list?';'|attribute-specifier*decl-specifier-seqinit-declarator-list';'|attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'initializer';'
        enterLabeledAlt: decl-specifier-seqinit-declarator-list?';'
          enterAlternative: decl-specifier-seqinit-declarator-list?';'
            enterElement: decl-specifier-seq
              => element -> {decl-specifier-seq}
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
            exitElement: decl-specifier-seq
            enterElement: init-declarator-list?
              => element -> [init-declarator-list]
              enterAtom: init-declarator-list
                enterRuleref: init-declarator-list
                exitRuleref: init-declarator-list
              exitAtom: init-declarator-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: init-declarator-list?
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: decl-specifier-seqinit-declarator-list?';'
        => elements -> ['{decl-specifier-seq}', '[init-declarator-list]', ';']
            => alternative -> {decl-specifier-seq} [init-declarator-list] ;
        exitLabeledAlt: decl-specifier-seqinit-declarator-list?';'
        enterLabeledAlt: attribute-specifier*decl-specifier-seqinit-declarator-list';'
          enterAlternative: attribute-specifier*decl-specifier-seqinit-declarator-list';'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: decl-specifier-seq
              => element -> {decl-specifier-seq}
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
            exitElement: decl-specifier-seq
            enterElement: init-declarator-list
              => element -> {init-declarator-list}
              enterAtom: init-declarator-list
                enterRuleref: init-declarator-list
                exitRuleref: init-declarator-list
              exitAtom: init-declarator-list
            exitElement: init-declarator-list
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: attribute-specifier*decl-specifier-seqinit-declarator-list';'
        => elements -> ['[attribute-specifier]...', '{decl-specifier-seq}', '{init-declarator-list}', ';']
            => alternative -> [attribute-specifier]... {decl-specifier-seq} {init-declarator-list} ;
        exitLabeledAlt: attribute-specifier*decl-specifier-seqinit-declarator-list';'
        enterLabeledAlt: attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'initializer';'
          enterAlternative: attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'initializer';'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: decl-specifier-seq
              => element -> {decl-specifier-seq}
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
            exitElement: decl-specifier-seq
            enterElement: ref-qualifier?
              => element -> [ref-qualifier]
              enterAtom: ref-qualifier
                enterRuleref: ref-qualifier
                exitRuleref: ref-qualifier
              exitAtom: ref-qualifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: ref-qualifier?
            enterElement: '['
              => element -> [
              enterAtom: '['
                enterTerminal: '['
                exitTerminal: '['
              exitAtom: '['
            exitElement: '['
            enterElement: identifier+
              => element -> {identifier}...
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: identifier+
            enterElement: ']'
              => element -> ]
              enterAtom: ']'
                enterTerminal: ']'
                exitTerminal: ']'
              exitAtom: ']'
            exitElement: ']'
            enterElement: initializer
              => element -> {initializer}
              enterAtom: initializer
                enterRuleref: initializer
                exitRuleref: initializer
              exitAtom: initializer
            exitElement: initializer
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'initializer';'
        => elements -> ['[attribute-specifier]...', '{decl-specifier-seq}', '[ref-qualifier]', '[', '{identifier}...', ']', '{initializer}', ';']
            => alternative -> [attribute-specifier]... {decl-specifier-seq} [ref-qualifier] [ {identifier}... ] {initializer} ;
        exitLabeledAlt: attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'initializer';'
      exitRuleAltList: decl-specifier-seqinit-declarator-list?';'|attribute-specifier*decl-specifier-seqinit-declarator-list';'|attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'initializer';'
    exitRuleBlock: decl-specifier-seqinit-declarator-list?';'|attribute-specifier*decl-specifier-seqinit-declarator-list';'|attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'initializer';'
  exitRuleSpec: simple-declaration:decl-specifier-seqinit-declarator-list?';'|attribute-specifier*decl-specifier-seqinit-declarator-list';'|attribute-specifier*decl-specifier-seqref-qualifier?'['identifier+']'initializer';';

  enterRuleSpec: static-assert-declaration:'static-assert('constant-expression');'|'static-assert('constant-expression','static-assert-message');';
    enterRuleBlock: 'static-assert('constant-expression');'|'static-assert('constant-expression','static-assert-message');'
      enterRuleAltList: 'static-assert('constant-expression');'|'static-assert('constant-expression','static-assert-message');'
        enterLabeledAlt: 'static-assert('constant-expression');'
          enterAlternative: 'static-assert('constant-expression');'
            enterElement: 'static-assert('
              => element -> static-assert(
              enterAtom: 'static-assert('
                enterTerminal: 'static-assert('
                exitTerminal: 'static-assert('
              exitAtom: 'static-assert('
            exitElement: 'static-assert('
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
            enterElement: ');'
              => element -> );
              enterAtom: ');'
                enterTerminal: ');'
                exitTerminal: ');'
              exitAtom: ');'
            exitElement: ');'
          exitAlternative: 'static-assert('constant-expression');'
        => elements -> ['static-assert(', '{constant-expression}', ');']
            => alternative -> static-assert( {constant-expression} );
        exitLabeledAlt: 'static-assert('constant-expression');'
        enterLabeledAlt: 'static-assert('constant-expression','static-assert-message');'
          enterAlternative: 'static-assert('constant-expression','static-assert-message');'
            enterElement: 'static-assert('
              => element -> static-assert(
              enterAtom: 'static-assert('
                enterTerminal: 'static-assert('
                exitTerminal: 'static-assert('
              exitAtom: 'static-assert('
            exitElement: 'static-assert('
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: static-assert-message
              => element -> {static-assert-message}
              enterAtom: static-assert-message
                enterRuleref: static-assert-message
                exitRuleref: static-assert-message
              exitAtom: static-assert-message
            exitElement: static-assert-message
            enterElement: ');'
              => element -> );
              enterAtom: ');'
                enterTerminal: ');'
                exitTerminal: ');'
              exitAtom: ');'
            exitElement: ');'
          exitAlternative: 'static-assert('constant-expression','static-assert-message');'
        => elements -> ['static-assert(', '{constant-expression}', ',', '{static-assert-message}', ');']
            => alternative -> static-assert( {constant-expression} , {static-assert-message} );
        exitLabeledAlt: 'static-assert('constant-expression','static-assert-message');'
      exitRuleAltList: 'static-assert('constant-expression');'|'static-assert('constant-expression','static-assert-message');'
    exitRuleBlock: 'static-assert('constant-expression');'|'static-assert('constant-expression','static-assert-message');'
  exitRuleSpec: static-assert-declaration:'static-assert('constant-expression');'|'static-assert('constant-expression','static-assert-message');';

  enterRuleSpec: empty-declaration:';';
    enterRuleBlock: ';'
      enterRuleAltList: ';'
        enterLabeledAlt: ';'
          enterAlternative: ';'
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: ';'
        => elements -> [';']
            => alternative -> ;
        exitLabeledAlt: ';'
      exitRuleAltList: ';'
    exitRuleBlock: ';'
  exitRuleSpec: empty-declaration:';';

  enterRuleSpec: attribute-declaration:attribute-specifier+';';
    enterRuleBlock: attribute-specifier+';'
      enterRuleAltList: attribute-specifier+';'
        enterLabeledAlt: attribute-specifier+';'
          enterAlternative: attribute-specifier+';'
            enterElement: attribute-specifier+
              => element -> {attribute-specifier}...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: attribute-specifier+
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: attribute-specifier+';'
        => elements -> ['{attribute-specifier}...', ';']
            => alternative -> {attribute-specifier}... ;
        exitLabeledAlt: attribute-specifier+';'
      exitRuleAltList: attribute-specifier+';'
    exitRuleBlock: attribute-specifier+';'
  exitRuleSpec: attribute-declaration:attribute-specifier+';';

  enterRuleSpec: decl-specifier:storage-class-specifier|defining-type-specifier|function-specifier|'friend'|'typedef'|'constexpr'|'consteval'|'constinit'|'inline';
    enterRuleBlock: storage-class-specifier|defining-type-specifier|function-specifier|'friend'|'typedef'|'constexpr'|'consteval'|'constinit'|'inline'
      enterRuleAltList: storage-class-specifier|defining-type-specifier|function-specifier|'friend'|'typedef'|'constexpr'|'consteval'|'constinit'|'inline'
        enterLabeledAlt: storage-class-specifier
          enterAlternative: storage-class-specifier
            enterElement: storage-class-specifier
              => element -> {storage-class-specifier}
              enterAtom: storage-class-specifier
                enterRuleref: storage-class-specifier
                exitRuleref: storage-class-specifier
              exitAtom: storage-class-specifier
            exitElement: storage-class-specifier
          exitAlternative: storage-class-specifier
        => elements -> ['{storage-class-specifier}']
            => alternative -> {storage-class-specifier}
        exitLabeledAlt: storage-class-specifier
        enterLabeledAlt: defining-type-specifier
          enterAlternative: defining-type-specifier
            enterElement: defining-type-specifier
              => element -> {defining-type-specifier}
              enterAtom: defining-type-specifier
                enterRuleref: defining-type-specifier
                exitRuleref: defining-type-specifier
              exitAtom: defining-type-specifier
            exitElement: defining-type-specifier
          exitAlternative: defining-type-specifier
        => elements -> ['{defining-type-specifier}']
            => alternative -> {defining-type-specifier}
        exitLabeledAlt: defining-type-specifier
        enterLabeledAlt: function-specifier
          enterAlternative: function-specifier
            enterElement: function-specifier
              => element -> {function-specifier}
              enterAtom: function-specifier
                enterRuleref: function-specifier
                exitRuleref: function-specifier
              exitAtom: function-specifier
            exitElement: function-specifier
          exitAlternative: function-specifier
        => elements -> ['{function-specifier}']
            => alternative -> {function-specifier}
        exitLabeledAlt: function-specifier
        enterLabeledAlt: 'friend'
          enterAlternative: 'friend'
            enterElement: 'friend'
              => element -> friend
              enterAtom: 'friend'
                enterTerminal: 'friend'
                exitTerminal: 'friend'
              exitAtom: 'friend'
            exitElement: 'friend'
          exitAlternative: 'friend'
        => elements -> ['friend']
            => alternative -> friend
        exitLabeledAlt: 'friend'
        enterLabeledAlt: 'typedef'
          enterAlternative: 'typedef'
            enterElement: 'typedef'
              => element -> typedef
              enterAtom: 'typedef'
                enterTerminal: 'typedef'
                exitTerminal: 'typedef'
              exitAtom: 'typedef'
            exitElement: 'typedef'
          exitAlternative: 'typedef'
        => elements -> ['typedef']
            => alternative -> typedef
        exitLabeledAlt: 'typedef'
        enterLabeledAlt: 'constexpr'
          enterAlternative: 'constexpr'
            enterElement: 'constexpr'
              => element -> constexpr
              enterAtom: 'constexpr'
                enterTerminal: 'constexpr'
                exitTerminal: 'constexpr'
              exitAtom: 'constexpr'
            exitElement: 'constexpr'
          exitAlternative: 'constexpr'
        => elements -> ['constexpr']
            => alternative -> constexpr
        exitLabeledAlt: 'constexpr'
        enterLabeledAlt: 'consteval'
          enterAlternative: 'consteval'
            enterElement: 'consteval'
              => element -> consteval
              enterAtom: 'consteval'
                enterTerminal: 'consteval'
                exitTerminal: 'consteval'
              exitAtom: 'consteval'
            exitElement: 'consteval'
          exitAlternative: 'consteval'
        => elements -> ['consteval']
            => alternative -> consteval
        exitLabeledAlt: 'consteval'
        enterLabeledAlt: 'constinit'
          enterAlternative: 'constinit'
            enterElement: 'constinit'
              => element -> constinit
              enterAtom: 'constinit'
                enterTerminal: 'constinit'
                exitTerminal: 'constinit'
              exitAtom: 'constinit'
            exitElement: 'constinit'
          exitAlternative: 'constinit'
        => elements -> ['constinit']
            => alternative -> constinit
        exitLabeledAlt: 'constinit'
        enterLabeledAlt: 'inline'
          enterAlternative: 'inline'
            enterElement: 'inline'
              => element -> inline
              enterAtom: 'inline'
                enterTerminal: 'inline'
                exitTerminal: 'inline'
              exitAtom: 'inline'
            exitElement: 'inline'
          exitAlternative: 'inline'
        => elements -> ['inline']
            => alternative -> inline
        exitLabeledAlt: 'inline'
      exitRuleAltList: storage-class-specifier|defining-type-specifier|function-specifier|'friend'|'typedef'|'constexpr'|'consteval'|'constinit'|'inline'
    exitRuleBlock: storage-class-specifier|defining-type-specifier|function-specifier|'friend'|'typedef'|'constexpr'|'consteval'|'constinit'|'inline'
  exitRuleSpec: decl-specifier:storage-class-specifier|defining-type-specifier|function-specifier|'friend'|'typedef'|'constexpr'|'consteval'|'constinit'|'inline';

  enterRuleSpec: decl-specifier-seq:decl-specifierattribute-specifier*|decl-specifierdecl-specifier-seq;
    enterRuleBlock: decl-specifierattribute-specifier*|decl-specifierdecl-specifier-seq
      enterRuleAltList: decl-specifierattribute-specifier*|decl-specifierdecl-specifier-seq
        enterLabeledAlt: decl-specifierattribute-specifier*
          enterAlternative: decl-specifierattribute-specifier*
            enterElement: decl-specifier
              => element -> {decl-specifier}
              enterAtom: decl-specifier
                enterRuleref: decl-specifier
                exitRuleref: decl-specifier
              exitAtom: decl-specifier
            exitElement: decl-specifier
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
          exitAlternative: decl-specifierattribute-specifier*
        => elements -> ['{decl-specifier}', '[attribute-specifier]...']
            => alternative -> {decl-specifier} [attribute-specifier]...
        exitLabeledAlt: decl-specifierattribute-specifier*
        enterLabeledAlt: decl-specifierdecl-specifier-seq
          enterAlternative: decl-specifierdecl-specifier-seq
            enterElement: decl-specifier
              => element -> {decl-specifier}
              enterAtom: decl-specifier
                enterRuleref: decl-specifier
                exitRuleref: decl-specifier
              exitAtom: decl-specifier
            exitElement: decl-specifier
            enterElement: decl-specifier-seq
              => element -> {decl-specifier-seq}
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
            exitElement: decl-specifier-seq
          exitAlternative: decl-specifierdecl-specifier-seq
        => elements -> ['{decl-specifier}', '{decl-specifier-seq}']
            => alternative -> {decl-specifier} {decl-specifier-seq}
        exitLabeledAlt: decl-specifierdecl-specifier-seq
      exitRuleAltList: decl-specifierattribute-specifier*|decl-specifierdecl-specifier-seq
    exitRuleBlock: decl-specifierattribute-specifier*|decl-specifierdecl-specifier-seq
  exitRuleSpec: decl-specifier-seq:decl-specifierattribute-specifier*|decl-specifierdecl-specifier-seq;

  enterRuleSpec: storage-class-specifier:'static'|'thread_local'|'extern'|'mutable';
    enterRuleBlock: 'static'|'thread_local'|'extern'|'mutable'
      enterRuleAltList: 'static'|'thread_local'|'extern'|'mutable'
        enterLabeledAlt: 'static'
          enterAlternative: 'static'
            enterElement: 'static'
              => element -> static
              enterAtom: 'static'
                enterTerminal: 'static'
                exitTerminal: 'static'
              exitAtom: 'static'
            exitElement: 'static'
          exitAlternative: 'static'
        => elements -> ['static']
            => alternative -> static
        exitLabeledAlt: 'static'
        enterLabeledAlt: 'thread_local'
          enterAlternative: 'thread_local'
            enterElement: 'thread_local'
              => element -> thread_local
              enterAtom: 'thread_local'
                enterTerminal: 'thread_local'
                exitTerminal: 'thread_local'
              exitAtom: 'thread_local'
            exitElement: 'thread_local'
          exitAlternative: 'thread_local'
        => elements -> ['thread_local']
            => alternative -> thread_local
        exitLabeledAlt: 'thread_local'
        enterLabeledAlt: 'extern'
          enterAlternative: 'extern'
            enterElement: 'extern'
              => element -> extern
              enterAtom: 'extern'
                enterTerminal: 'extern'
                exitTerminal: 'extern'
              exitAtom: 'extern'
            exitElement: 'extern'
          exitAlternative: 'extern'
        => elements -> ['extern']
            => alternative -> extern
        exitLabeledAlt: 'extern'
        enterLabeledAlt: 'mutable'
          enterAlternative: 'mutable'
            enterElement: 'mutable'
              => element -> mutable
              enterAtom: 'mutable'
                enterTerminal: 'mutable'
                exitTerminal: 'mutable'
              exitAtom: 'mutable'
            exitElement: 'mutable'
          exitAlternative: 'mutable'
        => elements -> ['mutable']
            => alternative -> mutable
        exitLabeledAlt: 'mutable'
      exitRuleAltList: 'static'|'thread_local'|'extern'|'mutable'
    exitRuleBlock: 'static'|'thread_local'|'extern'|'mutable'
  exitRuleSpec: storage-class-specifier:'static'|'thread_local'|'extern'|'mutable';

  enterRuleSpec: function-specifier:'virtual'|explicit-specifier;
    enterRuleBlock: 'virtual'|explicit-specifier
      enterRuleAltList: 'virtual'|explicit-specifier
        enterLabeledAlt: 'virtual'
          enterAlternative: 'virtual'
            enterElement: 'virtual'
              => element -> virtual
              enterAtom: 'virtual'
                enterTerminal: 'virtual'
                exitTerminal: 'virtual'
              exitAtom: 'virtual'
            exitElement: 'virtual'
          exitAlternative: 'virtual'
        => elements -> ['virtual']
            => alternative -> virtual
        exitLabeledAlt: 'virtual'
        enterLabeledAlt: explicit-specifier
          enterAlternative: explicit-specifier
            enterElement: explicit-specifier
              => element -> {explicit-specifier}
              enterAtom: explicit-specifier
                enterRuleref: explicit-specifier
                exitRuleref: explicit-specifier
              exitAtom: explicit-specifier
            exitElement: explicit-specifier
          exitAlternative: explicit-specifier
        => elements -> ['{explicit-specifier}']
            => alternative -> {explicit-specifier}
        exitLabeledAlt: explicit-specifier
      exitRuleAltList: 'virtual'|explicit-specifier
    exitRuleBlock: 'virtual'|explicit-specifier
  exitRuleSpec: function-specifier:'virtual'|explicit-specifier;

  enterRuleSpec: explicit-specifier:'explicit('constant-expression')'|'explicit';
    enterRuleBlock: 'explicit('constant-expression')'|'explicit'
      enterRuleAltList: 'explicit('constant-expression')'|'explicit'
        enterLabeledAlt: 'explicit('constant-expression')'
          enterAlternative: 'explicit('constant-expression')'
            enterElement: 'explicit('
              => element -> explicit(
              enterAtom: 'explicit('
                enterTerminal: 'explicit('
                exitTerminal: 'explicit('
              exitAtom: 'explicit('
            exitElement: 'explicit('
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'explicit('constant-expression')'
        => elements -> ['explicit(', '{constant-expression}', ')']
            => alternative -> explicit( {constant-expression} )
        exitLabeledAlt: 'explicit('constant-expression')'
        enterLabeledAlt: 'explicit'
          enterAlternative: 'explicit'
            enterElement: 'explicit'
              => element -> explicit
              enterAtom: 'explicit'
                enterTerminal: 'explicit'
                exitTerminal: 'explicit'
              exitAtom: 'explicit'
            exitElement: 'explicit'
          exitAlternative: 'explicit'
        => elements -> ['explicit']
            => alternative -> explicit
        exitLabeledAlt: 'explicit'
      exitRuleAltList: 'explicit('constant-expression')'|'explicit'
    exitRuleBlock: 'explicit('constant-expression')'|'explicit'
  exitRuleSpec: explicit-specifier:'explicit('constant-expression')'|'explicit';

  enterRuleSpec: typedef-name:identifier|simple-template-id;
    enterRuleBlock: identifier|simple-template-id
      enterRuleAltList: identifier|simple-template-id
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
        enterLabeledAlt: simple-template-id
          enterAlternative: simple-template-id
            enterElement: simple-template-id
              => element -> {simple-template-id}
              enterAtom: simple-template-id
                enterRuleref: simple-template-id
                exitRuleref: simple-template-id
              exitAtom: simple-template-id
            exitElement: simple-template-id
          exitAlternative: simple-template-id
        => elements -> ['{simple-template-id}']
            => alternative -> {simple-template-id}
        exitLabeledAlt: simple-template-id
      exitRuleAltList: identifier|simple-template-id
    exitRuleBlock: identifier|simple-template-id
  exitRuleSpec: typedef-name:identifier|simple-template-id;

  enterRuleSpec: type-specifier:simple-type-specifier|elaborated-type-specifier|typename-specifier|cv-qualifier;
    enterRuleBlock: simple-type-specifier|elaborated-type-specifier|typename-specifier|cv-qualifier
      enterRuleAltList: simple-type-specifier|elaborated-type-specifier|typename-specifier|cv-qualifier
        enterLabeledAlt: simple-type-specifier
          enterAlternative: simple-type-specifier
            enterElement: simple-type-specifier
              => element -> {simple-type-specifier}
              enterAtom: simple-type-specifier
                enterRuleref: simple-type-specifier
                exitRuleref: simple-type-specifier
              exitAtom: simple-type-specifier
            exitElement: simple-type-specifier
          exitAlternative: simple-type-specifier
        => elements -> ['{simple-type-specifier}']
            => alternative -> {simple-type-specifier}
        exitLabeledAlt: simple-type-specifier
        enterLabeledAlt: elaborated-type-specifier
          enterAlternative: elaborated-type-specifier
            enterElement: elaborated-type-specifier
              => element -> {elaborated-type-specifier}
              enterAtom: elaborated-type-specifier
                enterRuleref: elaborated-type-specifier
                exitRuleref: elaborated-type-specifier
              exitAtom: elaborated-type-specifier
            exitElement: elaborated-type-specifier
          exitAlternative: elaborated-type-specifier
        => elements -> ['{elaborated-type-specifier}']
            => alternative -> {elaborated-type-specifier}
        exitLabeledAlt: elaborated-type-specifier
        enterLabeledAlt: typename-specifier
          enterAlternative: typename-specifier
            enterElement: typename-specifier
              => element -> {typename-specifier}
              enterAtom: typename-specifier
                enterRuleref: typename-specifier
                exitRuleref: typename-specifier
              exitAtom: typename-specifier
            exitElement: typename-specifier
          exitAlternative: typename-specifier
        => elements -> ['{typename-specifier}']
            => alternative -> {typename-specifier}
        exitLabeledAlt: typename-specifier
        enterLabeledAlt: cv-qualifier
          enterAlternative: cv-qualifier
            enterElement: cv-qualifier
              => element -> {cv-qualifier}
              enterAtom: cv-qualifier
                enterRuleref: cv-qualifier
                exitRuleref: cv-qualifier
              exitAtom: cv-qualifier
            exitElement: cv-qualifier
          exitAlternative: cv-qualifier
        => elements -> ['{cv-qualifier}']
            => alternative -> {cv-qualifier}
        exitLabeledAlt: cv-qualifier
      exitRuleAltList: simple-type-specifier|elaborated-type-specifier|typename-specifier|cv-qualifier
    exitRuleBlock: simple-type-specifier|elaborated-type-specifier|typename-specifier|cv-qualifier
  exitRuleSpec: type-specifier:simple-type-specifier|elaborated-type-specifier|typename-specifier|cv-qualifier;

  enterRuleSpec: type-specifier-seq:type-specifierattribute-specifier*|type-specifiertype-specifier-seq;
    enterRuleBlock: type-specifierattribute-specifier*|type-specifiertype-specifier-seq
      enterRuleAltList: type-specifierattribute-specifier*|type-specifiertype-specifier-seq
        enterLabeledAlt: type-specifierattribute-specifier*
          enterAlternative: type-specifierattribute-specifier*
            enterElement: type-specifier
              => element -> {type-specifier}
              enterAtom: type-specifier
                enterRuleref: type-specifier
                exitRuleref: type-specifier
              exitAtom: type-specifier
            exitElement: type-specifier
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
          exitAlternative: type-specifierattribute-specifier*
        => elements -> ['{type-specifier}', '[attribute-specifier]...']
            => alternative -> {type-specifier} [attribute-specifier]...
        exitLabeledAlt: type-specifierattribute-specifier*
        enterLabeledAlt: type-specifiertype-specifier-seq
          enterAlternative: type-specifiertype-specifier-seq
            enterElement: type-specifier
              => element -> {type-specifier}
              enterAtom: type-specifier
                enterRuleref: type-specifier
                exitRuleref: type-specifier
              exitAtom: type-specifier
            exitElement: type-specifier
            enterElement: type-specifier-seq
              => element -> {type-specifier-seq}
              enterAtom: type-specifier-seq
                enterRuleref: type-specifier-seq
                exitRuleref: type-specifier-seq
              exitAtom: type-specifier-seq
            exitElement: type-specifier-seq
          exitAlternative: type-specifiertype-specifier-seq
        => elements -> ['{type-specifier}', '{type-specifier-seq}']
            => alternative -> {type-specifier} {type-specifier-seq}
        exitLabeledAlt: type-specifiertype-specifier-seq
      exitRuleAltList: type-specifierattribute-specifier*|type-specifiertype-specifier-seq
    exitRuleBlock: type-specifierattribute-specifier*|type-specifiertype-specifier-seq
  exitRuleSpec: type-specifier-seq:type-specifierattribute-specifier*|type-specifiertype-specifier-seq;

  enterRuleSpec: defining-type-specifier:type-specifier|class-specifier|enum-specifier;
    enterRuleBlock: type-specifier|class-specifier|enum-specifier
      enterRuleAltList: type-specifier|class-specifier|enum-specifier
        enterLabeledAlt: type-specifier
          enterAlternative: type-specifier
            enterElement: type-specifier
              => element -> {type-specifier}
              enterAtom: type-specifier
                enterRuleref: type-specifier
                exitRuleref: type-specifier
              exitAtom: type-specifier
            exitElement: type-specifier
          exitAlternative: type-specifier
        => elements -> ['{type-specifier}']
            => alternative -> {type-specifier}
        exitLabeledAlt: type-specifier
        enterLabeledAlt: class-specifier
          enterAlternative: class-specifier
            enterElement: class-specifier
              => element -> {class-specifier}
              enterAtom: class-specifier
                enterRuleref: class-specifier
                exitRuleref: class-specifier
              exitAtom: class-specifier
            exitElement: class-specifier
          exitAlternative: class-specifier
        => elements -> ['{class-specifier}']
            => alternative -> {class-specifier}
        exitLabeledAlt: class-specifier
        enterLabeledAlt: enum-specifier
          enterAlternative: enum-specifier
            enterElement: enum-specifier
              => element -> {enum-specifier}
              enterAtom: enum-specifier
                enterRuleref: enum-specifier
                exitRuleref: enum-specifier
              exitAtom: enum-specifier
            exitElement: enum-specifier
          exitAlternative: enum-specifier
        => elements -> ['{enum-specifier}']
            => alternative -> {enum-specifier}
        exitLabeledAlt: enum-specifier
      exitRuleAltList: type-specifier|class-specifier|enum-specifier
    exitRuleBlock: type-specifier|class-specifier|enum-specifier
  exitRuleSpec: defining-type-specifier:type-specifier|class-specifier|enum-specifier;

  enterRuleSpec: defining-type-specifier-seq:defining-type-specifierattribute-specifier*|defining-type-specifierdefining-type-specifier-seq;
    enterRuleBlock: defining-type-specifierattribute-specifier*|defining-type-specifierdefining-type-specifier-seq
      enterRuleAltList: defining-type-specifierattribute-specifier*|defining-type-specifierdefining-type-specifier-seq
        enterLabeledAlt: defining-type-specifierattribute-specifier*
          enterAlternative: defining-type-specifierattribute-specifier*
            enterElement: defining-type-specifier
              => element -> {defining-type-specifier}
              enterAtom: defining-type-specifier
                enterRuleref: defining-type-specifier
                exitRuleref: defining-type-specifier
              exitAtom: defining-type-specifier
            exitElement: defining-type-specifier
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
          exitAlternative: defining-type-specifierattribute-specifier*
        => elements -> ['{defining-type-specifier}', '[attribute-specifier]...']
            => alternative -> {defining-type-specifier} [attribute-specifier]...
        exitLabeledAlt: defining-type-specifierattribute-specifier*
        enterLabeledAlt: defining-type-specifierdefining-type-specifier-seq
          enterAlternative: defining-type-specifierdefining-type-specifier-seq
            enterElement: defining-type-specifier
              => element -> {defining-type-specifier}
              enterAtom: defining-type-specifier
                enterRuleref: defining-type-specifier
                exitRuleref: defining-type-specifier
              exitAtom: defining-type-specifier
            exitElement: defining-type-specifier
            enterElement: defining-type-specifier-seq
              => element -> {defining-type-specifier-seq}
              enterAtom: defining-type-specifier-seq
                enterRuleref: defining-type-specifier-seq
                exitRuleref: defining-type-specifier-seq
              exitAtom: defining-type-specifier-seq
            exitElement: defining-type-specifier-seq
          exitAlternative: defining-type-specifierdefining-type-specifier-seq
        => elements -> ['{defining-type-specifier}', '{defining-type-specifier-seq}']
            => alternative -> {defining-type-specifier} {defining-type-specifier-seq}
        exitLabeledAlt: defining-type-specifierdefining-type-specifier-seq
      exitRuleAltList: defining-type-specifierattribute-specifier*|defining-type-specifierdefining-type-specifier-seq
    exitRuleBlock: defining-type-specifierattribute-specifier*|defining-type-specifierdefining-type-specifier-seq
  exitRuleSpec: defining-type-specifier-seq:defining-type-specifierattribute-specifier*|defining-type-specifierdefining-type-specifier-seq;

  enterRuleSpec: simple-type-specifier:nested-name-specifier?type-name|nested-name-specifier'template'simple-template-id|computed-type-specifier|placeholder-type-specifier|nested-name-specifier?template-name|'char'|'char8_t'|'char16_t'|'char32_t'|'wchar_t'|'bool'|'short'|'int'|'long'|'signed'|'unsigned'|'float'|'double'|'void';
    enterRuleBlock: nested-name-specifier?type-name|nested-name-specifier'template'simple-template-id|computed-type-specifier|placeholder-type-specifier|nested-name-specifier?template-name|'char'|'char8_t'|'char16_t'|'char32_t'|'wchar_t'|'bool'|'short'|'int'|'long'|'signed'|'unsigned'|'float'|'double'|'void'
      enterRuleAltList: nested-name-specifier?type-name|nested-name-specifier'template'simple-template-id|computed-type-specifier|placeholder-type-specifier|nested-name-specifier?template-name|'char'|'char8_t'|'char16_t'|'char32_t'|'wchar_t'|'bool'|'short'|'int'|'long'|'signed'|'unsigned'|'float'|'double'|'void'
        enterLabeledAlt: nested-name-specifier?type-name
          enterAlternative: nested-name-specifier?type-name
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: type-name
              => element -> {type-name}
              enterAtom: type-name
                enterRuleref: type-name
                exitRuleref: type-name
              exitAtom: type-name
            exitElement: type-name
          exitAlternative: nested-name-specifier?type-name
        => elements -> ['[nested-name-specifier]', '{type-name}']
            => alternative -> [nested-name-specifier] {type-name}
        exitLabeledAlt: nested-name-specifier?type-name
        enterLabeledAlt: nested-name-specifier'template'simple-template-id
          enterAlternative: nested-name-specifier'template'simple-template-id
            enterElement: nested-name-specifier
              => element -> {nested-name-specifier}
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
            exitElement: nested-name-specifier
            enterElement: 'template'
              => element -> template
              enterAtom: 'template'
                enterTerminal: 'template'
                exitTerminal: 'template'
              exitAtom: 'template'
            exitElement: 'template'
            enterElement: simple-template-id
              => element -> {simple-template-id}
              enterAtom: simple-template-id
                enterRuleref: simple-template-id
                exitRuleref: simple-template-id
              exitAtom: simple-template-id
            exitElement: simple-template-id
          exitAlternative: nested-name-specifier'template'simple-template-id
        => elements -> ['{nested-name-specifier}', 'template', '{simple-template-id}']
            => alternative -> {nested-name-specifier} template {simple-template-id}
        exitLabeledAlt: nested-name-specifier'template'simple-template-id
        enterLabeledAlt: computed-type-specifier
          enterAlternative: computed-type-specifier
            enterElement: computed-type-specifier
              => element -> {computed-type-specifier}
              enterAtom: computed-type-specifier
                enterRuleref: computed-type-specifier
                exitRuleref: computed-type-specifier
              exitAtom: computed-type-specifier
            exitElement: computed-type-specifier
          exitAlternative: computed-type-specifier
        => elements -> ['{computed-type-specifier}']
            => alternative -> {computed-type-specifier}
        exitLabeledAlt: computed-type-specifier
        enterLabeledAlt: placeholder-type-specifier
          enterAlternative: placeholder-type-specifier
            enterElement: placeholder-type-specifier
              => element -> {placeholder-type-specifier}
              enterAtom: placeholder-type-specifier
                enterRuleref: placeholder-type-specifier
                exitRuleref: placeholder-type-specifier
              exitAtom: placeholder-type-specifier
            exitElement: placeholder-type-specifier
          exitAlternative: placeholder-type-specifier
        => elements -> ['{placeholder-type-specifier}']
            => alternative -> {placeholder-type-specifier}
        exitLabeledAlt: placeholder-type-specifier
        enterLabeledAlt: nested-name-specifier?template-name
          enterAlternative: nested-name-specifier?template-name
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: template-name
              => element -> {template-name}
              enterAtom: template-name
                enterRuleref: template-name
                exitRuleref: template-name
              exitAtom: template-name
            exitElement: template-name
          exitAlternative: nested-name-specifier?template-name
        => elements -> ['[nested-name-specifier]', '{template-name}']
            => alternative -> [nested-name-specifier] {template-name}
        exitLabeledAlt: nested-name-specifier?template-name
        enterLabeledAlt: 'char'
          enterAlternative: 'char'
            enterElement: 'char'
              => element -> char
              enterAtom: 'char'
                enterTerminal: 'char'
                exitTerminal: 'char'
              exitAtom: 'char'
            exitElement: 'char'
          exitAlternative: 'char'
        => elements -> ['char']
            => alternative -> char
        exitLabeledAlt: 'char'
        enterLabeledAlt: 'char8_t'
          enterAlternative: 'char8_t'
            enterElement: 'char8_t'
              => element -> char8_t
              enterAtom: 'char8_t'
                enterTerminal: 'char8_t'
                exitTerminal: 'char8_t'
              exitAtom: 'char8_t'
            exitElement: 'char8_t'
          exitAlternative: 'char8_t'
        => elements -> ['char8_t']
            => alternative -> char8_t
        exitLabeledAlt: 'char8_t'
        enterLabeledAlt: 'char16_t'
          enterAlternative: 'char16_t'
            enterElement: 'char16_t'
              => element -> char16_t
              enterAtom: 'char16_t'
                enterTerminal: 'char16_t'
                exitTerminal: 'char16_t'
              exitAtom: 'char16_t'
            exitElement: 'char16_t'
          exitAlternative: 'char16_t'
        => elements -> ['char16_t']
            => alternative -> char16_t
        exitLabeledAlt: 'char16_t'
        enterLabeledAlt: 'char32_t'
          enterAlternative: 'char32_t'
            enterElement: 'char32_t'
              => element -> char32_t
              enterAtom: 'char32_t'
                enterTerminal: 'char32_t'
                exitTerminal: 'char32_t'
              exitAtom: 'char32_t'
            exitElement: 'char32_t'
          exitAlternative: 'char32_t'
        => elements -> ['char32_t']
            => alternative -> char32_t
        exitLabeledAlt: 'char32_t'
        enterLabeledAlt: 'wchar_t'
          enterAlternative: 'wchar_t'
            enterElement: 'wchar_t'
              => element -> wchar_t
              enterAtom: 'wchar_t'
                enterTerminal: 'wchar_t'
                exitTerminal: 'wchar_t'
              exitAtom: 'wchar_t'
            exitElement: 'wchar_t'
          exitAlternative: 'wchar_t'
        => elements -> ['wchar_t']
            => alternative -> wchar_t
        exitLabeledAlt: 'wchar_t'
        enterLabeledAlt: 'bool'
          enterAlternative: 'bool'
            enterElement: 'bool'
              => element -> bool
              enterAtom: 'bool'
                enterTerminal: 'bool'
                exitTerminal: 'bool'
              exitAtom: 'bool'
            exitElement: 'bool'
          exitAlternative: 'bool'
        => elements -> ['bool']
            => alternative -> bool
        exitLabeledAlt: 'bool'
        enterLabeledAlt: 'short'
          enterAlternative: 'short'
            enterElement: 'short'
              => element -> short
              enterAtom: 'short'
                enterTerminal: 'short'
                exitTerminal: 'short'
              exitAtom: 'short'
            exitElement: 'short'
          exitAlternative: 'short'
        => elements -> ['short']
            => alternative -> short
        exitLabeledAlt: 'short'
        enterLabeledAlt: 'int'
          enterAlternative: 'int'
            enterElement: 'int'
              => element -> int
              enterAtom: 'int'
                enterTerminal: 'int'
                exitTerminal: 'int'
              exitAtom: 'int'
            exitElement: 'int'
          exitAlternative: 'int'
        => elements -> ['int']
            => alternative -> int
        exitLabeledAlt: 'int'
        enterLabeledAlt: 'long'
          enterAlternative: 'long'
            enterElement: 'long'
              => element -> long
              enterAtom: 'long'
                enterTerminal: 'long'
                exitTerminal: 'long'
              exitAtom: 'long'
            exitElement: 'long'
          exitAlternative: 'long'
        => elements -> ['long']
            => alternative -> long
        exitLabeledAlt: 'long'
        enterLabeledAlt: 'signed'
          enterAlternative: 'signed'
            enterElement: 'signed'
              => element -> signed
              enterAtom: 'signed'
                enterTerminal: 'signed'
                exitTerminal: 'signed'
              exitAtom: 'signed'
            exitElement: 'signed'
          exitAlternative: 'signed'
        => elements -> ['signed']
            => alternative -> signed
        exitLabeledAlt: 'signed'
        enterLabeledAlt: 'unsigned'
          enterAlternative: 'unsigned'
            enterElement: 'unsigned'
              => element -> unsigned
              enterAtom: 'unsigned'
                enterTerminal: 'unsigned'
                exitTerminal: 'unsigned'
              exitAtom: 'unsigned'
            exitElement: 'unsigned'
          exitAlternative: 'unsigned'
        => elements -> ['unsigned']
            => alternative -> unsigned
        exitLabeledAlt: 'unsigned'
        enterLabeledAlt: 'float'
          enterAlternative: 'float'
            enterElement: 'float'
              => element -> float
              enterAtom: 'float'
                enterTerminal: 'float'
                exitTerminal: 'float'
              exitAtom: 'float'
            exitElement: 'float'
          exitAlternative: 'float'
        => elements -> ['float']
            => alternative -> float
        exitLabeledAlt: 'float'
        enterLabeledAlt: 'double'
          enterAlternative: 'double'
            enterElement: 'double'
              => element -> double
              enterAtom: 'double'
                enterTerminal: 'double'
                exitTerminal: 'double'
              exitAtom: 'double'
            exitElement: 'double'
          exitAlternative: 'double'
        => elements -> ['double']
            => alternative -> double
        exitLabeledAlt: 'double'
        enterLabeledAlt: 'void'
          enterAlternative: 'void'
            enterElement: 'void'
              => element -> void
              enterAtom: 'void'
                enterTerminal: 'void'
                exitTerminal: 'void'
              exitAtom: 'void'
            exitElement: 'void'
          exitAlternative: 'void'
        => elements -> ['void']
            => alternative -> void
        exitLabeledAlt: 'void'
      exitRuleAltList: nested-name-specifier?type-name|nested-name-specifier'template'simple-template-id|computed-type-specifier|placeholder-type-specifier|nested-name-specifier?template-name|'char'|'char8_t'|'char16_t'|'char32_t'|'wchar_t'|'bool'|'short'|'int'|'long'|'signed'|'unsigned'|'float'|'double'|'void'
    exitRuleBlock: nested-name-specifier?type-name|nested-name-specifier'template'simple-template-id|computed-type-specifier|placeholder-type-specifier|nested-name-specifier?template-name|'char'|'char8_t'|'char16_t'|'char32_t'|'wchar_t'|'bool'|'short'|'int'|'long'|'signed'|'unsigned'|'float'|'double'|'void'
  exitRuleSpec: simple-type-specifier:nested-name-specifier?type-name|nested-name-specifier'template'simple-template-id|computed-type-specifier|placeholder-type-specifier|nested-name-specifier?template-name|'char'|'char8_t'|'char16_t'|'char32_t'|'wchar_t'|'bool'|'short'|'int'|'long'|'signed'|'unsigned'|'float'|'double'|'void';

  enterRuleSpec: type-name:class-name|enum-name|typedef-name;
    enterRuleBlock: class-name|enum-name|typedef-name
      enterRuleAltList: class-name|enum-name|typedef-name
        enterLabeledAlt: class-name
          enterAlternative: class-name
            enterElement: class-name
              => element -> {class-name}
              enterAtom: class-name
                enterRuleref: class-name
                exitRuleref: class-name
              exitAtom: class-name
            exitElement: class-name
          exitAlternative: class-name
        => elements -> ['{class-name}']
            => alternative -> {class-name}
        exitLabeledAlt: class-name
        enterLabeledAlt: enum-name
          enterAlternative: enum-name
            enterElement: enum-name
              => element -> {enum-name}
              enterAtom: enum-name
                enterRuleref: enum-name
                exitRuleref: enum-name
              exitAtom: enum-name
            exitElement: enum-name
          exitAlternative: enum-name
        => elements -> ['{enum-name}']
            => alternative -> {enum-name}
        exitLabeledAlt: enum-name
        enterLabeledAlt: typedef-name
          enterAlternative: typedef-name
            enterElement: typedef-name
              => element -> {typedef-name}
              enterAtom: typedef-name
                enterRuleref: typedef-name
                exitRuleref: typedef-name
              exitAtom: typedef-name
            exitElement: typedef-name
          exitAlternative: typedef-name
        => elements -> ['{typedef-name}']
            => alternative -> {typedef-name}
        exitLabeledAlt: typedef-name
      exitRuleAltList: class-name|enum-name|typedef-name
    exitRuleBlock: class-name|enum-name|typedef-name
  exitRuleSpec: type-name:class-name|enum-name|typedef-name;

  enterRuleSpec: computed-type-specifier:decltype-specifier|pack-index-specifier;
    enterRuleBlock: decltype-specifier|pack-index-specifier
      enterRuleAltList: decltype-specifier|pack-index-specifier
        enterLabeledAlt: decltype-specifier
          enterAlternative: decltype-specifier
            enterElement: decltype-specifier
              => element -> {decltype-specifier}
              enterAtom: decltype-specifier
                enterRuleref: decltype-specifier
                exitRuleref: decltype-specifier
              exitAtom: decltype-specifier
            exitElement: decltype-specifier
          exitAlternative: decltype-specifier
        => elements -> ['{decltype-specifier}']
            => alternative -> {decltype-specifier}
        exitLabeledAlt: decltype-specifier
        enterLabeledAlt: pack-index-specifier
          enterAlternative: pack-index-specifier
            enterElement: pack-index-specifier
              => element -> {pack-index-specifier}
              enterAtom: pack-index-specifier
                enterRuleref: pack-index-specifier
                exitRuleref: pack-index-specifier
              exitAtom: pack-index-specifier
            exitElement: pack-index-specifier
          exitAlternative: pack-index-specifier
        => elements -> ['{pack-index-specifier}']
            => alternative -> {pack-index-specifier}
        exitLabeledAlt: pack-index-specifier
      exitRuleAltList: decltype-specifier|pack-index-specifier
    exitRuleBlock: decltype-specifier|pack-index-specifier
  exitRuleSpec: computed-type-specifier:decltype-specifier|pack-index-specifier;

  enterRuleSpec: pack-index-specifier:typedef-name'...['constant-expression']';
    enterRuleBlock: typedef-name'...['constant-expression']'
      enterRuleAltList: typedef-name'...['constant-expression']'
        enterLabeledAlt: typedef-name'...['constant-expression']'
          enterAlternative: typedef-name'...['constant-expression']'
            enterElement: typedef-name
              => element -> {typedef-name}
              enterAtom: typedef-name
                enterRuleref: typedef-name
                exitRuleref: typedef-name
              exitAtom: typedef-name
            exitElement: typedef-name
            enterElement: '...['
              => element -> ...[
              enterAtom: '...['
                enterTerminal: '...['
                exitTerminal: '...['
              exitAtom: '...['
            exitElement: '...['
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
            enterElement: ']'
              => element -> ]
              enterAtom: ']'
                enterTerminal: ']'
                exitTerminal: ']'
              exitAtom: ']'
            exitElement: ']'
          exitAlternative: typedef-name'...['constant-expression']'
        => elements -> ['{typedef-name}', '...[', '{constant-expression}', ']']
            => alternative -> {typedef-name} ...[ {constant-expression} ]
        exitLabeledAlt: typedef-name'...['constant-expression']'
      exitRuleAltList: typedef-name'...['constant-expression']'
    exitRuleBlock: typedef-name'...['constant-expression']'
  exitRuleSpec: pack-index-specifier:typedef-name'...['constant-expression']';

  enterRuleSpec: elaborated-type-specifier:class-keyattribute-specifier*nested-name-specifier?identifier|class-keysimple-template-id|class-keynested-name-specifiertemplate?simple-template-id|'enum'nested-name-specifier?identifier;
    enterRuleBlock: class-keyattribute-specifier*nested-name-specifier?identifier|class-keysimple-template-id|class-keynested-name-specifiertemplate?simple-template-id|'enum'nested-name-specifier?identifier
      enterRuleAltList: class-keyattribute-specifier*nested-name-specifier?identifier|class-keysimple-template-id|class-keynested-name-specifiertemplate?simple-template-id|'enum'nested-name-specifier?identifier
        enterLabeledAlt: class-keyattribute-specifier*nested-name-specifier?identifier
          enterAlternative: class-keyattribute-specifier*nested-name-specifier?identifier
            enterElement: class-key
              => element -> {class-key}
              enterAtom: class-key
                enterRuleref: class-key
                exitRuleref: class-key
              exitAtom: class-key
            exitElement: class-key
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: class-keyattribute-specifier*nested-name-specifier?identifier
        => elements -> ['{class-key}', '[attribute-specifier]...', '[nested-name-specifier]', '{identifier}']
            => alternative -> {class-key} [attribute-specifier]... [nested-name-specifier] {identifier}
        exitLabeledAlt: class-keyattribute-specifier*nested-name-specifier?identifier
        enterLabeledAlt: class-keysimple-template-id
          enterAlternative: class-keysimple-template-id
            enterElement: class-key
              => element -> {class-key}
              enterAtom: class-key
                enterRuleref: class-key
                exitRuleref: class-key
              exitAtom: class-key
            exitElement: class-key
            enterElement: simple-template-id
              => element -> {simple-template-id}
              enterAtom: simple-template-id
                enterRuleref: simple-template-id
                exitRuleref: simple-template-id
              exitAtom: simple-template-id
            exitElement: simple-template-id
          exitAlternative: class-keysimple-template-id
        => elements -> ['{class-key}', '{simple-template-id}']
            => alternative -> {class-key} {simple-template-id}
        exitLabeledAlt: class-keysimple-template-id
        enterLabeledAlt: class-keynested-name-specifiertemplate?simple-template-id
          enterAlternative: class-keynested-name-specifiertemplate?simple-template-id
            enterElement: class-key
              => element -> {class-key}
              enterAtom: class-key
                enterRuleref: class-key
                exitRuleref: class-key
              exitAtom: class-key
            exitElement: class-key
            enterElement: nested-name-specifier
              => element -> {nested-name-specifier}
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
            exitElement: nested-name-specifier
            enterElement: template?
              => element -> [template]
              enterAtom: template
                enterRuleref: template
                exitRuleref: template
              exitAtom: template
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: template?
            enterElement: simple-template-id
              => element -> {simple-template-id}
              enterAtom: simple-template-id
                enterRuleref: simple-template-id
                exitRuleref: simple-template-id
              exitAtom: simple-template-id
            exitElement: simple-template-id
          exitAlternative: class-keynested-name-specifiertemplate?simple-template-id
        => elements -> ['{class-key}', '{nested-name-specifier}', '[template]', '{simple-template-id}']
            => alternative -> {class-key} {nested-name-specifier} [template] {simple-template-id}
        exitLabeledAlt: class-keynested-name-specifiertemplate?simple-template-id
        enterLabeledAlt: 'enum'nested-name-specifier?identifier
          enterAlternative: 'enum'nested-name-specifier?identifier
            enterElement: 'enum'
              => element -> enum
              enterAtom: 'enum'
                enterTerminal: 'enum'
                exitTerminal: 'enum'
              exitAtom: 'enum'
            exitElement: 'enum'
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: 'enum'nested-name-specifier?identifier
        => elements -> ['enum', '[nested-name-specifier]', '{identifier}']
            => alternative -> enum [nested-name-specifier] {identifier}
        exitLabeledAlt: 'enum'nested-name-specifier?identifier
      exitRuleAltList: class-keyattribute-specifier*nested-name-specifier?identifier|class-keysimple-template-id|class-keynested-name-specifiertemplate?simple-template-id|'enum'nested-name-specifier?identifier
    exitRuleBlock: class-keyattribute-specifier*nested-name-specifier?identifier|class-keysimple-template-id|class-keynested-name-specifiertemplate?simple-template-id|'enum'nested-name-specifier?identifier
  exitRuleSpec: elaborated-type-specifier:class-keyattribute-specifier*nested-name-specifier?identifier|class-keysimple-template-id|class-keynested-name-specifiertemplate?simple-template-id|'enum'nested-name-specifier?identifier;

  enterRuleSpec: decltype-specifier:'decltype('expression')';
    enterRuleBlock: 'decltype('expression')'
      enterRuleAltList: 'decltype('expression')'
        enterLabeledAlt: 'decltype('expression')'
          enterAlternative: 'decltype('expression')'
            enterElement: 'decltype('
              => element -> decltype(
              enterAtom: 'decltype('
                enterTerminal: 'decltype('
                exitTerminal: 'decltype('
              exitAtom: 'decltype('
            exitElement: 'decltype('
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'decltype('expression')'
        => elements -> ['decltype(', '{expression}', ')']
            => alternative -> decltype( {expression} )
        exitLabeledAlt: 'decltype('expression')'
      exitRuleAltList: 'decltype('expression')'
    exitRuleBlock: 'decltype('expression')'
  exitRuleSpec: decltype-specifier:'decltype('expression')';

  enterRuleSpec: placeholder-type-specifier:type-constraint?'auto'|type-constraint?'decltype(auto)';
    enterRuleBlock: type-constraint?'auto'|type-constraint?'decltype(auto)'
      enterRuleAltList: type-constraint?'auto'|type-constraint?'decltype(auto)'
        enterLabeledAlt: type-constraint?'auto'
          enterAlternative: type-constraint?'auto'
            enterElement: type-constraint?
              => element -> [type-constraint]
              enterAtom: type-constraint
                enterRuleref: type-constraint
                exitRuleref: type-constraint
              exitAtom: type-constraint
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: type-constraint?
            enterElement: 'auto'
              => element -> auto
              enterAtom: 'auto'
                enterTerminal: 'auto'
                exitTerminal: 'auto'
              exitAtom: 'auto'
            exitElement: 'auto'
          exitAlternative: type-constraint?'auto'
        => elements -> ['[type-constraint]', 'auto']
            => alternative -> [type-constraint] auto
        exitLabeledAlt: type-constraint?'auto'
        enterLabeledAlt: type-constraint?'decltype(auto)'
          enterAlternative: type-constraint?'decltype(auto)'
            enterElement: type-constraint?
              => element -> [type-constraint]
              enterAtom: type-constraint
                enterRuleref: type-constraint
                exitRuleref: type-constraint
              exitAtom: type-constraint
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: type-constraint?
            enterElement: 'decltype(auto)'
              => element -> decltype(auto)
              enterAtom: 'decltype(auto)'
                enterTerminal: 'decltype(auto)'
                exitTerminal: 'decltype(auto)'
              exitAtom: 'decltype(auto)'
            exitElement: 'decltype(auto)'
          exitAlternative: type-constraint?'decltype(auto)'
        => elements -> ['[type-constraint]', 'decltype(auto)']
            => alternative -> [type-constraint] decltype(auto)
        exitLabeledAlt: type-constraint?'decltype(auto)'
      exitRuleAltList: type-constraint?'auto'|type-constraint?'decltype(auto)'
    exitRuleBlock: type-constraint?'auto'|type-constraint?'decltype(auto)'
  exitRuleSpec: placeholder-type-specifier:type-constraint?'auto'|type-constraint?'decltype(auto)';

  enterRuleSpec: init-declarator-list:init-declarator|init-declarator-list','init-declarator;
    enterRuleBlock: init-declarator|init-declarator-list','init-declarator
      enterRuleAltList: init-declarator|init-declarator-list','init-declarator
        enterLabeledAlt: init-declarator
          enterAlternative: init-declarator
            enterElement: init-declarator
              => element -> {init-declarator}
              enterAtom: init-declarator
                enterRuleref: init-declarator
                exitRuleref: init-declarator
              exitAtom: init-declarator
            exitElement: init-declarator
          exitAlternative: init-declarator
        => elements -> ['{init-declarator}']
            => alternative -> {init-declarator}
        exitLabeledAlt: init-declarator
        enterLabeledAlt: init-declarator-list','init-declarator
          enterAlternative: init-declarator-list','init-declarator
            enterElement: init-declarator-list
              => element -> {init-declarator-list}
              enterAtom: init-declarator-list
                enterRuleref: init-declarator-list
                exitRuleref: init-declarator-list
              exitAtom: init-declarator-list
            exitElement: init-declarator-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: init-declarator
              => element -> {init-declarator}
              enterAtom: init-declarator
                enterRuleref: init-declarator
                exitRuleref: init-declarator
              exitAtom: init-declarator
            exitElement: init-declarator
          exitAlternative: init-declarator-list','init-declarator
        => elements -> ['{init-declarator-list}', ',', '{init-declarator}']
            => alternative -> {init-declarator-list} , {init-declarator}
        exitLabeledAlt: init-declarator-list','init-declarator
      exitRuleAltList: init-declarator|init-declarator-list','init-declarator
    exitRuleBlock: init-declarator|init-declarator-list','init-declarator
  exitRuleSpec: init-declarator-list:init-declarator|init-declarator-list','init-declarator;

  enterRuleSpec: init-declarator:declaratorinitializer?|declaratorrequires-clause;
    enterRuleBlock: declaratorinitializer?|declaratorrequires-clause
      enterRuleAltList: declaratorinitializer?|declaratorrequires-clause
        enterLabeledAlt: declaratorinitializer?
          enterAlternative: declaratorinitializer?
            enterElement: declarator
              => element -> {declarator}
              enterAtom: declarator
                enterRuleref: declarator
                exitRuleref: declarator
              exitAtom: declarator
            exitElement: declarator
            enterElement: initializer?
              => element -> [initializer]
              enterAtom: initializer
                enterRuleref: initializer
                exitRuleref: initializer
              exitAtom: initializer
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: initializer?
          exitAlternative: declaratorinitializer?
        => elements -> ['{declarator}', '[initializer]']
            => alternative -> {declarator} [initializer]
        exitLabeledAlt: declaratorinitializer?
        enterLabeledAlt: declaratorrequires-clause
          enterAlternative: declaratorrequires-clause
            enterElement: declarator
              => element -> {declarator}
              enterAtom: declarator
                enterRuleref: declarator
                exitRuleref: declarator
              exitAtom: declarator
            exitElement: declarator
            enterElement: requires-clause
              => element -> {requires-clause}
              enterAtom: requires-clause
                enterRuleref: requires-clause
                exitRuleref: requires-clause
              exitAtom: requires-clause
            exitElement: requires-clause
          exitAlternative: declaratorrequires-clause
        => elements -> ['{declarator}', '{requires-clause}']
            => alternative -> {declarator} {requires-clause}
        exitLabeledAlt: declaratorrequires-clause
      exitRuleAltList: declaratorinitializer?|declaratorrequires-clause
    exitRuleBlock: declaratorinitializer?|declaratorrequires-clause
  exitRuleSpec: init-declarator:declaratorinitializer?|declaratorrequires-clause;

  enterRuleSpec: declarator:ptr-declarator|noptr-declaratorparameters-and-qualifierstrailing-return-type;
    enterRuleBlock: ptr-declarator|noptr-declaratorparameters-and-qualifierstrailing-return-type
      enterRuleAltList: ptr-declarator|noptr-declaratorparameters-and-qualifierstrailing-return-type
        enterLabeledAlt: ptr-declarator
          enterAlternative: ptr-declarator
            enterElement: ptr-declarator
              => element -> {ptr-declarator}
              enterAtom: ptr-declarator
                enterRuleref: ptr-declarator
                exitRuleref: ptr-declarator
              exitAtom: ptr-declarator
            exitElement: ptr-declarator
          exitAlternative: ptr-declarator
        => elements -> ['{ptr-declarator}']
            => alternative -> {ptr-declarator}
        exitLabeledAlt: ptr-declarator
        enterLabeledAlt: noptr-declaratorparameters-and-qualifierstrailing-return-type
          enterAlternative: noptr-declaratorparameters-and-qualifierstrailing-return-type
            enterElement: noptr-declarator
              => element -> {noptr-declarator}
              enterAtom: noptr-declarator
                enterRuleref: noptr-declarator
                exitRuleref: noptr-declarator
              exitAtom: noptr-declarator
            exitElement: noptr-declarator
            enterElement: parameters-and-qualifiers
              => element -> {parameters-and-qualifiers}
              enterAtom: parameters-and-qualifiers
                enterRuleref: parameters-and-qualifiers
                exitRuleref: parameters-and-qualifiers
              exitAtom: parameters-and-qualifiers
            exitElement: parameters-and-qualifiers
            enterElement: trailing-return-type
              => element -> {trailing-return-type}
              enterAtom: trailing-return-type
                enterRuleref: trailing-return-type
                exitRuleref: trailing-return-type
              exitAtom: trailing-return-type
            exitElement: trailing-return-type
          exitAlternative: noptr-declaratorparameters-and-qualifierstrailing-return-type
        => elements -> ['{noptr-declarator}', '{parameters-and-qualifiers}', '{trailing-return-type}']
            => alternative -> {noptr-declarator} {parameters-and-qualifiers} {trailing-return-type}
        exitLabeledAlt: noptr-declaratorparameters-and-qualifierstrailing-return-type
      exitRuleAltList: ptr-declarator|noptr-declaratorparameters-and-qualifierstrailing-return-type
    exitRuleBlock: ptr-declarator|noptr-declaratorparameters-and-qualifierstrailing-return-type
  exitRuleSpec: declarator:ptr-declarator|noptr-declaratorparameters-and-qualifierstrailing-return-type;

  enterRuleSpec: ptr-declarator:noptr-declarator|ptr-operatorptr-declarator;
    enterRuleBlock: noptr-declarator|ptr-operatorptr-declarator
      enterRuleAltList: noptr-declarator|ptr-operatorptr-declarator
        enterLabeledAlt: noptr-declarator
          enterAlternative: noptr-declarator
            enterElement: noptr-declarator
              => element -> {noptr-declarator}
              enterAtom: noptr-declarator
                enterRuleref: noptr-declarator
                exitRuleref: noptr-declarator
              exitAtom: noptr-declarator
            exitElement: noptr-declarator
          exitAlternative: noptr-declarator
        => elements -> ['{noptr-declarator}']
            => alternative -> {noptr-declarator}
        exitLabeledAlt: noptr-declarator
        enterLabeledAlt: ptr-operatorptr-declarator
          enterAlternative: ptr-operatorptr-declarator
            enterElement: ptr-operator
              => element -> {ptr-operator}
              enterAtom: ptr-operator
                enterRuleref: ptr-operator
                exitRuleref: ptr-operator
              exitAtom: ptr-operator
            exitElement: ptr-operator
            enterElement: ptr-declarator
              => element -> {ptr-declarator}
              enterAtom: ptr-declarator
                enterRuleref: ptr-declarator
                exitRuleref: ptr-declarator
              exitAtom: ptr-declarator
            exitElement: ptr-declarator
          exitAlternative: ptr-operatorptr-declarator
        => elements -> ['{ptr-operator}', '{ptr-declarator}']
            => alternative -> {ptr-operator} {ptr-declarator}
        exitLabeledAlt: ptr-operatorptr-declarator
      exitRuleAltList: noptr-declarator|ptr-operatorptr-declarator
    exitRuleBlock: noptr-declarator|ptr-operatorptr-declarator
  exitRuleSpec: ptr-declarator:noptr-declarator|ptr-operatorptr-declarator;

  enterRuleSpec: noptr-declarator:declarator-idattribute-specifier*|noptr-declaratorparameters-and-qualifiers|noptr-declarator'['constant-expression?']'attribute-specifier*|'('ptr-declarator')';
    enterRuleBlock: declarator-idattribute-specifier*|noptr-declaratorparameters-and-qualifiers|noptr-declarator'['constant-expression?']'attribute-specifier*|'('ptr-declarator')'
      enterRuleAltList: declarator-idattribute-specifier*|noptr-declaratorparameters-and-qualifiers|noptr-declarator'['constant-expression?']'attribute-specifier*|'('ptr-declarator')'
        enterLabeledAlt: declarator-idattribute-specifier*
          enterAlternative: declarator-idattribute-specifier*
            enterElement: declarator-id
              => element -> {declarator-id}
              enterAtom: declarator-id
                enterRuleref: declarator-id
                exitRuleref: declarator-id
              exitAtom: declarator-id
            exitElement: declarator-id
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
          exitAlternative: declarator-idattribute-specifier*
        => elements -> ['{declarator-id}', '[attribute-specifier]...']
            => alternative -> {declarator-id} [attribute-specifier]...
        exitLabeledAlt: declarator-idattribute-specifier*
        enterLabeledAlt: noptr-declaratorparameters-and-qualifiers
          enterAlternative: noptr-declaratorparameters-and-qualifiers
            enterElement: noptr-declarator
              => element -> {noptr-declarator}
              enterAtom: noptr-declarator
                enterRuleref: noptr-declarator
                exitRuleref: noptr-declarator
              exitAtom: noptr-declarator
            exitElement: noptr-declarator
            enterElement: parameters-and-qualifiers
              => element -> {parameters-and-qualifiers}
              enterAtom: parameters-and-qualifiers
                enterRuleref: parameters-and-qualifiers
                exitRuleref: parameters-and-qualifiers
              exitAtom: parameters-and-qualifiers
            exitElement: parameters-and-qualifiers
          exitAlternative: noptr-declaratorparameters-and-qualifiers
        => elements -> ['{noptr-declarator}', '{parameters-and-qualifiers}']
            => alternative -> {noptr-declarator} {parameters-and-qualifiers}
        exitLabeledAlt: noptr-declaratorparameters-and-qualifiers
        enterLabeledAlt: noptr-declarator'['constant-expression?']'attribute-specifier*
          enterAlternative: noptr-declarator'['constant-expression?']'attribute-specifier*
            enterElement: noptr-declarator
              => element -> {noptr-declarator}
              enterAtom: noptr-declarator
                enterRuleref: noptr-declarator
                exitRuleref: noptr-declarator
              exitAtom: noptr-declarator
            exitElement: noptr-declarator
            enterElement: '['
              => element -> [
              enterAtom: '['
                enterTerminal: '['
                exitTerminal: '['
              exitAtom: '['
            exitElement: '['
            enterElement: constant-expression?
              => element -> [constant-expression]
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: constant-expression?
            enterElement: ']'
              => element -> ]
              enterAtom: ']'
                enterTerminal: ']'
                exitTerminal: ']'
              exitAtom: ']'
            exitElement: ']'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
          exitAlternative: noptr-declarator'['constant-expression?']'attribute-specifier*
        => elements -> ['{noptr-declarator}', '[', '[constant-expression]', ']', '[attribute-specifier]...']
            => alternative -> {noptr-declarator} [ [constant-expression] ] [attribute-specifier]...
        exitLabeledAlt: noptr-declarator'['constant-expression?']'attribute-specifier*
        enterLabeledAlt: '('ptr-declarator')'
          enterAlternative: '('ptr-declarator')'
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: ptr-declarator
              => element -> {ptr-declarator}
              enterAtom: ptr-declarator
                enterRuleref: ptr-declarator
                exitRuleref: ptr-declarator
              exitAtom: ptr-declarator
            exitElement: ptr-declarator
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '('ptr-declarator')'
        => elements -> ['(', '{ptr-declarator}', ')']
            => alternative -> ( {ptr-declarator} )
        exitLabeledAlt: '('ptr-declarator')'
      exitRuleAltList: declarator-idattribute-specifier*|noptr-declaratorparameters-and-qualifiers|noptr-declarator'['constant-expression?']'attribute-specifier*|'('ptr-declarator')'
    exitRuleBlock: declarator-idattribute-specifier*|noptr-declaratorparameters-and-qualifiers|noptr-declarator'['constant-expression?']'attribute-specifier*|'('ptr-declarator')'
  exitRuleSpec: noptr-declarator:declarator-idattribute-specifier*|noptr-declaratorparameters-and-qualifiers|noptr-declarator'['constant-expression?']'attribute-specifier*|'('ptr-declarator')';

  enterRuleSpec: parameters-and-qualifiers:'('parameter-declaration-clause')'cv-qualifier*ref-qualifier?noexcept-specifier?attribute-specifier*;
    enterRuleBlock: '('parameter-declaration-clause')'cv-qualifier*ref-qualifier?noexcept-specifier?attribute-specifier*
      enterRuleAltList: '('parameter-declaration-clause')'cv-qualifier*ref-qualifier?noexcept-specifier?attribute-specifier*
        enterLabeledAlt: '('parameter-declaration-clause')'cv-qualifier*ref-qualifier?noexcept-specifier?attribute-specifier*
          enterAlternative: '('parameter-declaration-clause')'cv-qualifier*ref-qualifier?noexcept-specifier?attribute-specifier*
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: parameter-declaration-clause
              => element -> {parameter-declaration-clause}
              enterAtom: parameter-declaration-clause
                enterRuleref: parameter-declaration-clause
                exitRuleref: parameter-declaration-clause
              exitAtom: parameter-declaration-clause
            exitElement: parameter-declaration-clause
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
            enterElement: cv-qualifier*
              => element -> [cv-qualifier]...
              enterAtom: cv-qualifier
                enterRuleref: cv-qualifier
                exitRuleref: cv-qualifier
              exitAtom: cv-qualifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: cv-qualifier*
            enterElement: ref-qualifier?
              => element -> [ref-qualifier]
              enterAtom: ref-qualifier
                enterRuleref: ref-qualifier
                exitRuleref: ref-qualifier
              exitAtom: ref-qualifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: ref-qualifier?
            enterElement: noexcept-specifier?
              => element -> [noexcept-specifier]
              enterAtom: noexcept-specifier
                enterRuleref: noexcept-specifier
                exitRuleref: noexcept-specifier
              exitAtom: noexcept-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: noexcept-specifier?
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
          exitAlternative: '('parameter-declaration-clause')'cv-qualifier*ref-qualifier?noexcept-specifier?attribute-specifier*
        => elements -> ['(', '{parameter-declaration-clause}', ')', '[cv-qualifier]...', '[ref-qualifier]', '[noexcept-specifier]', '[attribute-specifier]...']
            => alternative -> ( {parameter-declaration-clause} ) [cv-qualifier]... [ref-qualifier] [noexcept-specifier] [attribute-specifier]...
        exitLabeledAlt: '('parameter-declaration-clause')'cv-qualifier*ref-qualifier?noexcept-specifier?attribute-specifier*
      exitRuleAltList: '('parameter-declaration-clause')'cv-qualifier*ref-qualifier?noexcept-specifier?attribute-specifier*
    exitRuleBlock: '('parameter-declaration-clause')'cv-qualifier*ref-qualifier?noexcept-specifier?attribute-specifier*
  exitRuleSpec: parameters-and-qualifiers:'('parameter-declaration-clause')'cv-qualifier*ref-qualifier?noexcept-specifier?attribute-specifier*;

  enterRuleSpec: trailing-return-type:'->'type-id;
    enterRuleBlock: '->'type-id
      enterRuleAltList: '->'type-id
        enterLabeledAlt: '->'type-id
          enterAlternative: '->'type-id
            enterElement: '->'
              => element -> ->
              enterAtom: '->'
                enterTerminal: '->'
                exitTerminal: '->'
              exitAtom: '->'
            exitElement: '->'
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
          exitAlternative: '->'type-id
        => elements -> ['->', '{type-id}']
            => alternative -> -> {type-id}
        exitLabeledAlt: '->'type-id
      exitRuleAltList: '->'type-id
    exitRuleBlock: '->'type-id
  exitRuleSpec: trailing-return-type:'->'type-id;

  enterRuleSpec: ptr-operator:'*'attribute-specifier*cv-qualifier*|'&'attribute-specifier*|'&&'attribute-specifier*|nested-name-specifier'*'attribute-specifier*cv-qualifier*|ms-based-modifier?'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*|ms-based-modifier?nested-name-specifier'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*;
    enterRuleBlock: '*'attribute-specifier*cv-qualifier*|'&'attribute-specifier*|'&&'attribute-specifier*|nested-name-specifier'*'attribute-specifier*cv-qualifier*|ms-based-modifier?'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*|ms-based-modifier?nested-name-specifier'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*
      enterRuleAltList: '*'attribute-specifier*cv-qualifier*|'&'attribute-specifier*|'&&'attribute-specifier*|nested-name-specifier'*'attribute-specifier*cv-qualifier*|ms-based-modifier?'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*|ms-based-modifier?nested-name-specifier'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*
        enterLabeledAlt: '*'attribute-specifier*cv-qualifier*
          enterAlternative: '*'attribute-specifier*cv-qualifier*
            enterElement: '*'
              => element -> *
              enterAtom: '*'
                enterTerminal: '*'
                exitTerminal: '*'
              exitAtom: '*'
            exitElement: '*'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: cv-qualifier*
              => element -> [cv-qualifier]...
              enterAtom: cv-qualifier
                enterRuleref: cv-qualifier
                exitRuleref: cv-qualifier
              exitAtom: cv-qualifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: cv-qualifier*
          exitAlternative: '*'attribute-specifier*cv-qualifier*
        => elements -> ['*', '[attribute-specifier]...', '[cv-qualifier]...']
            => alternative -> * [attribute-specifier]... [cv-qualifier]...
        exitLabeledAlt: '*'attribute-specifier*cv-qualifier*
        enterLabeledAlt: '&'attribute-specifier*
          enterAlternative: '&'attribute-specifier*
            enterElement: '&'
              => element -> &
              enterAtom: '&'
                enterTerminal: '&'
                exitTerminal: '&'
              exitAtom: '&'
            exitElement: '&'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
          exitAlternative: '&'attribute-specifier*
        => elements -> ['&', '[attribute-specifier]...']
            => alternative -> & [attribute-specifier]...
        exitLabeledAlt: '&'attribute-specifier*
        enterLabeledAlt: '&&'attribute-specifier*
          enterAlternative: '&&'attribute-specifier*
            enterElement: '&&'
              => element -> &&
              enterAtom: '&&'
                enterTerminal: '&&'
                exitTerminal: '&&'
              exitAtom: '&&'
            exitElement: '&&'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
          exitAlternative: '&&'attribute-specifier*
        => elements -> ['&&', '[attribute-specifier]...']
            => alternative -> && [attribute-specifier]...
        exitLabeledAlt: '&&'attribute-specifier*
        enterLabeledAlt: nested-name-specifier'*'attribute-specifier*cv-qualifier*
          enterAlternative: nested-name-specifier'*'attribute-specifier*cv-qualifier*
            enterElement: nested-name-specifier
              => element -> {nested-name-specifier}
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
            exitElement: nested-name-specifier
            enterElement: '*'
              => element -> *
              enterAtom: '*'
                enterTerminal: '*'
                exitTerminal: '*'
              exitAtom: '*'
            exitElement: '*'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: cv-qualifier*
              => element -> [cv-qualifier]...
              enterAtom: cv-qualifier
                enterRuleref: cv-qualifier
                exitRuleref: cv-qualifier
              exitAtom: cv-qualifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: cv-qualifier*
          exitAlternative: nested-name-specifier'*'attribute-specifier*cv-qualifier*
        => elements -> ['{nested-name-specifier}', '*', '[attribute-specifier]...', '[cv-qualifier]...']
            => alternative -> {nested-name-specifier} * [attribute-specifier]... [cv-qualifier]...
        exitLabeledAlt: nested-name-specifier'*'attribute-specifier*cv-qualifier*
        enterLabeledAlt: ms-based-modifier?'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*
          enterAlternative: ms-based-modifier?'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*
            enterElement: ms-based-modifier?
              => element -> [ms-based-modifier]
              enterAtom: ms-based-modifier
                enterRuleref: ms-based-modifier
                exitRuleref: ms-based-modifier
              exitAtom: ms-based-modifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: ms-based-modifier?
            enterElement: '*'
              => element -> *
              enterAtom: '*'
                enterTerminal: '*'
                exitTerminal: '*'
              exitAtom: '*'
            exitElement: '*'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: ms-pointer-modifier*
              => element -> [ms-pointer-modifier]...
              enterAtom: ms-pointer-modifier
                enterRuleref: ms-pointer-modifier
                exitRuleref: ms-pointer-modifier
              exitAtom: ms-pointer-modifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: ms-pointer-modifier*
            enterElement: cv-qualifier*
              => element -> [cv-qualifier]...
              enterAtom: cv-qualifier
                enterRuleref: cv-qualifier
                exitRuleref: cv-qualifier
              exitAtom: cv-qualifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: cv-qualifier*
          exitAlternative: ms-based-modifier?'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*
        => elements -> ['[ms-based-modifier]', '*', '[attribute-specifier]...', '[ms-pointer-modifier]...', '[cv-qualifier]...']
            => alternative -> [ms-based-modifier] * [attribute-specifier]... [ms-pointer-modifier]... [cv-qualifier]...
        exitLabeledAlt: ms-based-modifier?'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*
        enterLabeledAlt: ms-based-modifier?nested-name-specifier'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*
          enterAlternative: ms-based-modifier?nested-name-specifier'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*
            enterElement: ms-based-modifier?
              => element -> [ms-based-modifier]
              enterAtom: ms-based-modifier
                enterRuleref: ms-based-modifier
                exitRuleref: ms-based-modifier
              exitAtom: ms-based-modifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: ms-based-modifier?
            enterElement: nested-name-specifier
              => element -> {nested-name-specifier}
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
            exitElement: nested-name-specifier
            enterElement: '*'
              => element -> *
              enterAtom: '*'
                enterTerminal: '*'
                exitTerminal: '*'
              exitAtom: '*'
            exitElement: '*'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: ms-pointer-modifier*
              => element -> [ms-pointer-modifier]...
              enterAtom: ms-pointer-modifier
                enterRuleref: ms-pointer-modifier
                exitRuleref: ms-pointer-modifier
              exitAtom: ms-pointer-modifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: ms-pointer-modifier*
            enterElement: cv-qualifier*
              => element -> [cv-qualifier]...
              enterAtom: cv-qualifier
                enterRuleref: cv-qualifier
                exitRuleref: cv-qualifier
              exitAtom: cv-qualifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: cv-qualifier*
          exitAlternative: ms-based-modifier?nested-name-specifier'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*
        => elements -> ['[ms-based-modifier]', '{nested-name-specifier}', '*', '[attribute-specifier]...', '[ms-pointer-modifier]...', '[cv-qualifier]...']
            => alternative -> [ms-based-modifier] {nested-name-specifier} * [attribute-specifier]... [ms-pointer-modifier]... [cv-qualifier]...
        exitLabeledAlt: ms-based-modifier?nested-name-specifier'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*
      exitRuleAltList: '*'attribute-specifier*cv-qualifier*|'&'attribute-specifier*|'&&'attribute-specifier*|nested-name-specifier'*'attribute-specifier*cv-qualifier*|ms-based-modifier?'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*|ms-based-modifier?nested-name-specifier'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*
    exitRuleBlock: '*'attribute-specifier*cv-qualifier*|'&'attribute-specifier*|'&&'attribute-specifier*|nested-name-specifier'*'attribute-specifier*cv-qualifier*|ms-based-modifier?'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*|ms-based-modifier?nested-name-specifier'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*
  exitRuleSpec: ptr-operator:'*'attribute-specifier*cv-qualifier*|'&'attribute-specifier*|'&&'attribute-specifier*|nested-name-specifier'*'attribute-specifier*cv-qualifier*|ms-based-modifier?'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*|ms-based-modifier?nested-name-specifier'*'attribute-specifier*ms-pointer-modifier*cv-qualifier*;

  enterRuleSpec: cv-qualifier:'const'|'volatile';
    enterRuleBlock: 'const'|'volatile'
      enterRuleAltList: 'const'|'volatile'
        enterLabeledAlt: 'const'
          enterAlternative: 'const'
            enterElement: 'const'
              => element -> const
              enterAtom: 'const'
                enterTerminal: 'const'
                exitTerminal: 'const'
              exitAtom: 'const'
            exitElement: 'const'
          exitAlternative: 'const'
        => elements -> ['const']
            => alternative -> const
        exitLabeledAlt: 'const'
        enterLabeledAlt: 'volatile'
          enterAlternative: 'volatile'
            enterElement: 'volatile'
              => element -> volatile
              enterAtom: 'volatile'
                enterTerminal: 'volatile'
                exitTerminal: 'volatile'
              exitAtom: 'volatile'
            exitElement: 'volatile'
          exitAlternative: 'volatile'
        => elements -> ['volatile']
            => alternative -> volatile
        exitLabeledAlt: 'volatile'
      exitRuleAltList: 'const'|'volatile'
    exitRuleBlock: 'const'|'volatile'
  exitRuleSpec: cv-qualifier:'const'|'volatile';

  enterRuleSpec: ref-qualifier:'&'|'&&';
    enterRuleBlock: '&'|'&&'
      enterRuleAltList: '&'|'&&'
        enterLabeledAlt: '&'
          enterAlternative: '&'
            enterElement: '&'
              => element -> &
              enterAtom: '&'
                enterTerminal: '&'
                exitTerminal: '&'
              exitAtom: '&'
            exitElement: '&'
          exitAlternative: '&'
        => elements -> ['&']
            => alternative -> &
        exitLabeledAlt: '&'
        enterLabeledAlt: '&&'
          enterAlternative: '&&'
            enterElement: '&&'
              => element -> &&
              enterAtom: '&&'
                enterTerminal: '&&'
                exitTerminal: '&&'
              exitAtom: '&&'
            exitElement: '&&'
          exitAlternative: '&&'
        => elements -> ['&&']
            => alternative -> &&
        exitLabeledAlt: '&&'
      exitRuleAltList: '&'|'&&'
    exitRuleBlock: '&'|'&&'
  exitRuleSpec: ref-qualifier:'&'|'&&';

  enterRuleSpec: three-dots:'...';
    enterRuleBlock: '...'
      enterRuleAltList: '...'
        enterLabeledAlt: '...'
          enterAlternative: '...'
            enterElement: '...'
              => element -> ...
              enterAtom: '...'
                enterTerminal: '...'
                exitTerminal: '...'
              exitAtom: '...'
            exitElement: '...'
          exitAlternative: '...'
        => elements -> ['...']
            => alternative -> ...
        exitLabeledAlt: '...'
      exitRuleAltList: '...'
    exitRuleBlock: '...'
  exitRuleSpec: three-dots:'...';

  enterRuleSpec: declarator-id:three-dots?id-expression;
    enterRuleBlock: three-dots?id-expression
      enterRuleAltList: three-dots?id-expression
        enterLabeledAlt: three-dots?id-expression
          enterAlternative: three-dots?id-expression
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
            enterElement: id-expression
              => element -> {id-expression}
              enterAtom: id-expression
                enterRuleref: id-expression
                exitRuleref: id-expression
              exitAtom: id-expression
            exitElement: id-expression
          exitAlternative: three-dots?id-expression
        => elements -> ['[three-dots]', '{id-expression}']
            => alternative -> [three-dots] {id-expression}
        exitLabeledAlt: three-dots?id-expression
      exitRuleAltList: three-dots?id-expression
    exitRuleBlock: three-dots?id-expression
  exitRuleSpec: declarator-id:three-dots?id-expression;

  enterRuleSpec: type-id:type-specifier-seqabstract-declarator?;
    enterRuleBlock: type-specifier-seqabstract-declarator?
      enterRuleAltList: type-specifier-seqabstract-declarator?
        enterLabeledAlt: type-specifier-seqabstract-declarator?
          enterAlternative: type-specifier-seqabstract-declarator?
            enterElement: type-specifier-seq
              => element -> {type-specifier-seq}
              enterAtom: type-specifier-seq
                enterRuleref: type-specifier-seq
                exitRuleref: type-specifier-seq
              exitAtom: type-specifier-seq
            exitElement: type-specifier-seq
            enterElement: abstract-declarator?
              => element -> [abstract-declarator]
              enterAtom: abstract-declarator
                enterRuleref: abstract-declarator
                exitRuleref: abstract-declarator
              exitAtom: abstract-declarator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: abstract-declarator?
          exitAlternative: type-specifier-seqabstract-declarator?
        => elements -> ['{type-specifier-seq}', '[abstract-declarator]']
            => alternative -> {type-specifier-seq} [abstract-declarator]
        exitLabeledAlt: type-specifier-seqabstract-declarator?
      exitRuleAltList: type-specifier-seqabstract-declarator?
    exitRuleBlock: type-specifier-seqabstract-declarator?
  exitRuleSpec: type-id:type-specifier-seqabstract-declarator?;

  enterRuleSpec: defining-type-id:defining-type-specifier-seqabstract-declarator?;
    enterRuleBlock: defining-type-specifier-seqabstract-declarator?
      enterRuleAltList: defining-type-specifier-seqabstract-declarator?
        enterLabeledAlt: defining-type-specifier-seqabstract-declarator?
          enterAlternative: defining-type-specifier-seqabstract-declarator?
            enterElement: defining-type-specifier-seq
              => element -> {defining-type-specifier-seq}
              enterAtom: defining-type-specifier-seq
                enterRuleref: defining-type-specifier-seq
                exitRuleref: defining-type-specifier-seq
              exitAtom: defining-type-specifier-seq
            exitElement: defining-type-specifier-seq
            enterElement: abstract-declarator?
              => element -> [abstract-declarator]
              enterAtom: abstract-declarator
                enterRuleref: abstract-declarator
                exitRuleref: abstract-declarator
              exitAtom: abstract-declarator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: abstract-declarator?
          exitAlternative: defining-type-specifier-seqabstract-declarator?
        => elements -> ['{defining-type-specifier-seq}', '[abstract-declarator]']
            => alternative -> {defining-type-specifier-seq} [abstract-declarator]
        exitLabeledAlt: defining-type-specifier-seqabstract-declarator?
      exitRuleAltList: defining-type-specifier-seqabstract-declarator?
    exitRuleBlock: defining-type-specifier-seqabstract-declarator?
  exitRuleSpec: defining-type-id:defining-type-specifier-seqabstract-declarator?;

  enterRuleSpec: abstract-declarator:ptr-abstract-declarator|noptr-abstract-declarator?parameters-and-qualifierstrailing-return-type|abstract-pack-declarator;
    enterRuleBlock: ptr-abstract-declarator|noptr-abstract-declarator?parameters-and-qualifierstrailing-return-type|abstract-pack-declarator
      enterRuleAltList: ptr-abstract-declarator|noptr-abstract-declarator?parameters-and-qualifierstrailing-return-type|abstract-pack-declarator
        enterLabeledAlt: ptr-abstract-declarator
          enterAlternative: ptr-abstract-declarator
            enterElement: ptr-abstract-declarator
              => element -> {ptr-abstract-declarator}
              enterAtom: ptr-abstract-declarator
                enterRuleref: ptr-abstract-declarator
                exitRuleref: ptr-abstract-declarator
              exitAtom: ptr-abstract-declarator
            exitElement: ptr-abstract-declarator
          exitAlternative: ptr-abstract-declarator
        => elements -> ['{ptr-abstract-declarator}']
            => alternative -> {ptr-abstract-declarator}
        exitLabeledAlt: ptr-abstract-declarator
        enterLabeledAlt: noptr-abstract-declarator?parameters-and-qualifierstrailing-return-type
          enterAlternative: noptr-abstract-declarator?parameters-and-qualifierstrailing-return-type
            enterElement: noptr-abstract-declarator?
              => element -> [noptr-abstract-declarator]
              enterAtom: noptr-abstract-declarator
                enterRuleref: noptr-abstract-declarator
                exitRuleref: noptr-abstract-declarator
              exitAtom: noptr-abstract-declarator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: noptr-abstract-declarator?
            enterElement: parameters-and-qualifiers
              => element -> {parameters-and-qualifiers}
              enterAtom: parameters-and-qualifiers
                enterRuleref: parameters-and-qualifiers
                exitRuleref: parameters-and-qualifiers
              exitAtom: parameters-and-qualifiers
            exitElement: parameters-and-qualifiers
            enterElement: trailing-return-type
              => element -> {trailing-return-type}
              enterAtom: trailing-return-type
                enterRuleref: trailing-return-type
                exitRuleref: trailing-return-type
              exitAtom: trailing-return-type
            exitElement: trailing-return-type
          exitAlternative: noptr-abstract-declarator?parameters-and-qualifierstrailing-return-type
        => elements -> ['[noptr-abstract-declarator]', '{parameters-and-qualifiers}', '{trailing-return-type}']
            => alternative -> [noptr-abstract-declarator] {parameters-and-qualifiers} {trailing-return-type}
        exitLabeledAlt: noptr-abstract-declarator?parameters-and-qualifierstrailing-return-type
        enterLabeledAlt: abstract-pack-declarator
          enterAlternative: abstract-pack-declarator
            enterElement: abstract-pack-declarator
              => element -> {abstract-pack-declarator}
              enterAtom: abstract-pack-declarator
                enterRuleref: abstract-pack-declarator
                exitRuleref: abstract-pack-declarator
              exitAtom: abstract-pack-declarator
            exitElement: abstract-pack-declarator
          exitAlternative: abstract-pack-declarator
        => elements -> ['{abstract-pack-declarator}']
            => alternative -> {abstract-pack-declarator}
        exitLabeledAlt: abstract-pack-declarator
      exitRuleAltList: ptr-abstract-declarator|noptr-abstract-declarator?parameters-and-qualifierstrailing-return-type|abstract-pack-declarator
    exitRuleBlock: ptr-abstract-declarator|noptr-abstract-declarator?parameters-and-qualifierstrailing-return-type|abstract-pack-declarator
  exitRuleSpec: abstract-declarator:ptr-abstract-declarator|noptr-abstract-declarator?parameters-and-qualifierstrailing-return-type|abstract-pack-declarator;

  enterRuleSpec: ptr-abstract-declarator:noptr-abstract-declarator|ptr-operatorptr-abstract-declarator?;
    enterRuleBlock: noptr-abstract-declarator|ptr-operatorptr-abstract-declarator?
      enterRuleAltList: noptr-abstract-declarator|ptr-operatorptr-abstract-declarator?
        enterLabeledAlt: noptr-abstract-declarator
          enterAlternative: noptr-abstract-declarator
            enterElement: noptr-abstract-declarator
              => element -> {noptr-abstract-declarator}
              enterAtom: noptr-abstract-declarator
                enterRuleref: noptr-abstract-declarator
                exitRuleref: noptr-abstract-declarator
              exitAtom: noptr-abstract-declarator
            exitElement: noptr-abstract-declarator
          exitAlternative: noptr-abstract-declarator
        => elements -> ['{noptr-abstract-declarator}']
            => alternative -> {noptr-abstract-declarator}
        exitLabeledAlt: noptr-abstract-declarator
        enterLabeledAlt: ptr-operatorptr-abstract-declarator?
          enterAlternative: ptr-operatorptr-abstract-declarator?
            enterElement: ptr-operator
              => element -> {ptr-operator}
              enterAtom: ptr-operator
                enterRuleref: ptr-operator
                exitRuleref: ptr-operator
              exitAtom: ptr-operator
            exitElement: ptr-operator
            enterElement: ptr-abstract-declarator?
              => element -> [ptr-abstract-declarator]
              enterAtom: ptr-abstract-declarator
                enterRuleref: ptr-abstract-declarator
                exitRuleref: ptr-abstract-declarator
              exitAtom: ptr-abstract-declarator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: ptr-abstract-declarator?
          exitAlternative: ptr-operatorptr-abstract-declarator?
        => elements -> ['{ptr-operator}', '[ptr-abstract-declarator]']
            => alternative -> {ptr-operator} [ptr-abstract-declarator]
        exitLabeledAlt: ptr-operatorptr-abstract-declarator?
      exitRuleAltList: noptr-abstract-declarator|ptr-operatorptr-abstract-declarator?
    exitRuleBlock: noptr-abstract-declarator|ptr-operatorptr-abstract-declarator?
  exitRuleSpec: ptr-abstract-declarator:noptr-abstract-declarator|ptr-operatorptr-abstract-declarator?;

  enterRuleSpec: noptr-abstract-declarator:noptr-abstract-declarator?parameters-and-qualifiers|noptr-abstract-declarator?'['constant-expression?']'attribute-specifier*|'('ptr-abstract-declarator')';
    enterRuleBlock: noptr-abstract-declarator?parameters-and-qualifiers|noptr-abstract-declarator?'['constant-expression?']'attribute-specifier*|'('ptr-abstract-declarator')'
      enterRuleAltList: noptr-abstract-declarator?parameters-and-qualifiers|noptr-abstract-declarator?'['constant-expression?']'attribute-specifier*|'('ptr-abstract-declarator')'
        enterLabeledAlt: noptr-abstract-declarator?parameters-and-qualifiers
          enterAlternative: noptr-abstract-declarator?parameters-and-qualifiers
            enterElement: noptr-abstract-declarator?
              => element -> [noptr-abstract-declarator]
              enterAtom: noptr-abstract-declarator
                enterRuleref: noptr-abstract-declarator
                exitRuleref: noptr-abstract-declarator
              exitAtom: noptr-abstract-declarator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: noptr-abstract-declarator?
            enterElement: parameters-and-qualifiers
              => element -> {parameters-and-qualifiers}
              enterAtom: parameters-and-qualifiers
                enterRuleref: parameters-and-qualifiers
                exitRuleref: parameters-and-qualifiers
              exitAtom: parameters-and-qualifiers
            exitElement: parameters-and-qualifiers
          exitAlternative: noptr-abstract-declarator?parameters-and-qualifiers
        => elements -> ['[noptr-abstract-declarator]', '{parameters-and-qualifiers}']
            => alternative -> [noptr-abstract-declarator] {parameters-and-qualifiers}
        exitLabeledAlt: noptr-abstract-declarator?parameters-and-qualifiers
        enterLabeledAlt: noptr-abstract-declarator?'['constant-expression?']'attribute-specifier*
          enterAlternative: noptr-abstract-declarator?'['constant-expression?']'attribute-specifier*
            enterElement: noptr-abstract-declarator?
              => element -> [noptr-abstract-declarator]
              enterAtom: noptr-abstract-declarator
                enterRuleref: noptr-abstract-declarator
                exitRuleref: noptr-abstract-declarator
              exitAtom: noptr-abstract-declarator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: noptr-abstract-declarator?
            enterElement: '['
              => element -> [
              enterAtom: '['
                enterTerminal: '['
                exitTerminal: '['
              exitAtom: '['
            exitElement: '['
            enterElement: constant-expression?
              => element -> [constant-expression]
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: constant-expression?
            enterElement: ']'
              => element -> ]
              enterAtom: ']'
                enterTerminal: ']'
                exitTerminal: ']'
              exitAtom: ']'
            exitElement: ']'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
          exitAlternative: noptr-abstract-declarator?'['constant-expression?']'attribute-specifier*
        => elements -> ['[noptr-abstract-declarator]', '[', '[constant-expression]', ']', '[attribute-specifier]...']
            => alternative -> [noptr-abstract-declarator] [ [constant-expression] ] [attribute-specifier]...
        exitLabeledAlt: noptr-abstract-declarator?'['constant-expression?']'attribute-specifier*
        enterLabeledAlt: '('ptr-abstract-declarator')'
          enterAlternative: '('ptr-abstract-declarator')'
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: ptr-abstract-declarator
              => element -> {ptr-abstract-declarator}
              enterAtom: ptr-abstract-declarator
                enterRuleref: ptr-abstract-declarator
                exitRuleref: ptr-abstract-declarator
              exitAtom: ptr-abstract-declarator
            exitElement: ptr-abstract-declarator
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '('ptr-abstract-declarator')'
        => elements -> ['(', '{ptr-abstract-declarator}', ')']
            => alternative -> ( {ptr-abstract-declarator} )
        exitLabeledAlt: '('ptr-abstract-declarator')'
      exitRuleAltList: noptr-abstract-declarator?parameters-and-qualifiers|noptr-abstract-declarator?'['constant-expression?']'attribute-specifier*|'('ptr-abstract-declarator')'
    exitRuleBlock: noptr-abstract-declarator?parameters-and-qualifiers|noptr-abstract-declarator?'['constant-expression?']'attribute-specifier*|'('ptr-abstract-declarator')'
  exitRuleSpec: noptr-abstract-declarator:noptr-abstract-declarator?parameters-and-qualifiers|noptr-abstract-declarator?'['constant-expression?']'attribute-specifier*|'('ptr-abstract-declarator')';

  enterRuleSpec: abstract-pack-declarator:noptr-abstract-pack-declarator|ptr-operatorabstract-pack-declarator;
    enterRuleBlock: noptr-abstract-pack-declarator|ptr-operatorabstract-pack-declarator
      enterRuleAltList: noptr-abstract-pack-declarator|ptr-operatorabstract-pack-declarator
        enterLabeledAlt: noptr-abstract-pack-declarator
          enterAlternative: noptr-abstract-pack-declarator
            enterElement: noptr-abstract-pack-declarator
              => element -> {noptr-abstract-pack-declarator}
              enterAtom: noptr-abstract-pack-declarator
                enterRuleref: noptr-abstract-pack-declarator
                exitRuleref: noptr-abstract-pack-declarator
              exitAtom: noptr-abstract-pack-declarator
            exitElement: noptr-abstract-pack-declarator
          exitAlternative: noptr-abstract-pack-declarator
        => elements -> ['{noptr-abstract-pack-declarator}']
            => alternative -> {noptr-abstract-pack-declarator}
        exitLabeledAlt: noptr-abstract-pack-declarator
        enterLabeledAlt: ptr-operatorabstract-pack-declarator
          enterAlternative: ptr-operatorabstract-pack-declarator
            enterElement: ptr-operator
              => element -> {ptr-operator}
              enterAtom: ptr-operator
                enterRuleref: ptr-operator
                exitRuleref: ptr-operator
              exitAtom: ptr-operator
            exitElement: ptr-operator
            enterElement: abstract-pack-declarator
              => element -> {abstract-pack-declarator}
              enterAtom: abstract-pack-declarator
                enterRuleref: abstract-pack-declarator
                exitRuleref: abstract-pack-declarator
              exitAtom: abstract-pack-declarator
            exitElement: abstract-pack-declarator
          exitAlternative: ptr-operatorabstract-pack-declarator
        => elements -> ['{ptr-operator}', '{abstract-pack-declarator}']
            => alternative -> {ptr-operator} {abstract-pack-declarator}
        exitLabeledAlt: ptr-operatorabstract-pack-declarator
      exitRuleAltList: noptr-abstract-pack-declarator|ptr-operatorabstract-pack-declarator
    exitRuleBlock: noptr-abstract-pack-declarator|ptr-operatorabstract-pack-declarator
  exitRuleSpec: abstract-pack-declarator:noptr-abstract-pack-declarator|ptr-operatorabstract-pack-declarator;

  enterRuleSpec: noptr-abstract-pack-declarator:noptr-abstract-pack-declaratorparameters-and-qualifiers|'...';
    enterRuleBlock: noptr-abstract-pack-declaratorparameters-and-qualifiers|'...'
      enterRuleAltList: noptr-abstract-pack-declaratorparameters-and-qualifiers|'...'
        enterLabeledAlt: noptr-abstract-pack-declaratorparameters-and-qualifiers
          enterAlternative: noptr-abstract-pack-declaratorparameters-and-qualifiers
            enterElement: noptr-abstract-pack-declarator
              => element -> {noptr-abstract-pack-declarator}
              enterAtom: noptr-abstract-pack-declarator
                enterRuleref: noptr-abstract-pack-declarator
                exitRuleref: noptr-abstract-pack-declarator
              exitAtom: noptr-abstract-pack-declarator
            exitElement: noptr-abstract-pack-declarator
            enterElement: parameters-and-qualifiers
              => element -> {parameters-and-qualifiers}
              enterAtom: parameters-and-qualifiers
                enterRuleref: parameters-and-qualifiers
                exitRuleref: parameters-and-qualifiers
              exitAtom: parameters-and-qualifiers
            exitElement: parameters-and-qualifiers
          exitAlternative: noptr-abstract-pack-declaratorparameters-and-qualifiers
        => elements -> ['{noptr-abstract-pack-declarator}', '{parameters-and-qualifiers}']
            => alternative -> {noptr-abstract-pack-declarator} {parameters-and-qualifiers}
        exitLabeledAlt: noptr-abstract-pack-declaratorparameters-and-qualifiers
        enterLabeledAlt: '...'
          enterAlternative: '...'
            enterElement: '...'
              => element -> ...
              enterAtom: '...'
                enterTerminal: '...'
                exitTerminal: '...'
              exitAtom: '...'
            exitElement: '...'
          exitAlternative: '...'
        => elements -> ['...']
            => alternative -> ...
        exitLabeledAlt: '...'
      exitRuleAltList: noptr-abstract-pack-declaratorparameters-and-qualifiers|'...'
    exitRuleBlock: noptr-abstract-pack-declaratorparameters-and-qualifiers|'...'
  exitRuleSpec: noptr-abstract-pack-declarator:noptr-abstract-pack-declaratorparameters-and-qualifiers|'...';

  enterRuleSpec: parameter-declaration-clause:parameter-declaration-list?three-dots?|parameter-declaration-list', ...';
    enterRuleBlock: parameter-declaration-list?three-dots?|parameter-declaration-list', ...'
      enterRuleAltList: parameter-declaration-list?three-dots?|parameter-declaration-list', ...'
        enterLabeledAlt: parameter-declaration-list?three-dots?
          enterAlternative: parameter-declaration-list?three-dots?
            enterElement: parameter-declaration-list?
              => element -> [parameter-declaration-list]
              enterAtom: parameter-declaration-list
                enterRuleref: parameter-declaration-list
                exitRuleref: parameter-declaration-list
              exitAtom: parameter-declaration-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: parameter-declaration-list?
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
          exitAlternative: parameter-declaration-list?three-dots?
        => elements -> ['[parameter-declaration-list]', '[three-dots]']
            => alternative -> [parameter-declaration-list] [three-dots]
        exitLabeledAlt: parameter-declaration-list?three-dots?
        enterLabeledAlt: parameter-declaration-list', ...'
          enterAlternative: parameter-declaration-list', ...'
            enterElement: parameter-declaration-list
              => element -> {parameter-declaration-list}
              enterAtom: parameter-declaration-list
                enterRuleref: parameter-declaration-list
                exitRuleref: parameter-declaration-list
              exitAtom: parameter-declaration-list
            exitElement: parameter-declaration-list
            enterElement: ', ...'
              => element -> , ...
              enterAtom: ', ...'
                enterTerminal: ', ...'
                exitTerminal: ', ...'
              exitAtom: ', ...'
            exitElement: ', ...'
          exitAlternative: parameter-declaration-list', ...'
        => elements -> ['{parameter-declaration-list}', ', ...']
            => alternative -> {parameter-declaration-list} , ...
        exitLabeledAlt: parameter-declaration-list', ...'
      exitRuleAltList: parameter-declaration-list?three-dots?|parameter-declaration-list', ...'
    exitRuleBlock: parameter-declaration-list?three-dots?|parameter-declaration-list', ...'
  exitRuleSpec: parameter-declaration-clause:parameter-declaration-list?three-dots?|parameter-declaration-list', ...';

  enterRuleSpec: parameter-declaration-list:parameter-declaration|parameter-declaration-list','parameter-declaration;
    enterRuleBlock: parameter-declaration|parameter-declaration-list','parameter-declaration
      enterRuleAltList: parameter-declaration|parameter-declaration-list','parameter-declaration
        enterLabeledAlt: parameter-declaration
          enterAlternative: parameter-declaration
            enterElement: parameter-declaration
              => element -> {parameter-declaration}
              enterAtom: parameter-declaration
                enterRuleref: parameter-declaration
                exitRuleref: parameter-declaration
              exitAtom: parameter-declaration
            exitElement: parameter-declaration
          exitAlternative: parameter-declaration
        => elements -> ['{parameter-declaration}']
            => alternative -> {parameter-declaration}
        exitLabeledAlt: parameter-declaration
        enterLabeledAlt: parameter-declaration-list','parameter-declaration
          enterAlternative: parameter-declaration-list','parameter-declaration
            enterElement: parameter-declaration-list
              => element -> {parameter-declaration-list}
              enterAtom: parameter-declaration-list
                enterRuleref: parameter-declaration-list
                exitRuleref: parameter-declaration-list
              exitAtom: parameter-declaration-list
            exitElement: parameter-declaration-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: parameter-declaration
              => element -> {parameter-declaration}
              enterAtom: parameter-declaration
                enterRuleref: parameter-declaration
                exitRuleref: parameter-declaration
              exitAtom: parameter-declaration
            exitElement: parameter-declaration
          exitAlternative: parameter-declaration-list','parameter-declaration
        => elements -> ['{parameter-declaration-list}', ',', '{parameter-declaration}']
            => alternative -> {parameter-declaration-list} , {parameter-declaration}
        exitLabeledAlt: parameter-declaration-list','parameter-declaration
      exitRuleAltList: parameter-declaration|parameter-declaration-list','parameter-declaration
    exitRuleBlock: parameter-declaration|parameter-declaration-list','parameter-declaration
  exitRuleSpec: parameter-declaration-list:parameter-declaration|parameter-declaration-list','parameter-declaration;

  enterRuleSpec: this:'this';
    enterRuleBlock: 'this'
      enterRuleAltList: 'this'
        enterLabeledAlt: 'this'
          enterAlternative: 'this'
            enterElement: 'this'
              => element -> this
              enterAtom: 'this'
                enterTerminal: 'this'
                exitTerminal: 'this'
              exitAtom: 'this'
            exitElement: 'this'
          exitAlternative: 'this'
        => elements -> ['this']
            => alternative -> this
        exitLabeledAlt: 'this'
      exitRuleAltList: 'this'
    exitRuleBlock: 'this'
  exitRuleSpec: this:'this';

  enterRuleSpec: parameter-declaration:attribute-specifier*this?decl-specifier-seqdeclarator|attribute-specifier*decl-specifier-seqdeclarator'='initializer-clause|attribute-specifier*this?decl-specifier-seqabstract-declarator?|attribute-specifier*decl-specifier-seqabstract-declarator?'='initializer-clause;
    enterRuleBlock: attribute-specifier*this?decl-specifier-seqdeclarator|attribute-specifier*decl-specifier-seqdeclarator'='initializer-clause|attribute-specifier*this?decl-specifier-seqabstract-declarator?|attribute-specifier*decl-specifier-seqabstract-declarator?'='initializer-clause
      enterRuleAltList: attribute-specifier*this?decl-specifier-seqdeclarator|attribute-specifier*decl-specifier-seqdeclarator'='initializer-clause|attribute-specifier*this?decl-specifier-seqabstract-declarator?|attribute-specifier*decl-specifier-seqabstract-declarator?'='initializer-clause
        enterLabeledAlt: attribute-specifier*this?decl-specifier-seqdeclarator
          enterAlternative: attribute-specifier*this?decl-specifier-seqdeclarator
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: this?
              => element -> [this]
              enterAtom: this
                enterRuleref: this
                exitRuleref: this
              exitAtom: this
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: this?
            enterElement: decl-specifier-seq
              => element -> {decl-specifier-seq}
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
            exitElement: decl-specifier-seq
            enterElement: declarator
              => element -> {declarator}
              enterAtom: declarator
                enterRuleref: declarator
                exitRuleref: declarator
              exitAtom: declarator
            exitElement: declarator
          exitAlternative: attribute-specifier*this?decl-specifier-seqdeclarator
        => elements -> ['[attribute-specifier]...', '[this]', '{decl-specifier-seq}', '{declarator}']
            => alternative -> [attribute-specifier]... [this] {decl-specifier-seq} {declarator}
        exitLabeledAlt: attribute-specifier*this?decl-specifier-seqdeclarator
        enterLabeledAlt: attribute-specifier*decl-specifier-seqdeclarator'='initializer-clause
          enterAlternative: attribute-specifier*decl-specifier-seqdeclarator'='initializer-clause
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: decl-specifier-seq
              => element -> {decl-specifier-seq}
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
            exitElement: decl-specifier-seq
            enterElement: declarator
              => element -> {declarator}
              enterAtom: declarator
                enterRuleref: declarator
                exitRuleref: declarator
              exitAtom: declarator
            exitElement: declarator
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
            enterElement: initializer-clause
              => element -> {initializer-clause}
              enterAtom: initializer-clause
                enterRuleref: initializer-clause
                exitRuleref: initializer-clause
              exitAtom: initializer-clause
            exitElement: initializer-clause
          exitAlternative: attribute-specifier*decl-specifier-seqdeclarator'='initializer-clause
        => elements -> ['[attribute-specifier]...', '{decl-specifier-seq}', '{declarator}', '=', '{initializer-clause}']
            => alternative -> [attribute-specifier]... {decl-specifier-seq} {declarator} = {initializer-clause}
        exitLabeledAlt: attribute-specifier*decl-specifier-seqdeclarator'='initializer-clause
        enterLabeledAlt: attribute-specifier*this?decl-specifier-seqabstract-declarator?
          enterAlternative: attribute-specifier*this?decl-specifier-seqabstract-declarator?
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: this?
              => element -> [this]
              enterAtom: this
                enterRuleref: this
                exitRuleref: this
              exitAtom: this
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: this?
            enterElement: decl-specifier-seq
              => element -> {decl-specifier-seq}
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
            exitElement: decl-specifier-seq
            enterElement: abstract-declarator?
              => element -> [abstract-declarator]
              enterAtom: abstract-declarator
                enterRuleref: abstract-declarator
                exitRuleref: abstract-declarator
              exitAtom: abstract-declarator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: abstract-declarator?
          exitAlternative: attribute-specifier*this?decl-specifier-seqabstract-declarator?
        => elements -> ['[attribute-specifier]...', '[this]', '{decl-specifier-seq}', '[abstract-declarator]']
            => alternative -> [attribute-specifier]... [this] {decl-specifier-seq} [abstract-declarator]
        exitLabeledAlt: attribute-specifier*this?decl-specifier-seqabstract-declarator?
        enterLabeledAlt: attribute-specifier*decl-specifier-seqabstract-declarator?'='initializer-clause
          enterAlternative: attribute-specifier*decl-specifier-seqabstract-declarator?'='initializer-clause
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: decl-specifier-seq
              => element -> {decl-specifier-seq}
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
            exitElement: decl-specifier-seq
            enterElement: abstract-declarator?
              => element -> [abstract-declarator]
              enterAtom: abstract-declarator
                enterRuleref: abstract-declarator
                exitRuleref: abstract-declarator
              exitAtom: abstract-declarator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: abstract-declarator?
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
            enterElement: initializer-clause
              => element -> {initializer-clause}
              enterAtom: initializer-clause
                enterRuleref: initializer-clause
                exitRuleref: initializer-clause
              exitAtom: initializer-clause
            exitElement: initializer-clause
          exitAlternative: attribute-specifier*decl-specifier-seqabstract-declarator?'='initializer-clause
        => elements -> ['[attribute-specifier]...', '{decl-specifier-seq}', '[abstract-declarator]', '=', '{initializer-clause}']
            => alternative -> [attribute-specifier]... {decl-specifier-seq} [abstract-declarator] = {initializer-clause}
        exitLabeledAlt: attribute-specifier*decl-specifier-seqabstract-declarator?'='initializer-clause
      exitRuleAltList: attribute-specifier*this?decl-specifier-seqdeclarator|attribute-specifier*decl-specifier-seqdeclarator'='initializer-clause|attribute-specifier*this?decl-specifier-seqabstract-declarator?|attribute-specifier*decl-specifier-seqabstract-declarator?'='initializer-clause
    exitRuleBlock: attribute-specifier*this?decl-specifier-seqdeclarator|attribute-specifier*decl-specifier-seqdeclarator'='initializer-clause|attribute-specifier*this?decl-specifier-seqabstract-declarator?|attribute-specifier*decl-specifier-seqabstract-declarator?'='initializer-clause
  exitRuleSpec: parameter-declaration:attribute-specifier*this?decl-specifier-seqdeclarator|attribute-specifier*decl-specifier-seqdeclarator'='initializer-clause|attribute-specifier*this?decl-specifier-seqabstract-declarator?|attribute-specifier*decl-specifier-seqabstract-declarator?'='initializer-clause;

  enterRuleSpec: initializer:brace-or-equal-initializer|'('expression-list')';
    enterRuleBlock: brace-or-equal-initializer|'('expression-list')'
      enterRuleAltList: brace-or-equal-initializer|'('expression-list')'
        enterLabeledAlt: brace-or-equal-initializer
          enterAlternative: brace-or-equal-initializer
            enterElement: brace-or-equal-initializer
              => element -> {brace-or-equal-initializer}
              enterAtom: brace-or-equal-initializer
                enterRuleref: brace-or-equal-initializer
                exitRuleref: brace-or-equal-initializer
              exitAtom: brace-or-equal-initializer
            exitElement: brace-or-equal-initializer
          exitAlternative: brace-or-equal-initializer
        => elements -> ['{brace-or-equal-initializer}']
            => alternative -> {brace-or-equal-initializer}
        exitLabeledAlt: brace-or-equal-initializer
        enterLabeledAlt: '('expression-list')'
          enterAlternative: '('expression-list')'
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: expression-list
              => element -> {expression-list}
              enterAtom: expression-list
                enterRuleref: expression-list
                exitRuleref: expression-list
              exitAtom: expression-list
            exitElement: expression-list
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '('expression-list')'
        => elements -> ['(', '{expression-list}', ')']
            => alternative -> ( {expression-list} )
        exitLabeledAlt: '('expression-list')'
      exitRuleAltList: brace-or-equal-initializer|'('expression-list')'
    exitRuleBlock: brace-or-equal-initializer|'('expression-list')'
  exitRuleSpec: initializer:brace-or-equal-initializer|'('expression-list')';

  enterRuleSpec: brace-or-equal-initializer:'='initializer-clause|braced-init-list;
    enterRuleBlock: '='initializer-clause|braced-init-list
      enterRuleAltList: '='initializer-clause|braced-init-list
        enterLabeledAlt: '='initializer-clause
          enterAlternative: '='initializer-clause
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
            enterElement: initializer-clause
              => element -> {initializer-clause}
              enterAtom: initializer-clause
                enterRuleref: initializer-clause
                exitRuleref: initializer-clause
              exitAtom: initializer-clause
            exitElement: initializer-clause
          exitAlternative: '='initializer-clause
        => elements -> ['=', '{initializer-clause}']
            => alternative -> = {initializer-clause}
        exitLabeledAlt: '='initializer-clause
        enterLabeledAlt: braced-init-list
          enterAlternative: braced-init-list
            enterElement: braced-init-list
              => element -> {braced-init-list}
              enterAtom: braced-init-list
                enterRuleref: braced-init-list
                exitRuleref: braced-init-list
              exitAtom: braced-init-list
            exitElement: braced-init-list
          exitAlternative: braced-init-list
        => elements -> ['{braced-init-list}']
            => alternative -> {braced-init-list}
        exitLabeledAlt: braced-init-list
      exitRuleAltList: '='initializer-clause|braced-init-list
    exitRuleBlock: '='initializer-clause|braced-init-list
  exitRuleSpec: brace-or-equal-initializer:'='initializer-clause|braced-init-list;

  enterRuleSpec: initializer-clause:assignment-expression|braced-init-list;
    enterRuleBlock: assignment-expression|braced-init-list
      enterRuleAltList: assignment-expression|braced-init-list
        enterLabeledAlt: assignment-expression
          enterAlternative: assignment-expression
            enterElement: assignment-expression
              => element -> {assignment-expression}
              enterAtom: assignment-expression
                enterRuleref: assignment-expression
                exitRuleref: assignment-expression
              exitAtom: assignment-expression
            exitElement: assignment-expression
          exitAlternative: assignment-expression
        => elements -> ['{assignment-expression}']
            => alternative -> {assignment-expression}
        exitLabeledAlt: assignment-expression
        enterLabeledAlt: braced-init-list
          enterAlternative: braced-init-list
            enterElement: braced-init-list
              => element -> {braced-init-list}
              enterAtom: braced-init-list
                enterRuleref: braced-init-list
                exitRuleref: braced-init-list
              exitAtom: braced-init-list
            exitElement: braced-init-list
          exitAlternative: braced-init-list
        => elements -> ['{braced-init-list}']
            => alternative -> {braced-init-list}
        exitLabeledAlt: braced-init-list
      exitRuleAltList: assignment-expression|braced-init-list
    exitRuleBlock: assignment-expression|braced-init-list
  exitRuleSpec: initializer-clause:assignment-expression|braced-init-list;

  enterRuleSpec: comma:',';
    enterRuleBlock: ','
      enterRuleAltList: ','
        enterLabeledAlt: ','
          enterAlternative: ','
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
          exitAlternative: ','
        => elements -> [',']
            => alternative -> ,
        exitLabeledAlt: ','
      exitRuleAltList: ','
    exitRuleBlock: ','
  exitRuleSpec: comma:',';

  enterRuleSpec: braced-init-list:'{'initializer-listcomma?'}'|'{'designated-initializer-listcomma?'}'|'{}';
    enterRuleBlock: '{'initializer-listcomma?'}'|'{'designated-initializer-listcomma?'}'|'{}'
      enterRuleAltList: '{'initializer-listcomma?'}'|'{'designated-initializer-listcomma?'}'|'{}'
        enterLabeledAlt: '{'initializer-listcomma?'}'
          enterAlternative: '{'initializer-listcomma?'}'
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
            enterElement: initializer-list
              => element -> {initializer-list}
              enterAtom: initializer-list
                enterRuleref: initializer-list
                exitRuleref: initializer-list
              exitAtom: initializer-list
            exitElement: initializer-list
            enterElement: comma?
              => element -> [comma]
              enterAtom: comma
                enterRuleref: comma
                exitRuleref: comma
              exitAtom: comma
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: comma?
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: '{'initializer-listcomma?'}'
        => elements -> ['{', '{initializer-list}', '[comma]', '}']
            => alternative -> { {initializer-list} [comma] }
        exitLabeledAlt: '{'initializer-listcomma?'}'
        enterLabeledAlt: '{'designated-initializer-listcomma?'}'
          enterAlternative: '{'designated-initializer-listcomma?'}'
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
            enterElement: designated-initializer-list
              => element -> {designated-initializer-list}
              enterAtom: designated-initializer-list
                enterRuleref: designated-initializer-list
                exitRuleref: designated-initializer-list
              exitAtom: designated-initializer-list
            exitElement: designated-initializer-list
            enterElement: comma?
              => element -> [comma]
              enterAtom: comma
                enterRuleref: comma
                exitRuleref: comma
              exitAtom: comma
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: comma?
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: '{'designated-initializer-listcomma?'}'
        => elements -> ['{', '{designated-initializer-list}', '[comma]', '}']
            => alternative -> { {designated-initializer-list} [comma] }
        exitLabeledAlt: '{'designated-initializer-listcomma?'}'
        enterLabeledAlt: '{}'
          enterAlternative: '{}'
            enterElement: '{}'
              => element -> {}
              enterAtom: '{}'
                enterTerminal: '{}'
                exitTerminal: '{}'
              exitAtom: '{}'
            exitElement: '{}'
          exitAlternative: '{}'
        => elements -> ['{}']
            => alternative -> {}
        exitLabeledAlt: '{}'
      exitRuleAltList: '{'initializer-listcomma?'}'|'{'designated-initializer-listcomma?'}'|'{}'
    exitRuleBlock: '{'initializer-listcomma?'}'|'{'designated-initializer-listcomma?'}'|'{}'
  exitRuleSpec: braced-init-list:'{'initializer-listcomma?'}'|'{'designated-initializer-listcomma?'}'|'{}';

  enterRuleSpec: initializer-list:initializer-clausethree-dots?|initializer-list','initializer-clausethree-dots?;
    enterRuleBlock: initializer-clausethree-dots?|initializer-list','initializer-clausethree-dots?
      enterRuleAltList: initializer-clausethree-dots?|initializer-list','initializer-clausethree-dots?
        enterLabeledAlt: initializer-clausethree-dots?
          enterAlternative: initializer-clausethree-dots?
            enterElement: initializer-clause
              => element -> {initializer-clause}
              enterAtom: initializer-clause
                enterRuleref: initializer-clause
                exitRuleref: initializer-clause
              exitAtom: initializer-clause
            exitElement: initializer-clause
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
          exitAlternative: initializer-clausethree-dots?
        => elements -> ['{initializer-clause}', '[three-dots]']
            => alternative -> {initializer-clause} [three-dots]
        exitLabeledAlt: initializer-clausethree-dots?
        enterLabeledAlt: initializer-list','initializer-clausethree-dots?
          enterAlternative: initializer-list','initializer-clausethree-dots?
            enterElement: initializer-list
              => element -> {initializer-list}
              enterAtom: initializer-list
                enterRuleref: initializer-list
                exitRuleref: initializer-list
              exitAtom: initializer-list
            exitElement: initializer-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: initializer-clause
              => element -> {initializer-clause}
              enterAtom: initializer-clause
                enterRuleref: initializer-clause
                exitRuleref: initializer-clause
              exitAtom: initializer-clause
            exitElement: initializer-clause
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
          exitAlternative: initializer-list','initializer-clausethree-dots?
        => elements -> ['{initializer-list}', ',', '{initializer-clause}', '[three-dots]']
            => alternative -> {initializer-list} , {initializer-clause} [three-dots]
        exitLabeledAlt: initializer-list','initializer-clausethree-dots?
      exitRuleAltList: initializer-clausethree-dots?|initializer-list','initializer-clausethree-dots?
    exitRuleBlock: initializer-clausethree-dots?|initializer-list','initializer-clausethree-dots?
  exitRuleSpec: initializer-list:initializer-clausethree-dots?|initializer-list','initializer-clausethree-dots?;

  enterRuleSpec: designated-initializer-list:designated-initializer-clause|designated-initializer-list','designated-initializer-clause;
    enterRuleBlock: designated-initializer-clause|designated-initializer-list','designated-initializer-clause
      enterRuleAltList: designated-initializer-clause|designated-initializer-list','designated-initializer-clause
        enterLabeledAlt: designated-initializer-clause
          enterAlternative: designated-initializer-clause
            enterElement: designated-initializer-clause
              => element -> {designated-initializer-clause}
              enterAtom: designated-initializer-clause
                enterRuleref: designated-initializer-clause
                exitRuleref: designated-initializer-clause
              exitAtom: designated-initializer-clause
            exitElement: designated-initializer-clause
          exitAlternative: designated-initializer-clause
        => elements -> ['{designated-initializer-clause}']
            => alternative -> {designated-initializer-clause}
        exitLabeledAlt: designated-initializer-clause
        enterLabeledAlt: designated-initializer-list','designated-initializer-clause
          enterAlternative: designated-initializer-list','designated-initializer-clause
            enterElement: designated-initializer-list
              => element -> {designated-initializer-list}
              enterAtom: designated-initializer-list
                enterRuleref: designated-initializer-list
                exitRuleref: designated-initializer-list
              exitAtom: designated-initializer-list
            exitElement: designated-initializer-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: designated-initializer-clause
              => element -> {designated-initializer-clause}
              enterAtom: designated-initializer-clause
                enterRuleref: designated-initializer-clause
                exitRuleref: designated-initializer-clause
              exitAtom: designated-initializer-clause
            exitElement: designated-initializer-clause
          exitAlternative: designated-initializer-list','designated-initializer-clause
        => elements -> ['{designated-initializer-list}', ',', '{designated-initializer-clause}']
            => alternative -> {designated-initializer-list} , {designated-initializer-clause}
        exitLabeledAlt: designated-initializer-list','designated-initializer-clause
      exitRuleAltList: designated-initializer-clause|designated-initializer-list','designated-initializer-clause
    exitRuleBlock: designated-initializer-clause|designated-initializer-list','designated-initializer-clause
  exitRuleSpec: designated-initializer-list:designated-initializer-clause|designated-initializer-list','designated-initializer-clause;

  enterRuleSpec: designated-initializer-clause:designatorbrace-or-equal-initializer;
    enterRuleBlock: designatorbrace-or-equal-initializer
      enterRuleAltList: designatorbrace-or-equal-initializer
        enterLabeledAlt: designatorbrace-or-equal-initializer
          enterAlternative: designatorbrace-or-equal-initializer
            enterElement: designator
              => element -> {designator}
              enterAtom: designator
                enterRuleref: designator
                exitRuleref: designator
              exitAtom: designator
            exitElement: designator
            enterElement: brace-or-equal-initializer
              => element -> {brace-or-equal-initializer}
              enterAtom: brace-or-equal-initializer
                enterRuleref: brace-or-equal-initializer
                exitRuleref: brace-or-equal-initializer
              exitAtom: brace-or-equal-initializer
            exitElement: brace-or-equal-initializer
          exitAlternative: designatorbrace-or-equal-initializer
        => elements -> ['{designator}', '{brace-or-equal-initializer}']
            => alternative -> {designator} {brace-or-equal-initializer}
        exitLabeledAlt: designatorbrace-or-equal-initializer
      exitRuleAltList: designatorbrace-or-equal-initializer
    exitRuleBlock: designatorbrace-or-equal-initializer
  exitRuleSpec: designated-initializer-clause:designatorbrace-or-equal-initializer;

  enterRuleSpec: designator:'.'identifier;
    enterRuleBlock: '.'identifier
      enterRuleAltList: '.'identifier
        enterLabeledAlt: '.'identifier
          enterAlternative: '.'identifier
            enterElement: '.'
              => element -> .
              enterAtom: '.'
                enterTerminal: '.'
                exitTerminal: '.'
              exitAtom: '.'
            exitElement: '.'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: '.'identifier
        => elements -> ['.', '{identifier}']
            => alternative -> . {identifier}
        exitLabeledAlt: '.'identifier
      exitRuleAltList: '.'identifier
    exitRuleBlock: '.'identifier
  exitRuleSpec: designator:'.'identifier;

  enterRuleSpec: expr-or-braced-init-list:expression|braced-init-list;
    enterRuleBlock: expression|braced-init-list
      enterRuleAltList: expression|braced-init-list
        enterLabeledAlt: expression
          enterAlternative: expression
            enterElement: expression
              => element -> {expression}
              enterAtom: expression
                enterRuleref: expression
                exitRuleref: expression
              exitAtom: expression
            exitElement: expression
          exitAlternative: expression
        => elements -> ['{expression}']
            => alternative -> {expression}
        exitLabeledAlt: expression
        enterLabeledAlt: braced-init-list
          enterAlternative: braced-init-list
            enterElement: braced-init-list
              => element -> {braced-init-list}
              enterAtom: braced-init-list
                enterRuleref: braced-init-list
                exitRuleref: braced-init-list
              exitAtom: braced-init-list
            exitElement: braced-init-list
          exitAlternative: braced-init-list
        => elements -> ['{braced-init-list}']
            => alternative -> {braced-init-list}
        exitLabeledAlt: braced-init-list
      exitRuleAltList: expression|braced-init-list
    exitRuleBlock: expression|braced-init-list
  exitRuleSpec: expr-or-braced-init-list:expression|braced-init-list;

  enterRuleSpec: function-definition:attribute-specifier*decl-specifier-seq?declaratorvirt-specifier-seq?function-body|attribute-specifier*decl-specifier-seq?declaratorrequires-clausefunction-body;
    enterRuleBlock: attribute-specifier*decl-specifier-seq?declaratorvirt-specifier-seq?function-body|attribute-specifier*decl-specifier-seq?declaratorrequires-clausefunction-body
      enterRuleAltList: attribute-specifier*decl-specifier-seq?declaratorvirt-specifier-seq?function-body|attribute-specifier*decl-specifier-seq?declaratorrequires-clausefunction-body
        enterLabeledAlt: attribute-specifier*decl-specifier-seq?declaratorvirt-specifier-seq?function-body
          enterAlternative: attribute-specifier*decl-specifier-seq?declaratorvirt-specifier-seq?function-body
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: decl-specifier-seq?
              => element -> [decl-specifier-seq]
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: decl-specifier-seq?
            enterElement: declarator
              => element -> {declarator}
              enterAtom: declarator
                enterRuleref: declarator
                exitRuleref: declarator
              exitAtom: declarator
            exitElement: declarator
            enterElement: virt-specifier-seq?
              => element -> [virt-specifier-seq]
              enterAtom: virt-specifier-seq
                enterRuleref: virt-specifier-seq
                exitRuleref: virt-specifier-seq
              exitAtom: virt-specifier-seq
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: virt-specifier-seq?
            enterElement: function-body
              => element -> {function-body}
              enterAtom: function-body
                enterRuleref: function-body
                exitRuleref: function-body
              exitAtom: function-body
            exitElement: function-body
          exitAlternative: attribute-specifier*decl-specifier-seq?declaratorvirt-specifier-seq?function-body
        => elements -> ['[attribute-specifier]...', '[decl-specifier-seq]', '{declarator}', '[virt-specifier-seq]', '{function-body}']
            => alternative -> [attribute-specifier]... [decl-specifier-seq] {declarator} [virt-specifier-seq] {function-body}
        exitLabeledAlt: attribute-specifier*decl-specifier-seq?declaratorvirt-specifier-seq?function-body
        enterLabeledAlt: attribute-specifier*decl-specifier-seq?declaratorrequires-clausefunction-body
          enterAlternative: attribute-specifier*decl-specifier-seq?declaratorrequires-clausefunction-body
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: decl-specifier-seq?
              => element -> [decl-specifier-seq]
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: decl-specifier-seq?
            enterElement: declarator
              => element -> {declarator}
              enterAtom: declarator
                enterRuleref: declarator
                exitRuleref: declarator
              exitAtom: declarator
            exitElement: declarator
            enterElement: requires-clause
              => element -> {requires-clause}
              enterAtom: requires-clause
                enterRuleref: requires-clause
                exitRuleref: requires-clause
              exitAtom: requires-clause
            exitElement: requires-clause
            enterElement: function-body
              => element -> {function-body}
              enterAtom: function-body
                enterRuleref: function-body
                exitRuleref: function-body
              exitAtom: function-body
            exitElement: function-body
          exitAlternative: attribute-specifier*decl-specifier-seq?declaratorrequires-clausefunction-body
        => elements -> ['[attribute-specifier]...', '[decl-specifier-seq]', '{declarator}', '{requires-clause}', '{function-body}']
            => alternative -> [attribute-specifier]... [decl-specifier-seq] {declarator} {requires-clause} {function-body}
        exitLabeledAlt: attribute-specifier*decl-specifier-seq?declaratorrequires-clausefunction-body
      exitRuleAltList: attribute-specifier*decl-specifier-seq?declaratorvirt-specifier-seq?function-body|attribute-specifier*decl-specifier-seq?declaratorrequires-clausefunction-body
    exitRuleBlock: attribute-specifier*decl-specifier-seq?declaratorvirt-specifier-seq?function-body|attribute-specifier*decl-specifier-seq?declaratorrequires-clausefunction-body
  exitRuleSpec: function-definition:attribute-specifier*decl-specifier-seq?declaratorvirt-specifier-seq?function-body|attribute-specifier*decl-specifier-seq?declaratorrequires-clausefunction-body;

  enterRuleSpec: function-body:ctor-initializer?compound-statement|function-try-block|'= default;'|'= delete;';
    enterRuleBlock: ctor-initializer?compound-statement|function-try-block|'= default;'|'= delete;'
      enterRuleAltList: ctor-initializer?compound-statement|function-try-block|'= default;'|'= delete;'
        enterLabeledAlt: ctor-initializer?compound-statement
          enterAlternative: ctor-initializer?compound-statement
            enterElement: ctor-initializer?
              => element -> [ctor-initializer]
              enterAtom: ctor-initializer
                enterRuleref: ctor-initializer
                exitRuleref: ctor-initializer
              exitAtom: ctor-initializer
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: ctor-initializer?
            enterElement: compound-statement
              => element -> {compound-statement}
              enterAtom: compound-statement
                enterRuleref: compound-statement
                exitRuleref: compound-statement
              exitAtom: compound-statement
            exitElement: compound-statement
          exitAlternative: ctor-initializer?compound-statement
        => elements -> ['[ctor-initializer]', '{compound-statement}']
            => alternative -> [ctor-initializer] {compound-statement}
        exitLabeledAlt: ctor-initializer?compound-statement
        enterLabeledAlt: function-try-block
          enterAlternative: function-try-block
            enterElement: function-try-block
              => element -> {function-try-block}
              enterAtom: function-try-block
                enterRuleref: function-try-block
                exitRuleref: function-try-block
              exitAtom: function-try-block
            exitElement: function-try-block
          exitAlternative: function-try-block
        => elements -> ['{function-try-block}']
            => alternative -> {function-try-block}
        exitLabeledAlt: function-try-block
        enterLabeledAlt: '= default;'
          enterAlternative: '= default;'
            enterElement: '= default;'
              => element -> = default;
              enterAtom: '= default;'
                enterTerminal: '= default;'
                exitTerminal: '= default;'
              exitAtom: '= default;'
            exitElement: '= default;'
          exitAlternative: '= default;'
        => elements -> ['= default;']
            => alternative -> = default;
        exitLabeledAlt: '= default;'
        enterLabeledAlt: '= delete;'
          enterAlternative: '= delete;'
            enterElement: '= delete;'
              => element -> = delete;
              enterAtom: '= delete;'
                enterTerminal: '= delete;'
                exitTerminal: '= delete;'
              exitAtom: '= delete;'
            exitElement: '= delete;'
          exitAlternative: '= delete;'
        => elements -> ['= delete;']
            => alternative -> = delete;
        exitLabeledAlt: '= delete;'
      exitRuleAltList: ctor-initializer?compound-statement|function-try-block|'= default;'|'= delete;'
    exitRuleBlock: ctor-initializer?compound-statement|function-try-block|'= default;'|'= delete;'
  exitRuleSpec: function-body:ctor-initializer?compound-statement|function-try-block|'= default;'|'= delete;';

  enterRuleSpec: enum-name:identifier;
    enterRuleBlock: identifier
      enterRuleAltList: identifier
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
      exitRuleAltList: identifier
    exitRuleBlock: identifier
  exitRuleSpec: enum-name:identifier;

  enterRuleSpec: enum-specifier:enum-head'{'enumerator-list?'}'|enum-head'{'enumerator-list', }';
    enterRuleBlock: enum-head'{'enumerator-list?'}'|enum-head'{'enumerator-list', }'
      enterRuleAltList: enum-head'{'enumerator-list?'}'|enum-head'{'enumerator-list', }'
        enterLabeledAlt: enum-head'{'enumerator-list?'}'
          enterAlternative: enum-head'{'enumerator-list?'}'
            enterElement: enum-head
              => element -> {enum-head}
              enterAtom: enum-head
                enterRuleref: enum-head
                exitRuleref: enum-head
              exitAtom: enum-head
            exitElement: enum-head
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
            enterElement: enumerator-list?
              => element -> [enumerator-list]
              enterAtom: enumerator-list
                enterRuleref: enumerator-list
                exitRuleref: enumerator-list
              exitAtom: enumerator-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: enumerator-list?
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: enum-head'{'enumerator-list?'}'
        => elements -> ['{enum-head}', '{', '[enumerator-list]', '}']
            => alternative -> {enum-head} { [enumerator-list] }
        exitLabeledAlt: enum-head'{'enumerator-list?'}'
        enterLabeledAlt: enum-head'{'enumerator-list', }'
          enterAlternative: enum-head'{'enumerator-list', }'
            enterElement: enum-head
              => element -> {enum-head}
              enterAtom: enum-head
                enterRuleref: enum-head
                exitRuleref: enum-head
              exitAtom: enum-head
            exitElement: enum-head
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
            enterElement: enumerator-list
              => element -> {enumerator-list}
              enterAtom: enumerator-list
                enterRuleref: enumerator-list
                exitRuleref: enumerator-list
              exitAtom: enumerator-list
            exitElement: enumerator-list
            enterElement: ', }'
              => element -> , }
              enterAtom: ', }'
                enterTerminal: ', }'
                exitTerminal: ', }'
              exitAtom: ', }'
            exitElement: ', }'
          exitAlternative: enum-head'{'enumerator-list', }'
        => elements -> ['{enum-head}', '{', '{enumerator-list}', ', }']
            => alternative -> {enum-head} { {enumerator-list} , }
        exitLabeledAlt: enum-head'{'enumerator-list', }'
      exitRuleAltList: enum-head'{'enumerator-list?'}'|enum-head'{'enumerator-list', }'
    exitRuleBlock: enum-head'{'enumerator-list?'}'|enum-head'{'enumerator-list', }'
  exitRuleSpec: enum-specifier:enum-head'{'enumerator-list?'}'|enum-head'{'enumerator-list', }';

  enterRuleSpec: enum-head:enum-keyattribute-specifier*enum-head-name?enum-base?;
    enterRuleBlock: enum-keyattribute-specifier*enum-head-name?enum-base?
      enterRuleAltList: enum-keyattribute-specifier*enum-head-name?enum-base?
        enterLabeledAlt: enum-keyattribute-specifier*enum-head-name?enum-base?
          enterAlternative: enum-keyattribute-specifier*enum-head-name?enum-base?
            enterElement: enum-key
              => element -> {enum-key}
              enterAtom: enum-key
                enterRuleref: enum-key
                exitRuleref: enum-key
              exitAtom: enum-key
            exitElement: enum-key
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: enum-head-name?
              => element -> [enum-head-name]
              enterAtom: enum-head-name
                enterRuleref: enum-head-name
                exitRuleref: enum-head-name
              exitAtom: enum-head-name
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: enum-head-name?
            enterElement: enum-base?
              => element -> [enum-base]
              enterAtom: enum-base
                enterRuleref: enum-base
                exitRuleref: enum-base
              exitAtom: enum-base
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: enum-base?
          exitAlternative: enum-keyattribute-specifier*enum-head-name?enum-base?
        => elements -> ['{enum-key}', '[attribute-specifier]...', '[enum-head-name]', '[enum-base]']
            => alternative -> {enum-key} [attribute-specifier]... [enum-head-name] [enum-base]
        exitLabeledAlt: enum-keyattribute-specifier*enum-head-name?enum-base?
      exitRuleAltList: enum-keyattribute-specifier*enum-head-name?enum-base?
    exitRuleBlock: enum-keyattribute-specifier*enum-head-name?enum-base?
  exitRuleSpec: enum-head:enum-keyattribute-specifier*enum-head-name?enum-base?;

  enterRuleSpec: enum-head-name:nested-name-specifier?identifier;
    enterRuleBlock: nested-name-specifier?identifier
      enterRuleAltList: nested-name-specifier?identifier
        enterLabeledAlt: nested-name-specifier?identifier
          enterAlternative: nested-name-specifier?identifier
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: nested-name-specifier?identifier
        => elements -> ['[nested-name-specifier]', '{identifier}']
            => alternative -> [nested-name-specifier] {identifier}
        exitLabeledAlt: nested-name-specifier?identifier
      exitRuleAltList: nested-name-specifier?identifier
    exitRuleBlock: nested-name-specifier?identifier
  exitRuleSpec: enum-head-name:nested-name-specifier?identifier;

  enterRuleSpec: opaque-enum-declaration:enum-keyattribute-specifier*enum-head-nameenum-base?';';
    enterRuleBlock: enum-keyattribute-specifier*enum-head-nameenum-base?';'
      enterRuleAltList: enum-keyattribute-specifier*enum-head-nameenum-base?';'
        enterLabeledAlt: enum-keyattribute-specifier*enum-head-nameenum-base?';'
          enterAlternative: enum-keyattribute-specifier*enum-head-nameenum-base?';'
            enterElement: enum-key
              => element -> {enum-key}
              enterAtom: enum-key
                enterRuleref: enum-key
                exitRuleref: enum-key
              exitAtom: enum-key
            exitElement: enum-key
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: enum-head-name
              => element -> {enum-head-name}
              enterAtom: enum-head-name
                enterRuleref: enum-head-name
                exitRuleref: enum-head-name
              exitAtom: enum-head-name
            exitElement: enum-head-name
            enterElement: enum-base?
              => element -> [enum-base]
              enterAtom: enum-base
                enterRuleref: enum-base
                exitRuleref: enum-base
              exitAtom: enum-base
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: enum-base?
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: enum-keyattribute-specifier*enum-head-nameenum-base?';'
        => elements -> ['{enum-key}', '[attribute-specifier]...', '{enum-head-name}', '[enum-base]', ';']
            => alternative -> {enum-key} [attribute-specifier]... {enum-head-name} [enum-base] ;
        exitLabeledAlt: enum-keyattribute-specifier*enum-head-nameenum-base?';'
      exitRuleAltList: enum-keyattribute-specifier*enum-head-nameenum-base?';'
    exitRuleBlock: enum-keyattribute-specifier*enum-head-nameenum-base?';'
  exitRuleSpec: opaque-enum-declaration:enum-keyattribute-specifier*enum-head-nameenum-base?';';

  enterRuleSpec: enum-key:'enum'|'enum class'|'enum struct';
    enterRuleBlock: 'enum'|'enum class'|'enum struct'
      enterRuleAltList: 'enum'|'enum class'|'enum struct'
        enterLabeledAlt: 'enum'
          enterAlternative: 'enum'
            enterElement: 'enum'
              => element -> enum
              enterAtom: 'enum'
                enterTerminal: 'enum'
                exitTerminal: 'enum'
              exitAtom: 'enum'
            exitElement: 'enum'
          exitAlternative: 'enum'
        => elements -> ['enum']
            => alternative -> enum
        exitLabeledAlt: 'enum'
        enterLabeledAlt: 'enum class'
          enterAlternative: 'enum class'
            enterElement: 'enum class'
              => element -> enum class
              enterAtom: 'enum class'
                enterTerminal: 'enum class'
                exitTerminal: 'enum class'
              exitAtom: 'enum class'
            exitElement: 'enum class'
          exitAlternative: 'enum class'
        => elements -> ['enum class']
            => alternative -> enum class
        exitLabeledAlt: 'enum class'
        enterLabeledAlt: 'enum struct'
          enterAlternative: 'enum struct'
            enterElement: 'enum struct'
              => element -> enum struct
              enterAtom: 'enum struct'
                enterTerminal: 'enum struct'
                exitTerminal: 'enum struct'
              exitAtom: 'enum struct'
            exitElement: 'enum struct'
          exitAlternative: 'enum struct'
        => elements -> ['enum struct']
            => alternative -> enum struct
        exitLabeledAlt: 'enum struct'
      exitRuleAltList: 'enum'|'enum class'|'enum struct'
    exitRuleBlock: 'enum'|'enum class'|'enum struct'
  exitRuleSpec: enum-key:'enum'|'enum class'|'enum struct';

  enterRuleSpec: enum-base:':'type-specifier-seq;
    enterRuleBlock: ':'type-specifier-seq
      enterRuleAltList: ':'type-specifier-seq
        enterLabeledAlt: ':'type-specifier-seq
          enterAlternative: ':'type-specifier-seq
            enterElement: ':'
              => element -> :
              enterAtom: ':'
                enterTerminal: ':'
                exitTerminal: ':'
              exitAtom: ':'
            exitElement: ':'
            enterElement: type-specifier-seq
              => element -> {type-specifier-seq}
              enterAtom: type-specifier-seq
                enterRuleref: type-specifier-seq
                exitRuleref: type-specifier-seq
              exitAtom: type-specifier-seq
            exitElement: type-specifier-seq
          exitAlternative: ':'type-specifier-seq
        => elements -> [':', '{type-specifier-seq}']
            => alternative -> : {type-specifier-seq}
        exitLabeledAlt: ':'type-specifier-seq
      exitRuleAltList: ':'type-specifier-seq
    exitRuleBlock: ':'type-specifier-seq
  exitRuleSpec: enum-base:':'type-specifier-seq;

  enterRuleSpec: enumerator-list:enumerator-definition|enumerator-list','enumerator-definition;
    enterRuleBlock: enumerator-definition|enumerator-list','enumerator-definition
      enterRuleAltList: enumerator-definition|enumerator-list','enumerator-definition
        enterLabeledAlt: enumerator-definition
          enterAlternative: enumerator-definition
            enterElement: enumerator-definition
              => element -> {enumerator-definition}
              enterAtom: enumerator-definition
                enterRuleref: enumerator-definition
                exitRuleref: enumerator-definition
              exitAtom: enumerator-definition
            exitElement: enumerator-definition
          exitAlternative: enumerator-definition
        => elements -> ['{enumerator-definition}']
            => alternative -> {enumerator-definition}
        exitLabeledAlt: enumerator-definition
        enterLabeledAlt: enumerator-list','enumerator-definition
          enterAlternative: enumerator-list','enumerator-definition
            enterElement: enumerator-list
              => element -> {enumerator-list}
              enterAtom: enumerator-list
                enterRuleref: enumerator-list
                exitRuleref: enumerator-list
              exitAtom: enumerator-list
            exitElement: enumerator-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: enumerator-definition
              => element -> {enumerator-definition}
              enterAtom: enumerator-definition
                enterRuleref: enumerator-definition
                exitRuleref: enumerator-definition
              exitAtom: enumerator-definition
            exitElement: enumerator-definition
          exitAlternative: enumerator-list','enumerator-definition
        => elements -> ['{enumerator-list}', ',', '{enumerator-definition}']
            => alternative -> {enumerator-list} , {enumerator-definition}
        exitLabeledAlt: enumerator-list','enumerator-definition
      exitRuleAltList: enumerator-definition|enumerator-list','enumerator-definition
    exitRuleBlock: enumerator-definition|enumerator-list','enumerator-definition
  exitRuleSpec: enumerator-list:enumerator-definition|enumerator-list','enumerator-definition;

  enterRuleSpec: enumerator-definition:enumerator|enumerator'='constant-expression;
    enterRuleBlock: enumerator|enumerator'='constant-expression
      enterRuleAltList: enumerator|enumerator'='constant-expression
        enterLabeledAlt: enumerator
          enterAlternative: enumerator
            enterElement: enumerator
              => element -> {enumerator}
              enterAtom: enumerator
                enterRuleref: enumerator
                exitRuleref: enumerator
              exitAtom: enumerator
            exitElement: enumerator
          exitAlternative: enumerator
        => elements -> ['{enumerator}']
            => alternative -> {enumerator}
        exitLabeledAlt: enumerator
        enterLabeledAlt: enumerator'='constant-expression
          enterAlternative: enumerator'='constant-expression
            enterElement: enumerator
              => element -> {enumerator}
              enterAtom: enumerator
                enterRuleref: enumerator
                exitRuleref: enumerator
              exitAtom: enumerator
            exitElement: enumerator
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
          exitAlternative: enumerator'='constant-expression
        => elements -> ['{enumerator}', '=', '{constant-expression}']
            => alternative -> {enumerator} = {constant-expression}
        exitLabeledAlt: enumerator'='constant-expression
      exitRuleAltList: enumerator|enumerator'='constant-expression
    exitRuleBlock: enumerator|enumerator'='constant-expression
  exitRuleSpec: enumerator-definition:enumerator|enumerator'='constant-expression;

  enterRuleSpec: enumerator:identifierattribute-specifier*;
    enterRuleBlock: identifierattribute-specifier*
      enterRuleAltList: identifierattribute-specifier*
        enterLabeledAlt: identifierattribute-specifier*
          enterAlternative: identifierattribute-specifier*
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
          exitAlternative: identifierattribute-specifier*
        => elements -> ['{identifier}', '[attribute-specifier]...']
            => alternative -> {identifier} [attribute-specifier]...
        exitLabeledAlt: identifierattribute-specifier*
      exitRuleAltList: identifierattribute-specifier*
    exitRuleBlock: identifierattribute-specifier*
  exitRuleSpec: enumerator:identifierattribute-specifier*;

  enterRuleSpec: using-enum-declaration:'using enum'using-enum-declarator';';
    enterRuleBlock: 'using enum'using-enum-declarator';'
      enterRuleAltList: 'using enum'using-enum-declarator';'
        enterLabeledAlt: 'using enum'using-enum-declarator';'
          enterAlternative: 'using enum'using-enum-declarator';'
            enterElement: 'using enum'
              => element -> using enum
              enterAtom: 'using enum'
                enterTerminal: 'using enum'
                exitTerminal: 'using enum'
              exitAtom: 'using enum'
            exitElement: 'using enum'
            enterElement: using-enum-declarator
              => element -> {using-enum-declarator}
              enterAtom: using-enum-declarator
                enterRuleref: using-enum-declarator
                exitRuleref: using-enum-declarator
              exitAtom: using-enum-declarator
            exitElement: using-enum-declarator
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: 'using enum'using-enum-declarator';'
        => elements -> ['using enum', '{using-enum-declarator}', ';']
            => alternative -> using enum {using-enum-declarator} ;
        exitLabeledAlt: 'using enum'using-enum-declarator';'
      exitRuleAltList: 'using enum'using-enum-declarator';'
    exitRuleBlock: 'using enum'using-enum-declarator';'
  exitRuleSpec: using-enum-declaration:'using enum'using-enum-declarator';';

  enterRuleSpec: using-enum-declarator:nested-name-specifier?identifier|nested-name-specifier?simple-template-id;
    enterRuleBlock: nested-name-specifier?identifier|nested-name-specifier?simple-template-id
      enterRuleAltList: nested-name-specifier?identifier|nested-name-specifier?simple-template-id
        enterLabeledAlt: nested-name-specifier?identifier
          enterAlternative: nested-name-specifier?identifier
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: nested-name-specifier?identifier
        => elements -> ['[nested-name-specifier]', '{identifier}']
            => alternative -> [nested-name-specifier] {identifier}
        exitLabeledAlt: nested-name-specifier?identifier
        enterLabeledAlt: nested-name-specifier?simple-template-id
          enterAlternative: nested-name-specifier?simple-template-id
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: simple-template-id
              => element -> {simple-template-id}
              enterAtom: simple-template-id
                enterRuleref: simple-template-id
                exitRuleref: simple-template-id
              exitAtom: simple-template-id
            exitElement: simple-template-id
          exitAlternative: nested-name-specifier?simple-template-id
        => elements -> ['[nested-name-specifier]', '{simple-template-id}']
            => alternative -> [nested-name-specifier] {simple-template-id}
        exitLabeledAlt: nested-name-specifier?simple-template-id
      exitRuleAltList: nested-name-specifier?identifier|nested-name-specifier?simple-template-id
    exitRuleBlock: nested-name-specifier?identifier|nested-name-specifier?simple-template-id
  exitRuleSpec: using-enum-declarator:nested-name-specifier?identifier|nested-name-specifier?simple-template-id;

  enterRuleSpec: namespace-name:identifier|namespace-alias;
    enterRuleBlock: identifier|namespace-alias
      enterRuleAltList: identifier|namespace-alias
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
        enterLabeledAlt: namespace-alias
          enterAlternative: namespace-alias
            enterElement: namespace-alias
              => element -> {namespace-alias}
              enterAtom: namespace-alias
                enterRuleref: namespace-alias
                exitRuleref: namespace-alias
              exitAtom: namespace-alias
            exitElement: namespace-alias
          exitAlternative: namespace-alias
        => elements -> ['{namespace-alias}']
            => alternative -> {namespace-alias}
        exitLabeledAlt: namespace-alias
      exitRuleAltList: identifier|namespace-alias
    exitRuleBlock: identifier|namespace-alias
  exitRuleSpec: namespace-name:identifier|namespace-alias;

  enterRuleSpec: namespace-definition:named-namespace-definition|unnamed-namespace-definition|nested-namespace-definition;
    enterRuleBlock: named-namespace-definition|unnamed-namespace-definition|nested-namespace-definition
      enterRuleAltList: named-namespace-definition|unnamed-namespace-definition|nested-namespace-definition
        enterLabeledAlt: named-namespace-definition
          enterAlternative: named-namespace-definition
            enterElement: named-namespace-definition
              => element -> {named-namespace-definition}
              enterAtom: named-namespace-definition
                enterRuleref: named-namespace-definition
                exitRuleref: named-namespace-definition
              exitAtom: named-namespace-definition
            exitElement: named-namespace-definition
          exitAlternative: named-namespace-definition
        => elements -> ['{named-namespace-definition}']
            => alternative -> {named-namespace-definition}
        exitLabeledAlt: named-namespace-definition
        enterLabeledAlt: unnamed-namespace-definition
          enterAlternative: unnamed-namespace-definition
            enterElement: unnamed-namespace-definition
              => element -> {unnamed-namespace-definition}
              enterAtom: unnamed-namespace-definition
                enterRuleref: unnamed-namespace-definition
                exitRuleref: unnamed-namespace-definition
              exitAtom: unnamed-namespace-definition
            exitElement: unnamed-namespace-definition
          exitAlternative: unnamed-namespace-definition
        => elements -> ['{unnamed-namespace-definition}']
            => alternative -> {unnamed-namespace-definition}
        exitLabeledAlt: unnamed-namespace-definition
        enterLabeledAlt: nested-namespace-definition
          enterAlternative: nested-namespace-definition
            enterElement: nested-namespace-definition
              => element -> {nested-namespace-definition}
              enterAtom: nested-namespace-definition
                enterRuleref: nested-namespace-definition
                exitRuleref: nested-namespace-definition
              exitAtom: nested-namespace-definition
            exitElement: nested-namespace-definition
          exitAlternative: nested-namespace-definition
        => elements -> ['{nested-namespace-definition}']
            => alternative -> {nested-namespace-definition}
        exitLabeledAlt: nested-namespace-definition
      exitRuleAltList: named-namespace-definition|unnamed-namespace-definition|nested-namespace-definition
    exitRuleBlock: named-namespace-definition|unnamed-namespace-definition|nested-namespace-definition
  exitRuleSpec: namespace-definition:named-namespace-definition|unnamed-namespace-definition|nested-namespace-definition;

  enterRuleSpec: inline:'inline';
    enterRuleBlock: 'inline'
      enterRuleAltList: 'inline'
        enterLabeledAlt: 'inline'
          enterAlternative: 'inline'
            enterElement: 'inline'
              => element -> inline
              enterAtom: 'inline'
                enterTerminal: 'inline'
                exitTerminal: 'inline'
              exitAtom: 'inline'
            exitElement: 'inline'
          exitAlternative: 'inline'
        => elements -> ['inline']
            => alternative -> inline
        exitLabeledAlt: 'inline'
      exitRuleAltList: 'inline'
    exitRuleBlock: 'inline'
  exitRuleSpec: inline:'inline';

  enterRuleSpec: nested-inline:':: inline';
    enterRuleBlock: ':: inline'
      enterRuleAltList: ':: inline'
        enterLabeledAlt: ':: inline'
          enterAlternative: ':: inline'
            enterElement: ':: inline'
              => element -> :: inline
              enterAtom: ':: inline'
                enterTerminal: ':: inline'
                exitTerminal: ':: inline'
              exitAtom: ':: inline'
            exitElement: ':: inline'
          exitAlternative: ':: inline'
        => elements -> [':: inline']
            => alternative -> :: inline
        exitLabeledAlt: ':: inline'
      exitRuleAltList: ':: inline'
    exitRuleBlock: ':: inline'
  exitRuleSpec: nested-inline:':: inline';

  enterRuleSpec: named-namespace-definition:inline?'namespace'attribute-specifier*identifier'{'namespace-body'}';
    enterRuleBlock: inline?'namespace'attribute-specifier*identifier'{'namespace-body'}'
      enterRuleAltList: inline?'namespace'attribute-specifier*identifier'{'namespace-body'}'
        enterLabeledAlt: inline?'namespace'attribute-specifier*identifier'{'namespace-body'}'
          enterAlternative: inline?'namespace'attribute-specifier*identifier'{'namespace-body'}'
            enterElement: inline?
              => element -> [inline]
              enterAtom: inline
                enterRuleref: inline
                exitRuleref: inline
              exitAtom: inline
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: inline?
            enterElement: 'namespace'
              => element -> namespace
              enterAtom: 'namespace'
                enterTerminal: 'namespace'
                exitTerminal: 'namespace'
              exitAtom: 'namespace'
            exitElement: 'namespace'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
            enterElement: namespace-body
              => element -> {namespace-body}
              enterAtom: namespace-body
                enterRuleref: namespace-body
                exitRuleref: namespace-body
              exitAtom: namespace-body
            exitElement: namespace-body
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: inline?'namespace'attribute-specifier*identifier'{'namespace-body'}'
        => elements -> ['[inline]', 'namespace', '[attribute-specifier]...', '{identifier}', '{', '{namespace-body}', '}']
            => alternative -> [inline] namespace [attribute-specifier]... {identifier} { {namespace-body} }
        exitLabeledAlt: inline?'namespace'attribute-specifier*identifier'{'namespace-body'}'
      exitRuleAltList: inline?'namespace'attribute-specifier*identifier'{'namespace-body'}'
    exitRuleBlock: inline?'namespace'attribute-specifier*identifier'{'namespace-body'}'
  exitRuleSpec: named-namespace-definition:inline?'namespace'attribute-specifier*identifier'{'namespace-body'}';

  enterRuleSpec: unnamed-namespace-definition:inline?'namespace'attribute-specifier*'{'namespace-body'}';
    enterRuleBlock: inline?'namespace'attribute-specifier*'{'namespace-body'}'
      enterRuleAltList: inline?'namespace'attribute-specifier*'{'namespace-body'}'
        enterLabeledAlt: inline?'namespace'attribute-specifier*'{'namespace-body'}'
          enterAlternative: inline?'namespace'attribute-specifier*'{'namespace-body'}'
            enterElement: inline?
              => element -> [inline]
              enterAtom: inline
                enterRuleref: inline
                exitRuleref: inline
              exitAtom: inline
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: inline?
            enterElement: 'namespace'
              => element -> namespace
              enterAtom: 'namespace'
                enterTerminal: 'namespace'
                exitTerminal: 'namespace'
              exitAtom: 'namespace'
            exitElement: 'namespace'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
            enterElement: namespace-body
              => element -> {namespace-body}
              enterAtom: namespace-body
                enterRuleref: namespace-body
                exitRuleref: namespace-body
              exitAtom: namespace-body
            exitElement: namespace-body
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: inline?'namespace'attribute-specifier*'{'namespace-body'}'
        => elements -> ['[inline]', 'namespace', '[attribute-specifier]...', '{', '{namespace-body}', '}']
            => alternative -> [inline] namespace [attribute-specifier]... { {namespace-body} }
        exitLabeledAlt: inline?'namespace'attribute-specifier*'{'namespace-body'}'
      exitRuleAltList: inline?'namespace'attribute-specifier*'{'namespace-body'}'
    exitRuleBlock: inline?'namespace'attribute-specifier*'{'namespace-body'}'
  exitRuleSpec: unnamed-namespace-definition:inline?'namespace'attribute-specifier*'{'namespace-body'}';

  enterRuleSpec: nested-namespace-definition:'namespace'enclosing-namespace-specifiernested-inline?identifier'{'namespace-body'}';
    enterRuleBlock: 'namespace'enclosing-namespace-specifiernested-inline?identifier'{'namespace-body'}'
      enterRuleAltList: 'namespace'enclosing-namespace-specifiernested-inline?identifier'{'namespace-body'}'
        enterLabeledAlt: 'namespace'enclosing-namespace-specifiernested-inline?identifier'{'namespace-body'}'
          enterAlternative: 'namespace'enclosing-namespace-specifiernested-inline?identifier'{'namespace-body'}'
            enterElement: 'namespace'
              => element -> namespace
              enterAtom: 'namespace'
                enterTerminal: 'namespace'
                exitTerminal: 'namespace'
              exitAtom: 'namespace'
            exitElement: 'namespace'
            enterElement: enclosing-namespace-specifier
              => element -> {enclosing-namespace-specifier}
              enterAtom: enclosing-namespace-specifier
                enterRuleref: enclosing-namespace-specifier
                exitRuleref: enclosing-namespace-specifier
              exitAtom: enclosing-namespace-specifier
            exitElement: enclosing-namespace-specifier
            enterElement: nested-inline?
              => element -> [nested-inline]
              enterAtom: nested-inline
                enterRuleref: nested-inline
                exitRuleref: nested-inline
              exitAtom: nested-inline
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-inline?
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
            enterElement: namespace-body
              => element -> {namespace-body}
              enterAtom: namespace-body
                enterRuleref: namespace-body
                exitRuleref: namespace-body
              exitAtom: namespace-body
            exitElement: namespace-body
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: 'namespace'enclosing-namespace-specifiernested-inline?identifier'{'namespace-body'}'
        => elements -> ['namespace', '{enclosing-namespace-specifier}', '[nested-inline]', '{identifier}', '{', '{namespace-body}', '}']
            => alternative -> namespace {enclosing-namespace-specifier} [nested-inline] {identifier} { {namespace-body} }
        exitLabeledAlt: 'namespace'enclosing-namespace-specifiernested-inline?identifier'{'namespace-body'}'
      exitRuleAltList: 'namespace'enclosing-namespace-specifiernested-inline?identifier'{'namespace-body'}'
    exitRuleBlock: 'namespace'enclosing-namespace-specifiernested-inline?identifier'{'namespace-body'}'
  exitRuleSpec: nested-namespace-definition:'namespace'enclosing-namespace-specifiernested-inline?identifier'{'namespace-body'}';

  enterRuleSpec: enclosing-namespace-specifier:identifier|enclosing-namespace-specifiernested-inline?identifier;
    enterRuleBlock: identifier|enclosing-namespace-specifiernested-inline?identifier
      enterRuleAltList: identifier|enclosing-namespace-specifiernested-inline?identifier
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
        enterLabeledAlt: enclosing-namespace-specifiernested-inline?identifier
          enterAlternative: enclosing-namespace-specifiernested-inline?identifier
            enterElement: enclosing-namespace-specifier
              => element -> {enclosing-namespace-specifier}
              enterAtom: enclosing-namespace-specifier
                enterRuleref: enclosing-namespace-specifier
                exitRuleref: enclosing-namespace-specifier
              exitAtom: enclosing-namespace-specifier
            exitElement: enclosing-namespace-specifier
            enterElement: nested-inline?
              => element -> [nested-inline]
              enterAtom: nested-inline
                enterRuleref: nested-inline
                exitRuleref: nested-inline
              exitAtom: nested-inline
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-inline?
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: enclosing-namespace-specifiernested-inline?identifier
        => elements -> ['{enclosing-namespace-specifier}', '[nested-inline]', '{identifier}']
            => alternative -> {enclosing-namespace-specifier} [nested-inline] {identifier}
        exitLabeledAlt: enclosing-namespace-specifiernested-inline?identifier
      exitRuleAltList: identifier|enclosing-namespace-specifiernested-inline?identifier
    exitRuleBlock: identifier|enclosing-namespace-specifiernested-inline?identifier
  exitRuleSpec: enclosing-namespace-specifier:identifier|enclosing-namespace-specifiernested-inline?identifier;

  enterRuleSpec: namespace-body:declaration*;
    enterRuleBlock: declaration*
      enterRuleAltList: declaration*
        enterLabeledAlt: declaration*
          enterAlternative: declaration*
            enterElement: declaration*
              => element -> [declaration]...
              enterAtom: declaration
                enterRuleref: declaration
                exitRuleref: declaration
              exitAtom: declaration
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: declaration*
          exitAlternative: declaration*
        => elements -> ['[declaration]...']
            => alternative -> [declaration]...
        exitLabeledAlt: declaration*
      exitRuleAltList: declaration*
    exitRuleBlock: declaration*
  exitRuleSpec: namespace-body:declaration*;

  enterRuleSpec: namespace-alias:identifier;
    enterRuleBlock: identifier
      enterRuleAltList: identifier
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
      exitRuleAltList: identifier
    exitRuleBlock: identifier
  exitRuleSpec: namespace-alias:identifier;

  enterRuleSpec: namespace-alias-definition:'namespace'identifier'='qualified-namespace-specifier';';
    enterRuleBlock: 'namespace'identifier'='qualified-namespace-specifier';'
      enterRuleAltList: 'namespace'identifier'='qualified-namespace-specifier';'
        enterLabeledAlt: 'namespace'identifier'='qualified-namespace-specifier';'
          enterAlternative: 'namespace'identifier'='qualified-namespace-specifier';'
            enterElement: 'namespace'
              => element -> namespace
              enterAtom: 'namespace'
                enterTerminal: 'namespace'
                exitTerminal: 'namespace'
              exitAtom: 'namespace'
            exitElement: 'namespace'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
            enterElement: qualified-namespace-specifier
              => element -> {qualified-namespace-specifier}
              enterAtom: qualified-namespace-specifier
                enterRuleref: qualified-namespace-specifier
                exitRuleref: qualified-namespace-specifier
              exitAtom: qualified-namespace-specifier
            exitElement: qualified-namespace-specifier
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: 'namespace'identifier'='qualified-namespace-specifier';'
        => elements -> ['namespace', '{identifier}', '=', '{qualified-namespace-specifier}', ';']
            => alternative -> namespace {identifier} = {qualified-namespace-specifier} ;
        exitLabeledAlt: 'namespace'identifier'='qualified-namespace-specifier';'
      exitRuleAltList: 'namespace'identifier'='qualified-namespace-specifier';'
    exitRuleBlock: 'namespace'identifier'='qualified-namespace-specifier';'
  exitRuleSpec: namespace-alias-definition:'namespace'identifier'='qualified-namespace-specifier';';

  enterRuleSpec: qualified-namespace-specifier:nested-name-specifier?namespace-name;
    enterRuleBlock: nested-name-specifier?namespace-name
      enterRuleAltList: nested-name-specifier?namespace-name
        enterLabeledAlt: nested-name-specifier?namespace-name
          enterAlternative: nested-name-specifier?namespace-name
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: namespace-name
              => element -> {namespace-name}
              enterAtom: namespace-name
                enterRuleref: namespace-name
                exitRuleref: namespace-name
              exitAtom: namespace-name
            exitElement: namespace-name
          exitAlternative: nested-name-specifier?namespace-name
        => elements -> ['[nested-name-specifier]', '{namespace-name}']
            => alternative -> [nested-name-specifier] {namespace-name}
        exitLabeledAlt: nested-name-specifier?namespace-name
      exitRuleAltList: nested-name-specifier?namespace-name
    exitRuleBlock: nested-name-specifier?namespace-name
  exitRuleSpec: qualified-namespace-specifier:nested-name-specifier?namespace-name;

  enterRuleSpec: using-directive:attribute-specifier*'using namespace'nested-name-specifier?namespace-name';';
    enterRuleBlock: attribute-specifier*'using namespace'nested-name-specifier?namespace-name';'
      enterRuleAltList: attribute-specifier*'using namespace'nested-name-specifier?namespace-name';'
        enterLabeledAlt: attribute-specifier*'using namespace'nested-name-specifier?namespace-name';'
          enterAlternative: attribute-specifier*'using namespace'nested-name-specifier?namespace-name';'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: 'using namespace'
              => element -> using namespace
              enterAtom: 'using namespace'
                enterTerminal: 'using namespace'
                exitTerminal: 'using namespace'
              exitAtom: 'using namespace'
            exitElement: 'using namespace'
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: namespace-name
              => element -> {namespace-name}
              enterAtom: namespace-name
                enterRuleref: namespace-name
                exitRuleref: namespace-name
              exitAtom: namespace-name
            exitElement: namespace-name
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: attribute-specifier*'using namespace'nested-name-specifier?namespace-name';'
        => elements -> ['[attribute-specifier]...', 'using namespace', '[nested-name-specifier]', '{namespace-name}', ';']
            => alternative -> [attribute-specifier]... using namespace [nested-name-specifier] {namespace-name} ;
        exitLabeledAlt: attribute-specifier*'using namespace'nested-name-specifier?namespace-name';'
      exitRuleAltList: attribute-specifier*'using namespace'nested-name-specifier?namespace-name';'
    exitRuleBlock: attribute-specifier*'using namespace'nested-name-specifier?namespace-name';'
  exitRuleSpec: using-directive:attribute-specifier*'using namespace'nested-name-specifier?namespace-name';';

  enterRuleSpec: using-declaration:'using'using-declarator-list';';
    enterRuleBlock: 'using'using-declarator-list';'
      enterRuleAltList: 'using'using-declarator-list';'
        enterLabeledAlt: 'using'using-declarator-list';'
          enterAlternative: 'using'using-declarator-list';'
            enterElement: 'using'
              => element -> using
              enterAtom: 'using'
                enterTerminal: 'using'
                exitTerminal: 'using'
              exitAtom: 'using'
            exitElement: 'using'
            enterElement: using-declarator-list
              => element -> {using-declarator-list}
              enterAtom: using-declarator-list
                enterRuleref: using-declarator-list
                exitRuleref: using-declarator-list
              exitAtom: using-declarator-list
            exitElement: using-declarator-list
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: 'using'using-declarator-list';'
        => elements -> ['using', '{using-declarator-list}', ';']
            => alternative -> using {using-declarator-list} ;
        exitLabeledAlt: 'using'using-declarator-list';'
      exitRuleAltList: 'using'using-declarator-list';'
    exitRuleBlock: 'using'using-declarator-list';'
  exitRuleSpec: using-declaration:'using'using-declarator-list';';

  enterRuleSpec: using-declarator-list:using-declaratorthree-dots?|using-declarator-list','using-declaratorthree-dots?;
    enterRuleBlock: using-declaratorthree-dots?|using-declarator-list','using-declaratorthree-dots?
      enterRuleAltList: using-declaratorthree-dots?|using-declarator-list','using-declaratorthree-dots?
        enterLabeledAlt: using-declaratorthree-dots?
          enterAlternative: using-declaratorthree-dots?
            enterElement: using-declarator
              => element -> {using-declarator}
              enterAtom: using-declarator
                enterRuleref: using-declarator
                exitRuleref: using-declarator
              exitAtom: using-declarator
            exitElement: using-declarator
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
          exitAlternative: using-declaratorthree-dots?
        => elements -> ['{using-declarator}', '[three-dots]']
            => alternative -> {using-declarator} [three-dots]
        exitLabeledAlt: using-declaratorthree-dots?
        enterLabeledAlt: using-declarator-list','using-declaratorthree-dots?
          enterAlternative: using-declarator-list','using-declaratorthree-dots?
            enterElement: using-declarator-list
              => element -> {using-declarator-list}
              enterAtom: using-declarator-list
                enterRuleref: using-declarator-list
                exitRuleref: using-declarator-list
              exitAtom: using-declarator-list
            exitElement: using-declarator-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: using-declarator
              => element -> {using-declarator}
              enterAtom: using-declarator
                enterRuleref: using-declarator
                exitRuleref: using-declarator
              exitAtom: using-declarator
            exitElement: using-declarator
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
          exitAlternative: using-declarator-list','using-declaratorthree-dots?
        => elements -> ['{using-declarator-list}', ',', '{using-declarator}', '[three-dots]']
            => alternative -> {using-declarator-list} , {using-declarator} [three-dots]
        exitLabeledAlt: using-declarator-list','using-declaratorthree-dots?
      exitRuleAltList: using-declaratorthree-dots?|using-declarator-list','using-declaratorthree-dots?
    exitRuleBlock: using-declaratorthree-dots?|using-declarator-list','using-declaratorthree-dots?
  exitRuleSpec: using-declarator-list:using-declaratorthree-dots?|using-declarator-list','using-declaratorthree-dots?;

  enterRuleSpec: typename:'typename';
    enterRuleBlock: 'typename'
      enterRuleAltList: 'typename'
        enterLabeledAlt: 'typename'
          enterAlternative: 'typename'
            enterElement: 'typename'
              => element -> typename
              enterAtom: 'typename'
                enterTerminal: 'typename'
                exitTerminal: 'typename'
              exitAtom: 'typename'
            exitElement: 'typename'
          exitAlternative: 'typename'
        => elements -> ['typename']
            => alternative -> typename
        exitLabeledAlt: 'typename'
      exitRuleAltList: 'typename'
    exitRuleBlock: 'typename'
  exitRuleSpec: typename:'typename';

  enterRuleSpec: using-declarator:typename?nested-name-specifierunqualified-id;
    enterRuleBlock: typename?nested-name-specifierunqualified-id
      enterRuleAltList: typename?nested-name-specifierunqualified-id
        enterLabeledAlt: typename?nested-name-specifierunqualified-id
          enterAlternative: typename?nested-name-specifierunqualified-id
            enterElement: typename?
              => element -> [typename]
              enterAtom: typename
                enterRuleref: typename
                exitRuleref: typename
              exitAtom: typename
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: typename?
            enterElement: nested-name-specifier
              => element -> {nested-name-specifier}
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
            exitElement: nested-name-specifier
            enterElement: unqualified-id
              => element -> {unqualified-id}
              enterAtom: unqualified-id
                enterRuleref: unqualified-id
                exitRuleref: unqualified-id
              exitAtom: unqualified-id
            exitElement: unqualified-id
          exitAlternative: typename?nested-name-specifierunqualified-id
        => elements -> ['[typename]', '{nested-name-specifier}', '{unqualified-id}']
            => alternative -> [typename] {nested-name-specifier} {unqualified-id}
        exitLabeledAlt: typename?nested-name-specifierunqualified-id
      exitRuleAltList: typename?nested-name-specifierunqualified-id
    exitRuleBlock: typename?nested-name-specifierunqualified-id
  exitRuleSpec: using-declarator:typename?nested-name-specifierunqualified-id;

  enterRuleSpec: asm-declaration:attribute-specifier*'asm('balanced-token-seq');';
    enterRuleBlock: attribute-specifier*'asm('balanced-token-seq');'
      enterRuleAltList: attribute-specifier*'asm('balanced-token-seq');'
        enterLabeledAlt: attribute-specifier*'asm('balanced-token-seq');'
          enterAlternative: attribute-specifier*'asm('balanced-token-seq');'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: 'asm('
              => element -> asm(
              enterAtom: 'asm('
                enterTerminal: 'asm('
                exitTerminal: 'asm('
              exitAtom: 'asm('
            exitElement: 'asm('
            enterElement: balanced-token-seq
              => element -> {balanced-token-seq}
              enterAtom: balanced-token-seq
                enterRuleref: balanced-token-seq
                exitRuleref: balanced-token-seq
              exitAtom: balanced-token-seq
            exitElement: balanced-token-seq
            enterElement: ');'
              => element -> );
              enterAtom: ');'
                enterTerminal: ');'
                exitTerminal: ');'
              exitAtom: ');'
            exitElement: ');'
          exitAlternative: attribute-specifier*'asm('balanced-token-seq');'
        => elements -> ['[attribute-specifier]...', 'asm(', '{balanced-token-seq}', ');']
            => alternative -> [attribute-specifier]... asm( {balanced-token-seq} );
        exitLabeledAlt: attribute-specifier*'asm('balanced-token-seq');'
      exitRuleAltList: attribute-specifier*'asm('balanced-token-seq');'
    exitRuleBlock: attribute-specifier*'asm('balanced-token-seq');'
  exitRuleSpec: asm-declaration:attribute-specifier*'asm('balanced-token-seq');';

  enterRuleSpec: linkage-specification:'extern'unevaluated-string'{'declaration*'}'|'extern'unevaluated-stringname-declaration;
    enterRuleBlock: 'extern'unevaluated-string'{'declaration*'}'|'extern'unevaluated-stringname-declaration
      enterRuleAltList: 'extern'unevaluated-string'{'declaration*'}'|'extern'unevaluated-stringname-declaration
        enterLabeledAlt: 'extern'unevaluated-string'{'declaration*'}'
          enterAlternative: 'extern'unevaluated-string'{'declaration*'}'
            enterElement: 'extern'
              => element -> extern
              enterAtom: 'extern'
                enterTerminal: 'extern'
                exitTerminal: 'extern'
              exitAtom: 'extern'
            exitElement: 'extern'
            enterElement: unevaluated-string
              => element -> {unevaluated-string}
              enterAtom: unevaluated-string
                enterRuleref: unevaluated-string
                exitRuleref: unevaluated-string
              exitAtom: unevaluated-string
            exitElement: unevaluated-string
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
            enterElement: declaration*
              => element -> [declaration]...
              enterAtom: declaration
                enterRuleref: declaration
                exitRuleref: declaration
              exitAtom: declaration
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: declaration*
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: 'extern'unevaluated-string'{'declaration*'}'
        => elements -> ['extern', '{unevaluated-string}', '{', '[declaration]...', '}']
            => alternative -> extern {unevaluated-string} { [declaration]... }
        exitLabeledAlt: 'extern'unevaluated-string'{'declaration*'}'
        enterLabeledAlt: 'extern'unevaluated-stringname-declaration
          enterAlternative: 'extern'unevaluated-stringname-declaration
            enterElement: 'extern'
              => element -> extern
              enterAtom: 'extern'
                enterTerminal: 'extern'
                exitTerminal: 'extern'
              exitAtom: 'extern'
            exitElement: 'extern'
            enterElement: unevaluated-string
              => element -> {unevaluated-string}
              enterAtom: unevaluated-string
                enterRuleref: unevaluated-string
                exitRuleref: unevaluated-string
              exitAtom: unevaluated-string
            exitElement: unevaluated-string
            enterElement: name-declaration
              => element -> {name-declaration}
              enterAtom: name-declaration
                enterRuleref: name-declaration
                exitRuleref: name-declaration
              exitAtom: name-declaration
            exitElement: name-declaration
          exitAlternative: 'extern'unevaluated-stringname-declaration
        => elements -> ['extern', '{unevaluated-string}', '{name-declaration}']
            => alternative -> extern {unevaluated-string} {name-declaration}
        exitLabeledAlt: 'extern'unevaluated-stringname-declaration
      exitRuleAltList: 'extern'unevaluated-string'{'declaration*'}'|'extern'unevaluated-stringname-declaration
    exitRuleBlock: 'extern'unevaluated-string'{'declaration*'}'|'extern'unevaluated-stringname-declaration
  exitRuleSpec: linkage-specification:'extern'unevaluated-string'{'declaration*'}'|'extern'unevaluated-stringname-declaration;

  enterRuleSpec: attribute-specifierannotations(separator=', ',substitute_count='10',description='Some text',dublication='vertical',auto_substitute='yes'):'[['attribute-using-prefix?attribute-list']]'|alignment-specifier;
    enterAnnotationsSpec: annotations(separator=', ',substitute_count='10',description='Some text',dublication='vertical',auto_substitute='yes')
      enterAnnotationBlockSeq: separator=', ',substitute_count='10',description='Some text',dublication='vertical',auto_substitute='yes'
        enterAnnotationBlock: separator=', '
          enterAnnotationKey: separator
            enterIdentifier: separator
            exitIdentifier: separator
          exitAnnotationKey: separator
          enterAnnotationValue: ', '
          exitAnnotationValue: ', '
        exitAnnotationBlock: separator=', '
        enterAnnotationBlockSeq: substitute_count='10',description='Some text',dublication='vertical',auto_substitute='yes'
          enterAnnotationBlock: substitute_count='10'
            enterAnnotationKey: substitute_count
              enterIdentifier: substitute_count
              exitIdentifier: substitute_count
            exitAnnotationKey: substitute_count
            enterAnnotationValue: '10'
            exitAnnotationValue: '10'
          exitAnnotationBlock: substitute_count='10'
          enterAnnotationBlockSeq: description='Some text',dublication='vertical',auto_substitute='yes'
            enterAnnotationBlock: description='Some text'
              enterAnnotationKey: description
                enterIdentifier: description
                exitIdentifier: description
              exitAnnotationKey: description
              enterAnnotationValue: 'Some text'
              exitAnnotationValue: 'Some text'
            exitAnnotationBlock: description='Some text'
            enterAnnotationBlockSeq: dublication='vertical',auto_substitute='yes'
              enterAnnotationBlock: dublication='vertical'
                enterAnnotationKey: dublication
                  enterIdentifier: dublication
                  exitIdentifier: dublication
                exitAnnotationKey: dublication
                enterAnnotationValue: 'vertical'
                exitAnnotationValue: 'vertical'
              exitAnnotationBlock: dublication='vertical'
              enterAnnotationBlockSeq: auto_substitute='yes'
                enterAnnotationBlock: auto_substitute='yes'
                  enterAnnotationKey: auto_substitute
                    enterIdentifier: auto_substitute
                    exitIdentifier: auto_substitute
                  exitAnnotationKey: auto_substitute
                  enterAnnotationValue: 'yes'
                  exitAnnotationValue: 'yes'
                exitAnnotationBlock: auto_substitute='yes'
              exitAnnotationBlockSeq: auto_substitute='yes'
            exitAnnotationBlockSeq: dublication='vertical',auto_substitute='yes'
          exitAnnotationBlockSeq: description='Some text',dublication='vertical',auto_substitute='yes'
        exitAnnotationBlockSeq: substitute_count='10',description='Some text',dublication='vertical',auto_substitute='yes'
      exitAnnotationBlockSeq: separator=', ',substitute_count='10',description='Some text',dublication='vertical',auto_substitute='yes'
    exitAnnotationsSpec: annotations(separator=', ',substitute_count='10',description='Some text',dublication='vertical',auto_substitute='yes')
    enterRuleBlock: '[['attribute-using-prefix?attribute-list']]'|alignment-specifier
      enterRuleAltList: '[['attribute-using-prefix?attribute-list']]'|alignment-specifier
        enterLabeledAlt: '[['attribute-using-prefix?attribute-list']]'
          enterAlternative: '[['attribute-using-prefix?attribute-list']]'
            enterElement: '[['
              => element -> [[
              enterAtom: '[['
                enterTerminal: '[['
                exitTerminal: '[['
              exitAtom: '[['
            exitElement: '[['
            enterElement: attribute-using-prefix?
              => element -> [attribute-using-prefix]
              enterAtom: attribute-using-prefix
                enterRuleref: attribute-using-prefix
                exitRuleref: attribute-using-prefix
              exitAtom: attribute-using-prefix
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: attribute-using-prefix?
            enterElement: attribute-list
              => element -> {attribute-list}
              enterAtom: attribute-list
                enterRuleref: attribute-list
                exitRuleref: attribute-list
              exitAtom: attribute-list
            exitElement: attribute-list
            enterElement: ']]'
              => element -> ]]
              enterAtom: ']]'
                enterTerminal: ']]'
                exitTerminal: ']]'
              exitAtom: ']]'
            exitElement: ']]'
          exitAlternative: '[['attribute-using-prefix?attribute-list']]'
        => elements -> ['[[', '[attribute-using-prefix]', '{attribute-list}', ']]']
            => alternative -> [[ [attribute-using-prefix] {attribute-list} ]]
        exitLabeledAlt: '[['attribute-using-prefix?attribute-list']]'
        enterLabeledAlt: alignment-specifier
          enterAlternative: alignment-specifier
            enterElement: alignment-specifier
              => element -> {alignment-specifier}
              enterAtom: alignment-specifier
                enterRuleref: alignment-specifier
                exitRuleref: alignment-specifier
              exitAtom: alignment-specifier
            exitElement: alignment-specifier
          exitAlternative: alignment-specifier
        => elements -> ['{alignment-specifier}']
            => alternative -> {alignment-specifier}
        exitLabeledAlt: alignment-specifier
      exitRuleAltList: '[['attribute-using-prefix?attribute-list']]'|alignment-specifier
    exitRuleBlock: '[['attribute-using-prefix?attribute-list']]'|alignment-specifier
  exitRuleSpec: attribute-specifierannotations(separator=', ',substitute_count='10',description='Some text',dublication='vertical',auto_substitute='yes'):'[['attribute-using-prefix?attribute-list']]'|alignment-specifier;

  enterRuleSpec: alignment-specifier:'alignas('type-idthree-dots?')'|'alignas('constant-expressionthree-dots?')';
    enterRuleBlock: 'alignas('type-idthree-dots?')'|'alignas('constant-expressionthree-dots?')'
      enterRuleAltList: 'alignas('type-idthree-dots?')'|'alignas('constant-expressionthree-dots?')'
        enterLabeledAlt: 'alignas('type-idthree-dots?')'
          enterAlternative: 'alignas('type-idthree-dots?')'
            enterElement: 'alignas('
              => element -> alignas(
              enterAtom: 'alignas('
                enterTerminal: 'alignas('
                exitTerminal: 'alignas('
              exitAtom: 'alignas('
            exitElement: 'alignas('
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'alignas('type-idthree-dots?')'
        => elements -> ['alignas(', '{type-id}', '[three-dots]', ')']
            => alternative -> alignas( {type-id} [three-dots] )
        exitLabeledAlt: 'alignas('type-idthree-dots?')'
        enterLabeledAlt: 'alignas('constant-expressionthree-dots?')'
          enterAlternative: 'alignas('constant-expressionthree-dots?')'
            enterElement: 'alignas('
              => element -> alignas(
              enterAtom: 'alignas('
                enterTerminal: 'alignas('
                exitTerminal: 'alignas('
              exitAtom: 'alignas('
            exitElement: 'alignas('
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'alignas('constant-expressionthree-dots?')'
        => elements -> ['alignas(', '{constant-expression}', '[three-dots]', ')']
            => alternative -> alignas( {constant-expression} [three-dots] )
        exitLabeledAlt: 'alignas('constant-expressionthree-dots?')'
      exitRuleAltList: 'alignas('type-idthree-dots?')'|'alignas('constant-expressionthree-dots?')'
    exitRuleBlock: 'alignas('type-idthree-dots?')'|'alignas('constant-expressionthree-dots?')'
  exitRuleSpec: alignment-specifier:'alignas('type-idthree-dots?')'|'alignas('constant-expressionthree-dots?')';

  enterRuleSpec: attribute-using-prefix:'using'attribute-namespace':';
    enterRuleBlock: 'using'attribute-namespace':'
      enterRuleAltList: 'using'attribute-namespace':'
        enterLabeledAlt: 'using'attribute-namespace':'
          enterAlternative: 'using'attribute-namespace':'
            enterElement: 'using'
              => element -> using
              enterAtom: 'using'
                enterTerminal: 'using'
                exitTerminal: 'using'
              exitAtom: 'using'
            exitElement: 'using'
            enterElement: attribute-namespace
              => element -> {attribute-namespace}
              enterAtom: attribute-namespace
                enterRuleref: attribute-namespace
                exitRuleref: attribute-namespace
              exitAtom: attribute-namespace
            exitElement: attribute-namespace
            enterElement: ':'
              => element -> :
              enterAtom: ':'
                enterTerminal: ':'
                exitTerminal: ':'
              exitAtom: ':'
            exitElement: ':'
          exitAlternative: 'using'attribute-namespace':'
        => elements -> ['using', '{attribute-namespace}', ':']
            => alternative -> using {attribute-namespace} :
        exitLabeledAlt: 'using'attribute-namespace':'
      exitRuleAltList: 'using'attribute-namespace':'
    exitRuleBlock: 'using'attribute-namespace':'
  exitRuleSpec: attribute-using-prefix:'using'attribute-namespace':';

  enterRuleSpec: attribute-list:attribute?|attribute-list','attribute?|attribute'...'|attribute-list','attribute'...';
    enterRuleBlock: attribute?|attribute-list','attribute?|attribute'...'|attribute-list','attribute'...'
      enterRuleAltList: attribute?|attribute-list','attribute?|attribute'...'|attribute-list','attribute'...'
        enterLabeledAlt: attribute?
          enterAlternative: attribute?
            enterElement: attribute?
              => element -> [attribute]
              enterAtom: attribute
                enterRuleref: attribute
                exitRuleref: attribute
              exitAtom: attribute
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: attribute?
          exitAlternative: attribute?
        => elements -> ['[attribute]']
            => alternative -> [attribute]
        exitLabeledAlt: attribute?
        enterLabeledAlt: attribute-list','attribute?
          enterAlternative: attribute-list','attribute?
            enterElement: attribute-list
              => element -> {attribute-list}
              enterAtom: attribute-list
                enterRuleref: attribute-list
                exitRuleref: attribute-list
              exitAtom: attribute-list
            exitElement: attribute-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: attribute?
              => element -> [attribute]
              enterAtom: attribute
                enterRuleref: attribute
                exitRuleref: attribute
              exitAtom: attribute
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: attribute?
          exitAlternative: attribute-list','attribute?
        => elements -> ['{attribute-list}', ',', '[attribute]']
            => alternative -> {attribute-list} , [attribute]
        exitLabeledAlt: attribute-list','attribute?
        enterLabeledAlt: attribute'...'
          enterAlternative: attribute'...'
            enterElement: attribute
              => element -> {attribute}
              enterAtom: attribute
                enterRuleref: attribute
                exitRuleref: attribute
              exitAtom: attribute
            exitElement: attribute
            enterElement: '...'
              => element -> ...
              enterAtom: '...'
                enterTerminal: '...'
                exitTerminal: '...'
              exitAtom: '...'
            exitElement: '...'
          exitAlternative: attribute'...'
        => elements -> ['{attribute}', '...']
            => alternative -> {attribute} ...
        exitLabeledAlt: attribute'...'
        enterLabeledAlt: attribute-list','attribute'...'
          enterAlternative: attribute-list','attribute'...'
            enterElement: attribute-list
              => element -> {attribute-list}
              enterAtom: attribute-list
                enterRuleref: attribute-list
                exitRuleref: attribute-list
              exitAtom: attribute-list
            exitElement: attribute-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: attribute
              => element -> {attribute}
              enterAtom: attribute
                enterRuleref: attribute
                exitRuleref: attribute
              exitAtom: attribute
            exitElement: attribute
            enterElement: '...'
              => element -> ...
              enterAtom: '...'
                enterTerminal: '...'
                exitTerminal: '...'
              exitAtom: '...'
            exitElement: '...'
          exitAlternative: attribute-list','attribute'...'
        => elements -> ['{attribute-list}', ',', '{attribute}', '...']
            => alternative -> {attribute-list} , {attribute} ...
        exitLabeledAlt: attribute-list','attribute'...'
      exitRuleAltList: attribute?|attribute-list','attribute?|attribute'...'|attribute-list','attribute'...'
    exitRuleBlock: attribute?|attribute-list','attribute?|attribute'...'|attribute-list','attribute'...'
  exitRuleSpec: attribute-list:attribute?|attribute-list','attribute?|attribute'...'|attribute-list','attribute'...';

  enterRuleSpec: attribute:attribute-tokenattribute-argument-clause?;
    enterRuleBlock: attribute-tokenattribute-argument-clause?
      enterRuleAltList: attribute-tokenattribute-argument-clause?
        enterLabeledAlt: attribute-tokenattribute-argument-clause?
          enterAlternative: attribute-tokenattribute-argument-clause?
            enterElement: attribute-token
              => element -> {attribute-token}
              enterAtom: attribute-token
                enterRuleref: attribute-token
                exitRuleref: attribute-token
              exitAtom: attribute-token
            exitElement: attribute-token
            enterElement: attribute-argument-clause?
              => element -> [attribute-argument-clause]
              enterAtom: attribute-argument-clause
                enterRuleref: attribute-argument-clause
                exitRuleref: attribute-argument-clause
              exitAtom: attribute-argument-clause
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: attribute-argument-clause?
          exitAlternative: attribute-tokenattribute-argument-clause?
        => elements -> ['{attribute-token}', '[attribute-argument-clause]']
            => alternative -> {attribute-token} [attribute-argument-clause]
        exitLabeledAlt: attribute-tokenattribute-argument-clause?
      exitRuleAltList: attribute-tokenattribute-argument-clause?
    exitRuleBlock: attribute-tokenattribute-argument-clause?
  exitRuleSpec: attribute:attribute-tokenattribute-argument-clause?;

  enterRuleSpec: attribute-token:identifier|attribute-scoped-token;
    enterRuleBlock: identifier|attribute-scoped-token
      enterRuleAltList: identifier|attribute-scoped-token
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
        enterLabeledAlt: attribute-scoped-token
          enterAlternative: attribute-scoped-token
            enterElement: attribute-scoped-token
              => element -> {attribute-scoped-token}
              enterAtom: attribute-scoped-token
                enterRuleref: attribute-scoped-token
                exitRuleref: attribute-scoped-token
              exitAtom: attribute-scoped-token
            exitElement: attribute-scoped-token
          exitAlternative: attribute-scoped-token
        => elements -> ['{attribute-scoped-token}']
            => alternative -> {attribute-scoped-token}
        exitLabeledAlt: attribute-scoped-token
      exitRuleAltList: identifier|attribute-scoped-token
    exitRuleBlock: identifier|attribute-scoped-token
  exitRuleSpec: attribute-token:identifier|attribute-scoped-token;

  enterRuleSpec: attribute-scoped-token:attribute-namespace'::'identifier;
    enterRuleBlock: attribute-namespace'::'identifier
      enterRuleAltList: attribute-namespace'::'identifier
        enterLabeledAlt: attribute-namespace'::'identifier
          enterAlternative: attribute-namespace'::'identifier
            enterElement: attribute-namespace
              => element -> {attribute-namespace}
              enterAtom: attribute-namespace
                enterRuleref: attribute-namespace
                exitRuleref: attribute-namespace
              exitAtom: attribute-namespace
            exitElement: attribute-namespace
            enterElement: '::'
              => element -> ::
              enterAtom: '::'
                enterTerminal: '::'
                exitTerminal: '::'
              exitAtom: '::'
            exitElement: '::'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: attribute-namespace'::'identifier
        => elements -> ['{attribute-namespace}', '::', '{identifier}']
            => alternative -> {attribute-namespace} :: {identifier}
        exitLabeledAlt: attribute-namespace'::'identifier
      exitRuleAltList: attribute-namespace'::'identifier
    exitRuleBlock: attribute-namespace'::'identifier
  exitRuleSpec: attribute-scoped-token:attribute-namespace'::'identifier;

  enterRuleSpec: attribute-namespace:identifier;
    enterRuleBlock: identifier
      enterRuleAltList: identifier
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
      exitRuleAltList: identifier
    exitRuleBlock: identifier
  exitRuleSpec: attribute-namespace:identifier;

  enterRuleSpec: attribute-argument-clause:'('balanced-token-seq?')';
    enterRuleBlock: '('balanced-token-seq?')'
      enterRuleAltList: '('balanced-token-seq?')'
        enterLabeledAlt: '('balanced-token-seq?')'
          enterAlternative: '('balanced-token-seq?')'
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: balanced-token-seq?
              => element -> [balanced-token-seq]
              enterAtom: balanced-token-seq
                enterRuleref: balanced-token-seq
                exitRuleref: balanced-token-seq
              exitAtom: balanced-token-seq
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: balanced-token-seq?
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '('balanced-token-seq?')'
        => elements -> ['(', '[balanced-token-seq]', ')']
            => alternative -> ( [balanced-token-seq] )
        exitLabeledAlt: '('balanced-token-seq?')'
      exitRuleAltList: '('balanced-token-seq?')'
    exitRuleBlock: '('balanced-token-seq?')'
  exitRuleSpec: attribute-argument-clause:'('balanced-token-seq?')';

  enterRuleSpec: balanced-token-seq:balanced-token|balanced-token-seqbalanced-token;
    enterRuleBlock: balanced-token|balanced-token-seqbalanced-token
      enterRuleAltList: balanced-token|balanced-token-seqbalanced-token
        enterLabeledAlt: balanced-token
          enterAlternative: balanced-token
            enterElement: balanced-token
              => element -> {balanced-token}
              enterAtom: balanced-token
                enterRuleref: balanced-token
                exitRuleref: balanced-token
              exitAtom: balanced-token
            exitElement: balanced-token
          exitAlternative: balanced-token
        => elements -> ['{balanced-token}']
            => alternative -> {balanced-token}
        exitLabeledAlt: balanced-token
        enterLabeledAlt: balanced-token-seqbalanced-token
          enterAlternative: balanced-token-seqbalanced-token
            enterElement: balanced-token-seq
              => element -> {balanced-token-seq}
              enterAtom: balanced-token-seq
                enterRuleref: balanced-token-seq
                exitRuleref: balanced-token-seq
              exitAtom: balanced-token-seq
            exitElement: balanced-token-seq
            enterElement: balanced-token
              => element -> {balanced-token}
              enterAtom: balanced-token
                enterRuleref: balanced-token
                exitRuleref: balanced-token
              exitAtom: balanced-token
            exitElement: balanced-token
          exitAlternative: balanced-token-seqbalanced-token
        => elements -> ['{balanced-token-seq}', '{balanced-token}']
            => alternative -> {balanced-token-seq} {balanced-token}
        exitLabeledAlt: balanced-token-seqbalanced-token
      exitRuleAltList: balanced-token|balanced-token-seqbalanced-token
    exitRuleBlock: balanced-token|balanced-token-seqbalanced-token
  exitRuleSpec: balanced-token-seq:balanced-token|balanced-token-seqbalanced-token;

  enterRuleSpec: non_balanced_token:'<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>';
    enterRuleBlock: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
      enterRuleAltList: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
        enterLabeledAlt: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
          enterAlternative: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
            enterElement: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
              => element -> <<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>
              enterAtom: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
                enterTerminal: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
                exitTerminal: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
              exitAtom: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
            exitElement: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
          exitAlternative: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
        => elements -> ['<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>']
            => alternative -> <<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>
        exitLabeledAlt: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
      exitRuleAltList: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
    exitRuleBlock: '<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
  exitRuleSpec: non_balanced_token:'<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>';

  enterRuleSpec: balanced-token:'('balanced-token-seq?')'|'['balanced-token-seq?']'|'{'balanced-token-seq?'}'|non_balanced_token;
    enterRuleBlock: '('balanced-token-seq?')'|'['balanced-token-seq?']'|'{'balanced-token-seq?'}'|non_balanced_token
      enterRuleAltList: '('balanced-token-seq?')'|'['balanced-token-seq?']'|'{'balanced-token-seq?'}'|non_balanced_token
        enterLabeledAlt: '('balanced-token-seq?')'
          enterAlternative: '('balanced-token-seq?')'
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: balanced-token-seq?
              => element -> [balanced-token-seq]
              enterAtom: balanced-token-seq
                enterRuleref: balanced-token-seq
                exitRuleref: balanced-token-seq
              exitAtom: balanced-token-seq
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: balanced-token-seq?
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '('balanced-token-seq?')'
        => elements -> ['(', '[balanced-token-seq]', ')']
            => alternative -> ( [balanced-token-seq] )
        exitLabeledAlt: '('balanced-token-seq?')'
        enterLabeledAlt: '['balanced-token-seq?']'
          enterAlternative: '['balanced-token-seq?']'
            enterElement: '['
              => element -> [
              enterAtom: '['
                enterTerminal: '['
                exitTerminal: '['
              exitAtom: '['
            exitElement: '['
            enterElement: balanced-token-seq?
              => element -> [balanced-token-seq]
              enterAtom: balanced-token-seq
                enterRuleref: balanced-token-seq
                exitRuleref: balanced-token-seq
              exitAtom: balanced-token-seq
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: balanced-token-seq?
            enterElement: ']'
              => element -> ]
              enterAtom: ']'
                enterTerminal: ']'
                exitTerminal: ']'
              exitAtom: ']'
            exitElement: ']'
          exitAlternative: '['balanced-token-seq?']'
        => elements -> ['[', '[balanced-token-seq]', ']']
            => alternative -> [ [balanced-token-seq] ]
        exitLabeledAlt: '['balanced-token-seq?']'
        enterLabeledAlt: '{'balanced-token-seq?'}'
          enterAlternative: '{'balanced-token-seq?'}'
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
            enterElement: balanced-token-seq?
              => element -> [balanced-token-seq]
              enterAtom: balanced-token-seq
                enterRuleref: balanced-token-seq
                exitRuleref: balanced-token-seq
              exitAtom: balanced-token-seq
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: balanced-token-seq?
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: '{'balanced-token-seq?'}'
        => elements -> ['{', '[balanced-token-seq]', '}']
            => alternative -> { [balanced-token-seq] }
        exitLabeledAlt: '{'balanced-token-seq?'}'
        enterLabeledAlt: non_balanced_token
          enterAlternative: non_balanced_token
            enterElement: non_balanced_token
              => element -> {non_balanced_token}
              enterAtom: non_balanced_token
                enterRuleref: non_balanced_token
                exitRuleref: non_balanced_token
              exitAtom: non_balanced_token
            exitElement: non_balanced_token
          exitAlternative: non_balanced_token
        => elements -> ['{non_balanced_token}']
            => alternative -> {non_balanced_token}
        exitLabeledAlt: non_balanced_token
      exitRuleAltList: '('balanced-token-seq?')'|'['balanced-token-seq?']'|'{'balanced-token-seq?'}'|non_balanced_token
    exitRuleBlock: '('balanced-token-seq?')'|'['balanced-token-seq?']'|'{'balanced-token-seq?'}'|non_balanced_token
  exitRuleSpec: balanced-token:'('balanced-token-seq?')'|'['balanced-token-seq?']'|'{'balanced-token-seq?'}'|non_balanced_token;

  enterRuleSpec: module-declaration:export-keyword?module-keywordmodule-namemodule-partition?attribute-specifier*';';
    enterRuleBlock: export-keyword?module-keywordmodule-namemodule-partition?attribute-specifier*';'
      enterRuleAltList: export-keyword?module-keywordmodule-namemodule-partition?attribute-specifier*';'
        enterLabeledAlt: export-keyword?module-keywordmodule-namemodule-partition?attribute-specifier*';'
          enterAlternative: export-keyword?module-keywordmodule-namemodule-partition?attribute-specifier*';'
            enterElement: export-keyword?
              => element -> [export-keyword]
              enterAtom: export-keyword
                enterRuleref: export-keyword
                exitRuleref: export-keyword
              exitAtom: export-keyword
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: export-keyword?
            enterElement: module-keyword
              => element -> {module-keyword}
              enterAtom: module-keyword
                enterRuleref: module-keyword
                exitRuleref: module-keyword
              exitAtom: module-keyword
            exitElement: module-keyword
            enterElement: module-name
              => element -> {module-name}
              enterAtom: module-name
                enterRuleref: module-name
                exitRuleref: module-name
              exitAtom: module-name
            exitElement: module-name
            enterElement: module-partition?
              => element -> [module-partition]
              enterAtom: module-partition
                enterRuleref: module-partition
                exitRuleref: module-partition
              exitAtom: module-partition
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: module-partition?
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: export-keyword?module-keywordmodule-namemodule-partition?attribute-specifier*';'
        => elements -> ['[export-keyword]', '{module-keyword}', '{module-name}', '[module-partition]', '[attribute-specifier]...', ';']
            => alternative -> [export-keyword] {module-keyword} {module-name} [module-partition] [attribute-specifier]... ;
        exitLabeledAlt: export-keyword?module-keywordmodule-namemodule-partition?attribute-specifier*';'
      exitRuleAltList: export-keyword?module-keywordmodule-namemodule-partition?attribute-specifier*';'
    exitRuleBlock: export-keyword?module-keywordmodule-namemodule-partition?attribute-specifier*';'
  exitRuleSpec: module-declaration:export-keyword?module-keywordmodule-namemodule-partition?attribute-specifier*';';

  enterRuleSpec: module-name:module-name-qualifier?identifier;
    enterRuleBlock: module-name-qualifier?identifier
      enterRuleAltList: module-name-qualifier?identifier
        enterLabeledAlt: module-name-qualifier?identifier
          enterAlternative: module-name-qualifier?identifier
            enterElement: module-name-qualifier?
              => element -> [module-name-qualifier]
              enterAtom: module-name-qualifier
                enterRuleref: module-name-qualifier
                exitRuleref: module-name-qualifier
              exitAtom: module-name-qualifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: module-name-qualifier?
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: module-name-qualifier?identifier
        => elements -> ['[module-name-qualifier]', '{identifier}']
            => alternative -> [module-name-qualifier] {identifier}
        exitLabeledAlt: module-name-qualifier?identifier
      exitRuleAltList: module-name-qualifier?identifier
    exitRuleBlock: module-name-qualifier?identifier
  exitRuleSpec: module-name:module-name-qualifier?identifier;

  enterRuleSpec: module-partition:':'module-name-qualifier?identifier;
    enterRuleBlock: ':'module-name-qualifier?identifier
      enterRuleAltList: ':'module-name-qualifier?identifier
        enterLabeledAlt: ':'module-name-qualifier?identifier
          enterAlternative: ':'module-name-qualifier?identifier
            enterElement: ':'
              => element -> :
              enterAtom: ':'
                enterTerminal: ':'
                exitTerminal: ':'
              exitAtom: ':'
            exitElement: ':'
            enterElement: module-name-qualifier?
              => element -> [module-name-qualifier]
              enterAtom: module-name-qualifier
                enterRuleref: module-name-qualifier
                exitRuleref: module-name-qualifier
              exitAtom: module-name-qualifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: module-name-qualifier?
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: ':'module-name-qualifier?identifier
        => elements -> [':', '[module-name-qualifier]', '{identifier}']
            => alternative -> : [module-name-qualifier] {identifier}
        exitLabeledAlt: ':'module-name-qualifier?identifier
      exitRuleAltList: ':'module-name-qualifier?identifier
    exitRuleBlock: ':'module-name-qualifier?identifier
  exitRuleSpec: module-partition:':'module-name-qualifier?identifier;

  enterRuleSpec: module-name-qualifier:identifier'.'|module-name-qualifieridentifier'.';
    enterRuleBlock: identifier'.'|module-name-qualifieridentifier'.'
      enterRuleAltList: identifier'.'|module-name-qualifieridentifier'.'
        enterLabeledAlt: identifier'.'
          enterAlternative: identifier'.'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: '.'
              => element -> .
              enterAtom: '.'
                enterTerminal: '.'
                exitTerminal: '.'
              exitAtom: '.'
            exitElement: '.'
          exitAlternative: identifier'.'
        => elements -> ['{identifier}', '.']
            => alternative -> {identifier} .
        exitLabeledAlt: identifier'.'
        enterLabeledAlt: module-name-qualifieridentifier'.'
          enterAlternative: module-name-qualifieridentifier'.'
            enterElement: module-name-qualifier
              => element -> {module-name-qualifier}
              enterAtom: module-name-qualifier
                enterRuleref: module-name-qualifier
                exitRuleref: module-name-qualifier
              exitAtom: module-name-qualifier
            exitElement: module-name-qualifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: '.'
              => element -> .
              enterAtom: '.'
                enterTerminal: '.'
                exitTerminal: '.'
              exitAtom: '.'
            exitElement: '.'
          exitAlternative: module-name-qualifieridentifier'.'
        => elements -> ['{module-name-qualifier}', '{identifier}', '.']
            => alternative -> {module-name-qualifier} {identifier} .
        exitLabeledAlt: module-name-qualifieridentifier'.'
      exitRuleAltList: identifier'.'|module-name-qualifieridentifier'.'
    exitRuleBlock: identifier'.'|module-name-qualifieridentifier'.'
  exitRuleSpec: module-name-qualifier:identifier'.'|module-name-qualifieridentifier'.';

  enterRuleSpec: export-declaration:'export'name-declaration|'export {'declaration*'}'|export-keywordmodule-import-declaration;
    enterRuleBlock: 'export'name-declaration|'export {'declaration*'}'|export-keywordmodule-import-declaration
      enterRuleAltList: 'export'name-declaration|'export {'declaration*'}'|export-keywordmodule-import-declaration
        enterLabeledAlt: 'export'name-declaration
          enterAlternative: 'export'name-declaration
            enterElement: 'export'
              => element -> export
              enterAtom: 'export'
                enterTerminal: 'export'
                exitTerminal: 'export'
              exitAtom: 'export'
            exitElement: 'export'
            enterElement: name-declaration
              => element -> {name-declaration}
              enterAtom: name-declaration
                enterRuleref: name-declaration
                exitRuleref: name-declaration
              exitAtom: name-declaration
            exitElement: name-declaration
          exitAlternative: 'export'name-declaration
        => elements -> ['export', '{name-declaration}']
            => alternative -> export {name-declaration}
        exitLabeledAlt: 'export'name-declaration
        enterLabeledAlt: 'export {'declaration*'}'
          enterAlternative: 'export {'declaration*'}'
            enterElement: 'export {'
              => element -> export {
              enterAtom: 'export {'
                enterTerminal: 'export {'
                exitTerminal: 'export {'
              exitAtom: 'export {'
            exitElement: 'export {'
            enterElement: declaration*
              => element -> [declaration]...
              enterAtom: declaration
                enterRuleref: declaration
                exitRuleref: declaration
              exitAtom: declaration
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: declaration*
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: 'export {'declaration*'}'
        => elements -> ['export {', '[declaration]...', '}']
            => alternative -> export { [declaration]... }
        exitLabeledAlt: 'export {'declaration*'}'
        enterLabeledAlt: export-keywordmodule-import-declaration
          enterAlternative: export-keywordmodule-import-declaration
            enterElement: export-keyword
              => element -> {export-keyword}
              enterAtom: export-keyword
                enterRuleref: export-keyword
                exitRuleref: export-keyword
              exitAtom: export-keyword
            exitElement: export-keyword
            enterElement: module-import-declaration
              => element -> {module-import-declaration}
              enterAtom: module-import-declaration
                enterRuleref: module-import-declaration
                exitRuleref: module-import-declaration
              exitAtom: module-import-declaration
            exitElement: module-import-declaration
          exitAlternative: export-keywordmodule-import-declaration
        => elements -> ['{export-keyword}', '{module-import-declaration}']
            => alternative -> {export-keyword} {module-import-declaration}
        exitLabeledAlt: export-keywordmodule-import-declaration
      exitRuleAltList: 'export'name-declaration|'export {'declaration*'}'|export-keywordmodule-import-declaration
    exitRuleBlock: 'export'name-declaration|'export {'declaration*'}'|export-keywordmodule-import-declaration
  exitRuleSpec: export-declaration:'export'name-declaration|'export {'declaration*'}'|export-keywordmodule-import-declaration;

  enterRuleSpec: module-import-declaration:import-keywordmodule-nameattribute-specifier*';'|import-keywordmodule-partitionattribute-specifier*';'|import-keywordheader-nameattribute-specifier*';';
    enterRuleBlock: import-keywordmodule-nameattribute-specifier*';'|import-keywordmodule-partitionattribute-specifier*';'|import-keywordheader-nameattribute-specifier*';'
      enterRuleAltList: import-keywordmodule-nameattribute-specifier*';'|import-keywordmodule-partitionattribute-specifier*';'|import-keywordheader-nameattribute-specifier*';'
        enterLabeledAlt: import-keywordmodule-nameattribute-specifier*';'
          enterAlternative: import-keywordmodule-nameattribute-specifier*';'
            enterElement: import-keyword
              => element -> {import-keyword}
              enterAtom: import-keyword
                enterRuleref: import-keyword
                exitRuleref: import-keyword
              exitAtom: import-keyword
            exitElement: import-keyword
            enterElement: module-name
              => element -> {module-name}
              enterAtom: module-name
                enterRuleref: module-name
                exitRuleref: module-name
              exitAtom: module-name
            exitElement: module-name
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: import-keywordmodule-nameattribute-specifier*';'
        => elements -> ['{import-keyword}', '{module-name}', '[attribute-specifier]...', ';']
            => alternative -> {import-keyword} {module-name} [attribute-specifier]... ;
        exitLabeledAlt: import-keywordmodule-nameattribute-specifier*';'
        enterLabeledAlt: import-keywordmodule-partitionattribute-specifier*';'
          enterAlternative: import-keywordmodule-partitionattribute-specifier*';'
            enterElement: import-keyword
              => element -> {import-keyword}
              enterAtom: import-keyword
                enterRuleref: import-keyword
                exitRuleref: import-keyword
              exitAtom: import-keyword
            exitElement: import-keyword
            enterElement: module-partition
              => element -> {module-partition}
              enterAtom: module-partition
                enterRuleref: module-partition
                exitRuleref: module-partition
              exitAtom: module-partition
            exitElement: module-partition
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: import-keywordmodule-partitionattribute-specifier*';'
        => elements -> ['{import-keyword}', '{module-partition}', '[attribute-specifier]...', ';']
            => alternative -> {import-keyword} {module-partition} [attribute-specifier]... ;
        exitLabeledAlt: import-keywordmodule-partitionattribute-specifier*';'
        enterLabeledAlt: import-keywordheader-nameattribute-specifier*';'
          enterAlternative: import-keywordheader-nameattribute-specifier*';'
            enterElement: import-keyword
              => element -> {import-keyword}
              enterAtom: import-keyword
                enterRuleref: import-keyword
                exitRuleref: import-keyword
              exitAtom: import-keyword
            exitElement: import-keyword
            enterElement: header-name
              => element -> {header-name}
              enterAtom: header-name
                enterRuleref: header-name
                exitRuleref: header-name
              exitAtom: header-name
            exitElement: header-name
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: import-keywordheader-nameattribute-specifier*';'
        => elements -> ['{import-keyword}', '{header-name}', '[attribute-specifier]...', ';']
            => alternative -> {import-keyword} {header-name} [attribute-specifier]... ;
        exitLabeledAlt: import-keywordheader-nameattribute-specifier*';'
      exitRuleAltList: import-keywordmodule-nameattribute-specifier*';'|import-keywordmodule-partitionattribute-specifier*';'|import-keywordheader-nameattribute-specifier*';'
    exitRuleBlock: import-keywordmodule-nameattribute-specifier*';'|import-keywordmodule-partitionattribute-specifier*';'|import-keywordheader-nameattribute-specifier*';'
  exitRuleSpec: module-import-declaration:import-keywordmodule-nameattribute-specifier*';'|import-keywordmodule-partitionattribute-specifier*';'|import-keywordheader-nameattribute-specifier*';';

  enterRuleSpec: global-module-fragment:module-keyword';'declaration*;
    enterRuleBlock: module-keyword';'declaration*
      enterRuleAltList: module-keyword';'declaration*
        enterLabeledAlt: module-keyword';'declaration*
          enterAlternative: module-keyword';'declaration*
            enterElement: module-keyword
              => element -> {module-keyword}
              enterAtom: module-keyword
                enterRuleref: module-keyword
                exitRuleref: module-keyword
              exitAtom: module-keyword
            exitElement: module-keyword
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
            enterElement: declaration*
              => element -> [declaration]...
              enterAtom: declaration
                enterRuleref: declaration
                exitRuleref: declaration
              exitAtom: declaration
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: declaration*
          exitAlternative: module-keyword';'declaration*
        => elements -> ['{module-keyword}', ';', '[declaration]...']
            => alternative -> {module-keyword} ; [declaration]...
        exitLabeledAlt: module-keyword';'declaration*
      exitRuleAltList: module-keyword';'declaration*
    exitRuleBlock: module-keyword';'declaration*
  exitRuleSpec: global-module-fragment:module-keyword';'declaration*;

  enterRuleSpec: private-module-fragment:module-keyword': private;'declaration*;
    enterRuleBlock: module-keyword': private;'declaration*
      enterRuleAltList: module-keyword': private;'declaration*
        enterLabeledAlt: module-keyword': private;'declaration*
          enterAlternative: module-keyword': private;'declaration*
            enterElement: module-keyword
              => element -> {module-keyword}
              enterAtom: module-keyword
                enterRuleref: module-keyword
                exitRuleref: module-keyword
              exitAtom: module-keyword
            exitElement: module-keyword
            enterElement: ': private;'
              => element -> : private;
              enterAtom: ': private;'
                enterTerminal: ': private;'
                exitTerminal: ': private;'
              exitAtom: ': private;'
            exitElement: ': private;'
            enterElement: declaration*
              => element -> [declaration]...
              enterAtom: declaration
                enterRuleref: declaration
                exitRuleref: declaration
              exitAtom: declaration
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: declaration*
          exitAlternative: module-keyword': private;'declaration*
        => elements -> ['{module-keyword}', ': private;', '[declaration]...']
            => alternative -> {module-keyword} : private; [declaration]...
        exitLabeledAlt: module-keyword': private;'declaration*
      exitRuleAltList: module-keyword': private;'declaration*
    exitRuleBlock: module-keyword': private;'declaration*
  exitRuleSpec: private-module-fragment:module-keyword': private;'declaration*;

  enterRuleSpec: class-name:identifier|simple-template-id;
    enterRuleBlock: identifier|simple-template-id
      enterRuleAltList: identifier|simple-template-id
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
        enterLabeledAlt: simple-template-id
          enterAlternative: simple-template-id
            enterElement: simple-template-id
              => element -> {simple-template-id}
              enterAtom: simple-template-id
                enterRuleref: simple-template-id
                exitRuleref: simple-template-id
              exitAtom: simple-template-id
            exitElement: simple-template-id
          exitAlternative: simple-template-id
        => elements -> ['{simple-template-id}']
            => alternative -> {simple-template-id}
        exitLabeledAlt: simple-template-id
      exitRuleAltList: identifier|simple-template-id
    exitRuleBlock: identifier|simple-template-id
  exitRuleSpec: class-name:identifier|simple-template-id;

  enterRuleSpec: class-specifier:class-head'{'member-specification?'}';
    enterRuleBlock: class-head'{'member-specification?'}'
      enterRuleAltList: class-head'{'member-specification?'}'
        enterLabeledAlt: class-head'{'member-specification?'}'
          enterAlternative: class-head'{'member-specification?'}'
            enterElement: class-head
              => element -> {class-head}
              enterAtom: class-head
                enterRuleref: class-head
                exitRuleref: class-head
              exitAtom: class-head
            exitElement: class-head
            enterElement: '{'
              => element -> {
              enterAtom: '{'
                enterTerminal: '{'
                exitTerminal: '{'
              exitAtom: '{'
            exitElement: '{'
            enterElement: member-specification?
              => element -> [member-specification]
              enterAtom: member-specification
                enterRuleref: member-specification
                exitRuleref: member-specification
              exitAtom: member-specification
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: member-specification?
            enterElement: '}'
              => element -> }
              enterAtom: '}'
                enterTerminal: '}'
                exitTerminal: '}'
              exitAtom: '}'
            exitElement: '}'
          exitAlternative: class-head'{'member-specification?'}'
        => elements -> ['{class-head}', '{', '[member-specification]', '}']
            => alternative -> {class-head} { [member-specification] }
        exitLabeledAlt: class-head'{'member-specification?'}'
      exitRuleAltList: class-head'{'member-specification?'}'
    exitRuleBlock: class-head'{'member-specification?'}'
  exitRuleSpec: class-specifier:class-head'{'member-specification?'}';

  enterRuleSpec: class-head:class-keyattribute-specifier*class-head-nameclass-virt-specifier?base-clause?|class-keyattribute-specifier*base-clause?;
    enterRuleBlock: class-keyattribute-specifier*class-head-nameclass-virt-specifier?base-clause?|class-keyattribute-specifier*base-clause?
      enterRuleAltList: class-keyattribute-specifier*class-head-nameclass-virt-specifier?base-clause?|class-keyattribute-specifier*base-clause?
        enterLabeledAlt: class-keyattribute-specifier*class-head-nameclass-virt-specifier?base-clause?
          enterAlternative: class-keyattribute-specifier*class-head-nameclass-virt-specifier?base-clause?
            enterElement: class-key
              => element -> {class-key}
              enterAtom: class-key
                enterRuleref: class-key
                exitRuleref: class-key
              exitAtom: class-key
            exitElement: class-key
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: class-head-name
              => element -> {class-head-name}
              enterAtom: class-head-name
                enterRuleref: class-head-name
                exitRuleref: class-head-name
              exitAtom: class-head-name
            exitElement: class-head-name
            enterElement: class-virt-specifier?
              => element -> [class-virt-specifier]
              enterAtom: class-virt-specifier
                enterRuleref: class-virt-specifier
                exitRuleref: class-virt-specifier
              exitAtom: class-virt-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: class-virt-specifier?
            enterElement: base-clause?
              => element -> [base-clause]
              enterAtom: base-clause
                enterRuleref: base-clause
                exitRuleref: base-clause
              exitAtom: base-clause
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: base-clause?
          exitAlternative: class-keyattribute-specifier*class-head-nameclass-virt-specifier?base-clause?
        => elements -> ['{class-key}', '[attribute-specifier]...', '{class-head-name}', '[class-virt-specifier]', '[base-clause]']
            => alternative -> {class-key} [attribute-specifier]... {class-head-name} [class-virt-specifier] [base-clause]
        exitLabeledAlt: class-keyattribute-specifier*class-head-nameclass-virt-specifier?base-clause?
        enterLabeledAlt: class-keyattribute-specifier*base-clause?
          enterAlternative: class-keyattribute-specifier*base-clause?
            enterElement: class-key
              => element -> {class-key}
              enterAtom: class-key
                enterRuleref: class-key
                exitRuleref: class-key
              exitAtom: class-key
            exitElement: class-key
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: base-clause?
              => element -> [base-clause]
              enterAtom: base-clause
                enterRuleref: base-clause
                exitRuleref: base-clause
              exitAtom: base-clause
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: base-clause?
          exitAlternative: class-keyattribute-specifier*base-clause?
        => elements -> ['{class-key}', '[attribute-specifier]...', '[base-clause]']
            => alternative -> {class-key} [attribute-specifier]... [base-clause]
        exitLabeledAlt: class-keyattribute-specifier*base-clause?
      exitRuleAltList: class-keyattribute-specifier*class-head-nameclass-virt-specifier?base-clause?|class-keyattribute-specifier*base-clause?
    exitRuleBlock: class-keyattribute-specifier*class-head-nameclass-virt-specifier?base-clause?|class-keyattribute-specifier*base-clause?
  exitRuleSpec: class-head:class-keyattribute-specifier*class-head-nameclass-virt-specifier?base-clause?|class-keyattribute-specifier*base-clause?;

  enterRuleSpec: class-head-name:nested-name-specifier?class-name;
    enterRuleBlock: nested-name-specifier?class-name
      enterRuleAltList: nested-name-specifier?class-name
        enterLabeledAlt: nested-name-specifier?class-name
          enterAlternative: nested-name-specifier?class-name
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: class-name
              => element -> {class-name}
              enterAtom: class-name
                enterRuleref: class-name
                exitRuleref: class-name
              exitAtom: class-name
            exitElement: class-name
          exitAlternative: nested-name-specifier?class-name
        => elements -> ['[nested-name-specifier]', '{class-name}']
            => alternative -> [nested-name-specifier] {class-name}
        exitLabeledAlt: nested-name-specifier?class-name
      exitRuleAltList: nested-name-specifier?class-name
    exitRuleBlock: nested-name-specifier?class-name
  exitRuleSpec: class-head-name:nested-name-specifier?class-name;

  enterRuleSpec: class-virt-specifier:'final';
    enterRuleBlock: 'final'
      enterRuleAltList: 'final'
        enterLabeledAlt: 'final'
          enterAlternative: 'final'
            enterElement: 'final'
              => element -> final
              enterAtom: 'final'
                enterTerminal: 'final'
                exitTerminal: 'final'
              exitAtom: 'final'
            exitElement: 'final'
          exitAlternative: 'final'
        => elements -> ['final']
            => alternative -> final
        exitLabeledAlt: 'final'
      exitRuleAltList: 'final'
    exitRuleBlock: 'final'
  exitRuleSpec: class-virt-specifier:'final';

  enterRuleSpec: class-key:'class'|'struct'|'union';
    enterRuleBlock: 'class'|'struct'|'union'
      enterRuleAltList: 'class'|'struct'|'union'
        enterLabeledAlt: 'class'
          enterAlternative: 'class'
            enterElement: 'class'
              => element -> class
              enterAtom: 'class'
                enterTerminal: 'class'
                exitTerminal: 'class'
              exitAtom: 'class'
            exitElement: 'class'
          exitAlternative: 'class'
        => elements -> ['class']
            => alternative -> class
        exitLabeledAlt: 'class'
        enterLabeledAlt: 'struct'
          enterAlternative: 'struct'
            enterElement: 'struct'
              => element -> struct
              enterAtom: 'struct'
                enterTerminal: 'struct'
                exitTerminal: 'struct'
              exitAtom: 'struct'
            exitElement: 'struct'
          exitAlternative: 'struct'
        => elements -> ['struct']
            => alternative -> struct
        exitLabeledAlt: 'struct'
        enterLabeledAlt: 'union'
          enterAlternative: 'union'
            enterElement: 'union'
              => element -> union
              enterAtom: 'union'
                enterTerminal: 'union'
                exitTerminal: 'union'
              exitAtom: 'union'
            exitElement: 'union'
          exitAlternative: 'union'
        => elements -> ['union']
            => alternative -> union
        exitLabeledAlt: 'union'
      exitRuleAltList: 'class'|'struct'|'union'
    exitRuleBlock: 'class'|'struct'|'union'
  exitRuleSpec: class-key:'class'|'struct'|'union';

  enterRuleSpec: member-specification:member-declarationmember-specification?|access-specifier':'member-specification?;
    enterRuleBlock: member-declarationmember-specification?|access-specifier':'member-specification?
      enterRuleAltList: member-declarationmember-specification?|access-specifier':'member-specification?
        enterLabeledAlt: member-declarationmember-specification?
          enterAlternative: member-declarationmember-specification?
            enterElement: member-declaration
              => element -> {member-declaration}
              enterAtom: member-declaration
                enterRuleref: member-declaration
                exitRuleref: member-declaration
              exitAtom: member-declaration
            exitElement: member-declaration
            enterElement: member-specification?
              => element -> [member-specification]
              enterAtom: member-specification
                enterRuleref: member-specification
                exitRuleref: member-specification
              exitAtom: member-specification
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: member-specification?
          exitAlternative: member-declarationmember-specification?
        => elements -> ['{member-declaration}', '[member-specification]']
            => alternative -> {member-declaration} [member-specification]
        exitLabeledAlt: member-declarationmember-specification?
        enterLabeledAlt: access-specifier':'member-specification?
          enterAlternative: access-specifier':'member-specification?
            enterElement: access-specifier
              => element -> {access-specifier}
              enterAtom: access-specifier
                enterRuleref: access-specifier
                exitRuleref: access-specifier
              exitAtom: access-specifier
            exitElement: access-specifier
            enterElement: ':'
              => element -> :
              enterAtom: ':'
                enterTerminal: ':'
                exitTerminal: ':'
              exitAtom: ':'
            exitElement: ':'
            enterElement: member-specification?
              => element -> [member-specification]
              enterAtom: member-specification
                enterRuleref: member-specification
                exitRuleref: member-specification
              exitAtom: member-specification
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: member-specification?
          exitAlternative: access-specifier':'member-specification?
        => elements -> ['{access-specifier}', ':', '[member-specification]']
            => alternative -> {access-specifier} : [member-specification]
        exitLabeledAlt: access-specifier':'member-specification?
      exitRuleAltList: member-declarationmember-specification?|access-specifier':'member-specification?
    exitRuleBlock: member-declarationmember-specification?|access-specifier':'member-specification?
  exitRuleSpec: member-specification:member-declarationmember-specification?|access-specifier':'member-specification?;

  enterRuleSpec: member-declaration:attribute-specifier*decl-specifier-seq?member-declarator-list?';'|function-definition|using-declaration|using-enum-declaration|static-assert-declaration|template-declaration|explicit-specialization|deduction-guide|alias-declaration|opaque-enum-declaration|empty-declaration;
    enterRuleBlock: attribute-specifier*decl-specifier-seq?member-declarator-list?';'|function-definition|using-declaration|using-enum-declaration|static-assert-declaration|template-declaration|explicit-specialization|deduction-guide|alias-declaration|opaque-enum-declaration|empty-declaration
      enterRuleAltList: attribute-specifier*decl-specifier-seq?member-declarator-list?';'|function-definition|using-declaration|using-enum-declaration|static-assert-declaration|template-declaration|explicit-specialization|deduction-guide|alias-declaration|opaque-enum-declaration|empty-declaration
        enterLabeledAlt: attribute-specifier*decl-specifier-seq?member-declarator-list?';'
          enterAlternative: attribute-specifier*decl-specifier-seq?member-declarator-list?';'
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: decl-specifier-seq?
              => element -> [decl-specifier-seq]
              enterAtom: decl-specifier-seq
                enterRuleref: decl-specifier-seq
                exitRuleref: decl-specifier-seq
              exitAtom: decl-specifier-seq
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: decl-specifier-seq?
            enterElement: member-declarator-list?
              => element -> [member-declarator-list]
              enterAtom: member-declarator-list
                enterRuleref: member-declarator-list
                exitRuleref: member-declarator-list
              exitAtom: member-declarator-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: member-declarator-list?
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: attribute-specifier*decl-specifier-seq?member-declarator-list?';'
        => elements -> ['[attribute-specifier]...', '[decl-specifier-seq]', '[member-declarator-list]', ';']
            => alternative -> [attribute-specifier]... [decl-specifier-seq] [member-declarator-list] ;
        exitLabeledAlt: attribute-specifier*decl-specifier-seq?member-declarator-list?';'
        enterLabeledAlt: function-definition
          enterAlternative: function-definition
            enterElement: function-definition
              => element -> {function-definition}
              enterAtom: function-definition
                enterRuleref: function-definition
                exitRuleref: function-definition
              exitAtom: function-definition
            exitElement: function-definition
          exitAlternative: function-definition
        => elements -> ['{function-definition}']
            => alternative -> {function-definition}
        exitLabeledAlt: function-definition
        enterLabeledAlt: using-declaration
          enterAlternative: using-declaration
            enterElement: using-declaration
              => element -> {using-declaration}
              enterAtom: using-declaration
                enterRuleref: using-declaration
                exitRuleref: using-declaration
              exitAtom: using-declaration
            exitElement: using-declaration
          exitAlternative: using-declaration
        => elements -> ['{using-declaration}']
            => alternative -> {using-declaration}
        exitLabeledAlt: using-declaration
        enterLabeledAlt: using-enum-declaration
          enterAlternative: using-enum-declaration
            enterElement: using-enum-declaration
              => element -> {using-enum-declaration}
              enterAtom: using-enum-declaration
                enterRuleref: using-enum-declaration
                exitRuleref: using-enum-declaration
              exitAtom: using-enum-declaration
            exitElement: using-enum-declaration
          exitAlternative: using-enum-declaration
        => elements -> ['{using-enum-declaration}']
            => alternative -> {using-enum-declaration}
        exitLabeledAlt: using-enum-declaration
        enterLabeledAlt: static-assert-declaration
          enterAlternative: static-assert-declaration
            enterElement: static-assert-declaration
              => element -> {static-assert-declaration}
              enterAtom: static-assert-declaration
                enterRuleref: static-assert-declaration
                exitRuleref: static-assert-declaration
              exitAtom: static-assert-declaration
            exitElement: static-assert-declaration
          exitAlternative: static-assert-declaration
        => elements -> ['{static-assert-declaration}']
            => alternative -> {static-assert-declaration}
        exitLabeledAlt: static-assert-declaration
        enterLabeledAlt: template-declaration
          enterAlternative: template-declaration
            enterElement: template-declaration
              => element -> {template-declaration}
              enterAtom: template-declaration
                enterRuleref: template-declaration
                exitRuleref: template-declaration
              exitAtom: template-declaration
            exitElement: template-declaration
          exitAlternative: template-declaration
        => elements -> ['{template-declaration}']
            => alternative -> {template-declaration}
        exitLabeledAlt: template-declaration
        enterLabeledAlt: explicit-specialization
          enterAlternative: explicit-specialization
            enterElement: explicit-specialization
              => element -> {explicit-specialization}
              enterAtom: explicit-specialization
                enterRuleref: explicit-specialization
                exitRuleref: explicit-specialization
              exitAtom: explicit-specialization
            exitElement: explicit-specialization
          exitAlternative: explicit-specialization
        => elements -> ['{explicit-specialization}']
            => alternative -> {explicit-specialization}
        exitLabeledAlt: explicit-specialization
        enterLabeledAlt: deduction-guide
          enterAlternative: deduction-guide
            enterElement: deduction-guide
              => element -> {deduction-guide}
              enterAtom: deduction-guide
                enterRuleref: deduction-guide
                exitRuleref: deduction-guide
              exitAtom: deduction-guide
            exitElement: deduction-guide
          exitAlternative: deduction-guide
        => elements -> ['{deduction-guide}']
            => alternative -> {deduction-guide}
        exitLabeledAlt: deduction-guide
        enterLabeledAlt: alias-declaration
          enterAlternative: alias-declaration
            enterElement: alias-declaration
              => element -> {alias-declaration}
              enterAtom: alias-declaration
                enterRuleref: alias-declaration
                exitRuleref: alias-declaration
              exitAtom: alias-declaration
            exitElement: alias-declaration
          exitAlternative: alias-declaration
        => elements -> ['{alias-declaration}']
            => alternative -> {alias-declaration}
        exitLabeledAlt: alias-declaration
        enterLabeledAlt: opaque-enum-declaration
          enterAlternative: opaque-enum-declaration
            enterElement: opaque-enum-declaration
              => element -> {opaque-enum-declaration}
              enterAtom: opaque-enum-declaration
                enterRuleref: opaque-enum-declaration
                exitRuleref: opaque-enum-declaration
              exitAtom: opaque-enum-declaration
            exitElement: opaque-enum-declaration
          exitAlternative: opaque-enum-declaration
        => elements -> ['{opaque-enum-declaration}']
            => alternative -> {opaque-enum-declaration}
        exitLabeledAlt: opaque-enum-declaration
        enterLabeledAlt: empty-declaration
          enterAlternative: empty-declaration
            enterElement: empty-declaration
              => element -> {empty-declaration}
              enterAtom: empty-declaration
                enterRuleref: empty-declaration
                exitRuleref: empty-declaration
              exitAtom: empty-declaration
            exitElement: empty-declaration
          exitAlternative: empty-declaration
        => elements -> ['{empty-declaration}']
            => alternative -> {empty-declaration}
        exitLabeledAlt: empty-declaration
      exitRuleAltList: attribute-specifier*decl-specifier-seq?member-declarator-list?';'|function-definition|using-declaration|using-enum-declaration|static-assert-declaration|template-declaration|explicit-specialization|deduction-guide|alias-declaration|opaque-enum-declaration|empty-declaration
    exitRuleBlock: attribute-specifier*decl-specifier-seq?member-declarator-list?';'|function-definition|using-declaration|using-enum-declaration|static-assert-declaration|template-declaration|explicit-specialization|deduction-guide|alias-declaration|opaque-enum-declaration|empty-declaration
  exitRuleSpec: member-declaration:attribute-specifier*decl-specifier-seq?member-declarator-list?';'|function-definition|using-declaration|using-enum-declaration|static-assert-declaration|template-declaration|explicit-specialization|deduction-guide|alias-declaration|opaque-enum-declaration|empty-declaration;

  enterRuleSpec: member-declarator-list:member-declarator|member-declarator-list','member-declarator;
    enterRuleBlock: member-declarator|member-declarator-list','member-declarator
      enterRuleAltList: member-declarator|member-declarator-list','member-declarator
        enterLabeledAlt: member-declarator
          enterAlternative: member-declarator
            enterElement: member-declarator
              => element -> {member-declarator}
              enterAtom: member-declarator
                enterRuleref: member-declarator
                exitRuleref: member-declarator
              exitAtom: member-declarator
            exitElement: member-declarator
          exitAlternative: member-declarator
        => elements -> ['{member-declarator}']
            => alternative -> {member-declarator}
        exitLabeledAlt: member-declarator
        enterLabeledAlt: member-declarator-list','member-declarator
          enterAlternative: member-declarator-list','member-declarator
            enterElement: member-declarator-list
              => element -> {member-declarator-list}
              enterAtom: member-declarator-list
                enterRuleref: member-declarator-list
                exitRuleref: member-declarator-list
              exitAtom: member-declarator-list
            exitElement: member-declarator-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: member-declarator
              => element -> {member-declarator}
              enterAtom: member-declarator
                enterRuleref: member-declarator
                exitRuleref: member-declarator
              exitAtom: member-declarator
            exitElement: member-declarator
          exitAlternative: member-declarator-list','member-declarator
        => elements -> ['{member-declarator-list}', ',', '{member-declarator}']
            => alternative -> {member-declarator-list} , {member-declarator}
        exitLabeledAlt: member-declarator-list','member-declarator
      exitRuleAltList: member-declarator|member-declarator-list','member-declarator
    exitRuleBlock: member-declarator|member-declarator-list','member-declarator
  exitRuleSpec: member-declarator-list:member-declarator|member-declarator-list','member-declarator;

  enterRuleSpec: member-declarator:declaratorvirt-specifier-seq?pure-specifier?|declaratorrequires-clause|declaratorbrace-or-equal-initializer?|identifier?attribute-specifier*':'constant-expressionbrace-or-equal-initializer?;
    enterRuleBlock: declaratorvirt-specifier-seq?pure-specifier?|declaratorrequires-clause|declaratorbrace-or-equal-initializer?|identifier?attribute-specifier*':'constant-expressionbrace-or-equal-initializer?
      enterRuleAltList: declaratorvirt-specifier-seq?pure-specifier?|declaratorrequires-clause|declaratorbrace-or-equal-initializer?|identifier?attribute-specifier*':'constant-expressionbrace-or-equal-initializer?
        enterLabeledAlt: declaratorvirt-specifier-seq?pure-specifier?
          enterAlternative: declaratorvirt-specifier-seq?pure-specifier?
            enterElement: declarator
              => element -> {declarator}
              enterAtom: declarator
                enterRuleref: declarator
                exitRuleref: declarator
              exitAtom: declarator
            exitElement: declarator
            enterElement: virt-specifier-seq?
              => element -> [virt-specifier-seq]
              enterAtom: virt-specifier-seq
                enterRuleref: virt-specifier-seq
                exitRuleref: virt-specifier-seq
              exitAtom: virt-specifier-seq
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: virt-specifier-seq?
            enterElement: pure-specifier?
              => element -> [pure-specifier]
              enterAtom: pure-specifier
                enterRuleref: pure-specifier
                exitRuleref: pure-specifier
              exitAtom: pure-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: pure-specifier?
          exitAlternative: declaratorvirt-specifier-seq?pure-specifier?
        => elements -> ['{declarator}', '[virt-specifier-seq]', '[pure-specifier]']
            => alternative -> {declarator} [virt-specifier-seq] [pure-specifier]
        exitLabeledAlt: declaratorvirt-specifier-seq?pure-specifier?
        enterLabeledAlt: declaratorrequires-clause
          enterAlternative: declaratorrequires-clause
            enterElement: declarator
              => element -> {declarator}
              enterAtom: declarator
                enterRuleref: declarator
                exitRuleref: declarator
              exitAtom: declarator
            exitElement: declarator
            enterElement: requires-clause
              => element -> {requires-clause}
              enterAtom: requires-clause
                enterRuleref: requires-clause
                exitRuleref: requires-clause
              exitAtom: requires-clause
            exitElement: requires-clause
          exitAlternative: declaratorrequires-clause
        => elements -> ['{declarator}', '{requires-clause}']
            => alternative -> {declarator} {requires-clause}
        exitLabeledAlt: declaratorrequires-clause
        enterLabeledAlt: declaratorbrace-or-equal-initializer?
          enterAlternative: declaratorbrace-or-equal-initializer?
            enterElement: declarator
              => element -> {declarator}
              enterAtom: declarator
                enterRuleref: declarator
                exitRuleref: declarator
              exitAtom: declarator
            exitElement: declarator
            enterElement: brace-or-equal-initializer?
              => element -> [brace-or-equal-initializer]
              enterAtom: brace-or-equal-initializer
                enterRuleref: brace-or-equal-initializer
                exitRuleref: brace-or-equal-initializer
              exitAtom: brace-or-equal-initializer
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: brace-or-equal-initializer?
          exitAlternative: declaratorbrace-or-equal-initializer?
        => elements -> ['{declarator}', '[brace-or-equal-initializer]']
            => alternative -> {declarator} [brace-or-equal-initializer]
        exitLabeledAlt: declaratorbrace-or-equal-initializer?
        enterLabeledAlt: identifier?attribute-specifier*':'constant-expressionbrace-or-equal-initializer?
          enterAlternative: identifier?attribute-specifier*':'constant-expressionbrace-or-equal-initializer?
            enterElement: identifier?
              => element -> [identifier]
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: identifier?
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: ':'
              => element -> :
              enterAtom: ':'
                enterTerminal: ':'
                exitTerminal: ':'
              exitAtom: ':'
            exitElement: ':'
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
            enterElement: brace-or-equal-initializer?
              => element -> [brace-or-equal-initializer]
              enterAtom: brace-or-equal-initializer
                enterRuleref: brace-or-equal-initializer
                exitRuleref: brace-or-equal-initializer
              exitAtom: brace-or-equal-initializer
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: brace-or-equal-initializer?
          exitAlternative: identifier?attribute-specifier*':'constant-expressionbrace-or-equal-initializer?
        => elements -> ['[identifier]', '[attribute-specifier]...', ':', '{constant-expression}', '[brace-or-equal-initializer]']
            => alternative -> [identifier] [attribute-specifier]... : {constant-expression} [brace-or-equal-initializer]
        exitLabeledAlt: identifier?attribute-specifier*':'constant-expressionbrace-or-equal-initializer?
      exitRuleAltList: declaratorvirt-specifier-seq?pure-specifier?|declaratorrequires-clause|declaratorbrace-or-equal-initializer?|identifier?attribute-specifier*':'constant-expressionbrace-or-equal-initializer?
    exitRuleBlock: declaratorvirt-specifier-seq?pure-specifier?|declaratorrequires-clause|declaratorbrace-or-equal-initializer?|identifier?attribute-specifier*':'constant-expressionbrace-or-equal-initializer?
  exitRuleSpec: member-declarator:declaratorvirt-specifier-seq?pure-specifier?|declaratorrequires-clause|declaratorbrace-or-equal-initializer?|identifier?attribute-specifier*':'constant-expressionbrace-or-equal-initializer?;

  enterRuleSpec: virt-specifier-seq:virt-specifier|virt-specifier-seqvirt-specifier;
    enterRuleBlock: virt-specifier|virt-specifier-seqvirt-specifier
      enterRuleAltList: virt-specifier|virt-specifier-seqvirt-specifier
        enterLabeledAlt: virt-specifier
          enterAlternative: virt-specifier
            enterElement: virt-specifier
              => element -> {virt-specifier}
              enterAtom: virt-specifier
                enterRuleref: virt-specifier
                exitRuleref: virt-specifier
              exitAtom: virt-specifier
            exitElement: virt-specifier
          exitAlternative: virt-specifier
        => elements -> ['{virt-specifier}']
            => alternative -> {virt-specifier}
        exitLabeledAlt: virt-specifier
        enterLabeledAlt: virt-specifier-seqvirt-specifier
          enterAlternative: virt-specifier-seqvirt-specifier
            enterElement: virt-specifier-seq
              => element -> {virt-specifier-seq}
              enterAtom: virt-specifier-seq
                enterRuleref: virt-specifier-seq
                exitRuleref: virt-specifier-seq
              exitAtom: virt-specifier-seq
            exitElement: virt-specifier-seq
            enterElement: virt-specifier
              => element -> {virt-specifier}
              enterAtom: virt-specifier
                enterRuleref: virt-specifier
                exitRuleref: virt-specifier
              exitAtom: virt-specifier
            exitElement: virt-specifier
          exitAlternative: virt-specifier-seqvirt-specifier
        => elements -> ['{virt-specifier-seq}', '{virt-specifier}']
            => alternative -> {virt-specifier-seq} {virt-specifier}
        exitLabeledAlt: virt-specifier-seqvirt-specifier
      exitRuleAltList: virt-specifier|virt-specifier-seqvirt-specifier
    exitRuleBlock: virt-specifier|virt-specifier-seqvirt-specifier
  exitRuleSpec: virt-specifier-seq:virt-specifier|virt-specifier-seqvirt-specifier;

  enterRuleSpec: virt-specifier:'override'|'final';
    enterRuleBlock: 'override'|'final'
      enterRuleAltList: 'override'|'final'
        enterLabeledAlt: 'override'
          enterAlternative: 'override'
            enterElement: 'override'
              => element -> override
              enterAtom: 'override'
                enterTerminal: 'override'
                exitTerminal: 'override'
              exitAtom: 'override'
            exitElement: 'override'
          exitAlternative: 'override'
        => elements -> ['override']
            => alternative -> override
        exitLabeledAlt: 'override'
        enterLabeledAlt: 'final'
          enterAlternative: 'final'
            enterElement: 'final'
              => element -> final
              enterAtom: 'final'
                enterTerminal: 'final'
                exitTerminal: 'final'
              exitAtom: 'final'
            exitElement: 'final'
          exitAlternative: 'final'
        => elements -> ['final']
            => alternative -> final
        exitLabeledAlt: 'final'
      exitRuleAltList: 'override'|'final'
    exitRuleBlock: 'override'|'final'
  exitRuleSpec: virt-specifier:'override'|'final';

  enterRuleSpec: pure-specifier:'= 0';
    enterRuleBlock: '= 0'
      enterRuleAltList: '= 0'
        enterLabeledAlt: '= 0'
          enterAlternative: '= 0'
            enterElement: '= 0'
              => element -> = 0
              enterAtom: '= 0'
                enterTerminal: '= 0'
                exitTerminal: '= 0'
              exitAtom: '= 0'
            exitElement: '= 0'
          exitAlternative: '= 0'
        => elements -> ['= 0']
            => alternative -> = 0
        exitLabeledAlt: '= 0'
      exitRuleAltList: '= 0'
    exitRuleBlock: '= 0'
  exitRuleSpec: pure-specifier:'= 0';

  enterRuleSpec: conversion-function-id:'operator'conversion-type-id;
    enterRuleBlock: 'operator'conversion-type-id
      enterRuleAltList: 'operator'conversion-type-id
        enterLabeledAlt: 'operator'conversion-type-id
          enterAlternative: 'operator'conversion-type-id
            enterElement: 'operator'
              => element -> operator
              enterAtom: 'operator'
                enterTerminal: 'operator'
                exitTerminal: 'operator'
              exitAtom: 'operator'
            exitElement: 'operator'
            enterElement: conversion-type-id
              => element -> {conversion-type-id}
              enterAtom: conversion-type-id
                enterRuleref: conversion-type-id
                exitRuleref: conversion-type-id
              exitAtom: conversion-type-id
            exitElement: conversion-type-id
          exitAlternative: 'operator'conversion-type-id
        => elements -> ['operator', '{conversion-type-id}']
            => alternative -> operator {conversion-type-id}
        exitLabeledAlt: 'operator'conversion-type-id
      exitRuleAltList: 'operator'conversion-type-id
    exitRuleBlock: 'operator'conversion-type-id
  exitRuleSpec: conversion-function-id:'operator'conversion-type-id;

  enterRuleSpec: conversion-type-id:type-specifier-seqconversion-declarator?;
    enterRuleBlock: type-specifier-seqconversion-declarator?
      enterRuleAltList: type-specifier-seqconversion-declarator?
        enterLabeledAlt: type-specifier-seqconversion-declarator?
          enterAlternative: type-specifier-seqconversion-declarator?
            enterElement: type-specifier-seq
              => element -> {type-specifier-seq}
              enterAtom: type-specifier-seq
                enterRuleref: type-specifier-seq
                exitRuleref: type-specifier-seq
              exitAtom: type-specifier-seq
            exitElement: type-specifier-seq
            enterElement: conversion-declarator?
              => element -> [conversion-declarator]
              enterAtom: conversion-declarator
                enterRuleref: conversion-declarator
                exitRuleref: conversion-declarator
              exitAtom: conversion-declarator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: conversion-declarator?
          exitAlternative: type-specifier-seqconversion-declarator?
        => elements -> ['{type-specifier-seq}', '[conversion-declarator]']
            => alternative -> {type-specifier-seq} [conversion-declarator]
        exitLabeledAlt: type-specifier-seqconversion-declarator?
      exitRuleAltList: type-specifier-seqconversion-declarator?
    exitRuleBlock: type-specifier-seqconversion-declarator?
  exitRuleSpec: conversion-type-id:type-specifier-seqconversion-declarator?;

  enterRuleSpec: conversion-declarator:ptr-operatorconversion-declarator?;
    enterRuleBlock: ptr-operatorconversion-declarator?
      enterRuleAltList: ptr-operatorconversion-declarator?
        enterLabeledAlt: ptr-operatorconversion-declarator?
          enterAlternative: ptr-operatorconversion-declarator?
            enterElement: ptr-operator
              => element -> {ptr-operator}
              enterAtom: ptr-operator
                enterRuleref: ptr-operator
                exitRuleref: ptr-operator
              exitAtom: ptr-operator
            exitElement: ptr-operator
            enterElement: conversion-declarator?
              => element -> [conversion-declarator]
              enterAtom: conversion-declarator
                enterRuleref: conversion-declarator
                exitRuleref: conversion-declarator
              exitAtom: conversion-declarator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: conversion-declarator?
          exitAlternative: ptr-operatorconversion-declarator?
        => elements -> ['{ptr-operator}', '[conversion-declarator]']
            => alternative -> {ptr-operator} [conversion-declarator]
        exitLabeledAlt: ptr-operatorconversion-declarator?
      exitRuleAltList: ptr-operatorconversion-declarator?
    exitRuleBlock: ptr-operatorconversion-declarator?
  exitRuleSpec: conversion-declarator:ptr-operatorconversion-declarator?;

  enterRuleSpec: base-clause:':'base-specifier-list;
    enterRuleBlock: ':'base-specifier-list
      enterRuleAltList: ':'base-specifier-list
        enterLabeledAlt: ':'base-specifier-list
          enterAlternative: ':'base-specifier-list
            enterElement: ':'
              => element -> :
              enterAtom: ':'
                enterTerminal: ':'
                exitTerminal: ':'
              exitAtom: ':'
            exitElement: ':'
            enterElement: base-specifier-list
              => element -> {base-specifier-list}
              enterAtom: base-specifier-list
                enterRuleref: base-specifier-list
                exitRuleref: base-specifier-list
              exitAtom: base-specifier-list
            exitElement: base-specifier-list
          exitAlternative: ':'base-specifier-list
        => elements -> [':', '{base-specifier-list}']
            => alternative -> : {base-specifier-list}
        exitLabeledAlt: ':'base-specifier-list
      exitRuleAltList: ':'base-specifier-list
    exitRuleBlock: ':'base-specifier-list
  exitRuleSpec: base-clause:':'base-specifier-list;

  enterRuleSpec: base-specifier-list:base-specifierthree-dots?|base-specifier-list','base-specifierthree-dots?;
    enterRuleBlock: base-specifierthree-dots?|base-specifier-list','base-specifierthree-dots?
      enterRuleAltList: base-specifierthree-dots?|base-specifier-list','base-specifierthree-dots?
        enterLabeledAlt: base-specifierthree-dots?
          enterAlternative: base-specifierthree-dots?
            enterElement: base-specifier
              => element -> {base-specifier}
              enterAtom: base-specifier
                enterRuleref: base-specifier
                exitRuleref: base-specifier
              exitAtom: base-specifier
            exitElement: base-specifier
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
          exitAlternative: base-specifierthree-dots?
        => elements -> ['{base-specifier}', '[three-dots]']
            => alternative -> {base-specifier} [three-dots]
        exitLabeledAlt: base-specifierthree-dots?
        enterLabeledAlt: base-specifier-list','base-specifierthree-dots?
          enterAlternative: base-specifier-list','base-specifierthree-dots?
            enterElement: base-specifier-list
              => element -> {base-specifier-list}
              enterAtom: base-specifier-list
                enterRuleref: base-specifier-list
                exitRuleref: base-specifier-list
              exitAtom: base-specifier-list
            exitElement: base-specifier-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: base-specifier
              => element -> {base-specifier}
              enterAtom: base-specifier
                enterRuleref: base-specifier
                exitRuleref: base-specifier
              exitAtom: base-specifier
            exitElement: base-specifier
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
          exitAlternative: base-specifier-list','base-specifierthree-dots?
        => elements -> ['{base-specifier-list}', ',', '{base-specifier}', '[three-dots]']
            => alternative -> {base-specifier-list} , {base-specifier} [three-dots]
        exitLabeledAlt: base-specifier-list','base-specifierthree-dots?
      exitRuleAltList: base-specifierthree-dots?|base-specifier-list','base-specifierthree-dots?
    exitRuleBlock: base-specifierthree-dots?|base-specifier-list','base-specifierthree-dots?
  exitRuleSpec: base-specifier-list:base-specifierthree-dots?|base-specifier-list','base-specifierthree-dots?;

  enterRuleSpec: virtual:'virtual';
    enterRuleBlock: 'virtual'
      enterRuleAltList: 'virtual'
        enterLabeledAlt: 'virtual'
          enterAlternative: 'virtual'
            enterElement: 'virtual'
              => element -> virtual
              enterAtom: 'virtual'
                enterTerminal: 'virtual'
                exitTerminal: 'virtual'
              exitAtom: 'virtual'
            exitElement: 'virtual'
          exitAlternative: 'virtual'
        => elements -> ['virtual']
            => alternative -> virtual
        exitLabeledAlt: 'virtual'
      exitRuleAltList: 'virtual'
    exitRuleBlock: 'virtual'
  exitRuleSpec: virtual:'virtual';

  enterRuleSpec: base-specifier:attribute-specifier*class-or-decltype|attribute-specifier*'virtual'access-specifier?class-or-decltype|attribute-specifier*access-specifiervirtual?class-or-decltype;
    enterRuleBlock: attribute-specifier*class-or-decltype|attribute-specifier*'virtual'access-specifier?class-or-decltype|attribute-specifier*access-specifiervirtual?class-or-decltype
      enterRuleAltList: attribute-specifier*class-or-decltype|attribute-specifier*'virtual'access-specifier?class-or-decltype|attribute-specifier*access-specifiervirtual?class-or-decltype
        enterLabeledAlt: attribute-specifier*class-or-decltype
          enterAlternative: attribute-specifier*class-or-decltype
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: class-or-decltype
              => element -> {class-or-decltype}
              enterAtom: class-or-decltype
                enterRuleref: class-or-decltype
                exitRuleref: class-or-decltype
              exitAtom: class-or-decltype
            exitElement: class-or-decltype
          exitAlternative: attribute-specifier*class-or-decltype
        => elements -> ['[attribute-specifier]...', '{class-or-decltype}']
            => alternative -> [attribute-specifier]... {class-or-decltype}
        exitLabeledAlt: attribute-specifier*class-or-decltype
        enterLabeledAlt: attribute-specifier*'virtual'access-specifier?class-or-decltype
          enterAlternative: attribute-specifier*'virtual'access-specifier?class-or-decltype
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: 'virtual'
              => element -> virtual
              enterAtom: 'virtual'
                enterTerminal: 'virtual'
                exitTerminal: 'virtual'
              exitAtom: 'virtual'
            exitElement: 'virtual'
            enterElement: access-specifier?
              => element -> [access-specifier]
              enterAtom: access-specifier
                enterRuleref: access-specifier
                exitRuleref: access-specifier
              exitAtom: access-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: access-specifier?
            enterElement: class-or-decltype
              => element -> {class-or-decltype}
              enterAtom: class-or-decltype
                enterRuleref: class-or-decltype
                exitRuleref: class-or-decltype
              exitAtom: class-or-decltype
            exitElement: class-or-decltype
          exitAlternative: attribute-specifier*'virtual'access-specifier?class-or-decltype
        => elements -> ['[attribute-specifier]...', 'virtual', '[access-specifier]', '{class-or-decltype}']
            => alternative -> [attribute-specifier]... virtual [access-specifier] {class-or-decltype}
        exitLabeledAlt: attribute-specifier*'virtual'access-specifier?class-or-decltype
        enterLabeledAlt: attribute-specifier*access-specifiervirtual?class-or-decltype
          enterAlternative: attribute-specifier*access-specifiervirtual?class-or-decltype
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: access-specifier
              => element -> {access-specifier}
              enterAtom: access-specifier
                enterRuleref: access-specifier
                exitRuleref: access-specifier
              exitAtom: access-specifier
            exitElement: access-specifier
            enterElement: virtual?
              => element -> [virtual]
              enterAtom: virtual
                enterRuleref: virtual
                exitRuleref: virtual
              exitAtom: virtual
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: virtual?
            enterElement: class-or-decltype
              => element -> {class-or-decltype}
              enterAtom: class-or-decltype
                enterRuleref: class-or-decltype
                exitRuleref: class-or-decltype
              exitAtom: class-or-decltype
            exitElement: class-or-decltype
          exitAlternative: attribute-specifier*access-specifiervirtual?class-or-decltype
        => elements -> ['[attribute-specifier]...', '{access-specifier}', '[virtual]', '{class-or-decltype}']
            => alternative -> [attribute-specifier]... {access-specifier} [virtual] {class-or-decltype}
        exitLabeledAlt: attribute-specifier*access-specifiervirtual?class-or-decltype
      exitRuleAltList: attribute-specifier*class-or-decltype|attribute-specifier*'virtual'access-specifier?class-or-decltype|attribute-specifier*access-specifiervirtual?class-or-decltype
    exitRuleBlock: attribute-specifier*class-or-decltype|attribute-specifier*'virtual'access-specifier?class-or-decltype|attribute-specifier*access-specifiervirtual?class-or-decltype
  exitRuleSpec: base-specifier:attribute-specifier*class-or-decltype|attribute-specifier*'virtual'access-specifier?class-or-decltype|attribute-specifier*access-specifiervirtual?class-or-decltype;

  enterRuleSpec: class-or-decltype:nested-name-specifier?type-name|nested-name-specifier'template'simple-template-id|decltype-specifier;
    enterRuleBlock: nested-name-specifier?type-name|nested-name-specifier'template'simple-template-id|decltype-specifier
      enterRuleAltList: nested-name-specifier?type-name|nested-name-specifier'template'simple-template-id|decltype-specifier
        enterLabeledAlt: nested-name-specifier?type-name
          enterAlternative: nested-name-specifier?type-name
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: type-name
              => element -> {type-name}
              enterAtom: type-name
                enterRuleref: type-name
                exitRuleref: type-name
              exitAtom: type-name
            exitElement: type-name
          exitAlternative: nested-name-specifier?type-name
        => elements -> ['[nested-name-specifier]', '{type-name}']
            => alternative -> [nested-name-specifier] {type-name}
        exitLabeledAlt: nested-name-specifier?type-name
        enterLabeledAlt: nested-name-specifier'template'simple-template-id
          enterAlternative: nested-name-specifier'template'simple-template-id
            enterElement: nested-name-specifier
              => element -> {nested-name-specifier}
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
            exitElement: nested-name-specifier
            enterElement: 'template'
              => element -> template
              enterAtom: 'template'
                enterTerminal: 'template'
                exitTerminal: 'template'
              exitAtom: 'template'
            exitElement: 'template'
            enterElement: simple-template-id
              => element -> {simple-template-id}
              enterAtom: simple-template-id
                enterRuleref: simple-template-id
                exitRuleref: simple-template-id
              exitAtom: simple-template-id
            exitElement: simple-template-id
          exitAlternative: nested-name-specifier'template'simple-template-id
        => elements -> ['{nested-name-specifier}', 'template', '{simple-template-id}']
            => alternative -> {nested-name-specifier} template {simple-template-id}
        exitLabeledAlt: nested-name-specifier'template'simple-template-id
        enterLabeledAlt: decltype-specifier
          enterAlternative: decltype-specifier
            enterElement: decltype-specifier
              => element -> {decltype-specifier}
              enterAtom: decltype-specifier
                enterRuleref: decltype-specifier
                exitRuleref: decltype-specifier
              exitAtom: decltype-specifier
            exitElement: decltype-specifier
          exitAlternative: decltype-specifier
        => elements -> ['{decltype-specifier}']
            => alternative -> {decltype-specifier}
        exitLabeledAlt: decltype-specifier
      exitRuleAltList: nested-name-specifier?type-name|nested-name-specifier'template'simple-template-id|decltype-specifier
    exitRuleBlock: nested-name-specifier?type-name|nested-name-specifier'template'simple-template-id|decltype-specifier
  exitRuleSpec: class-or-decltype:nested-name-specifier?type-name|nested-name-specifier'template'simple-template-id|decltype-specifier;

  enterRuleSpec: access-specifier:'private'|'protected'|'public';
    enterRuleBlock: 'private'|'protected'|'public'
      enterRuleAltList: 'private'|'protected'|'public'
        enterLabeledAlt: 'private'
          enterAlternative: 'private'
            enterElement: 'private'
              => element -> private
              enterAtom: 'private'
                enterTerminal: 'private'
                exitTerminal: 'private'
              exitAtom: 'private'
            exitElement: 'private'
          exitAlternative: 'private'
        => elements -> ['private']
            => alternative -> private
        exitLabeledAlt: 'private'
        enterLabeledAlt: 'protected'
          enterAlternative: 'protected'
            enterElement: 'protected'
              => element -> protected
              enterAtom: 'protected'
                enterTerminal: 'protected'
                exitTerminal: 'protected'
              exitAtom: 'protected'
            exitElement: 'protected'
          exitAlternative: 'protected'
        => elements -> ['protected']
            => alternative -> protected
        exitLabeledAlt: 'protected'
        enterLabeledAlt: 'public'
          enterAlternative: 'public'
            enterElement: 'public'
              => element -> public
              enterAtom: 'public'
                enterTerminal: 'public'
                exitTerminal: 'public'
              exitAtom: 'public'
            exitElement: 'public'
          exitAlternative: 'public'
        => elements -> ['public']
            => alternative -> public
        exitLabeledAlt: 'public'
      exitRuleAltList: 'private'|'protected'|'public'
    exitRuleBlock: 'private'|'protected'|'public'
  exitRuleSpec: access-specifier:'private'|'protected'|'public';

  enterRuleSpec: ctor-initializer:':'mem-initializer-list;
    enterRuleBlock: ':'mem-initializer-list
      enterRuleAltList: ':'mem-initializer-list
        enterLabeledAlt: ':'mem-initializer-list
          enterAlternative: ':'mem-initializer-list
            enterElement: ':'
              => element -> :
              enterAtom: ':'
                enterTerminal: ':'
                exitTerminal: ':'
              exitAtom: ':'
            exitElement: ':'
            enterElement: mem-initializer-list
              => element -> {mem-initializer-list}
              enterAtom: mem-initializer-list
                enterRuleref: mem-initializer-list
                exitRuleref: mem-initializer-list
              exitAtom: mem-initializer-list
            exitElement: mem-initializer-list
          exitAlternative: ':'mem-initializer-list
        => elements -> [':', '{mem-initializer-list}']
            => alternative -> : {mem-initializer-list}
        exitLabeledAlt: ':'mem-initializer-list
      exitRuleAltList: ':'mem-initializer-list
    exitRuleBlock: ':'mem-initializer-list
  exitRuleSpec: ctor-initializer:':'mem-initializer-list;

  enterRuleSpec: mem-initializer-list:mem-initializerthree-dots?|mem-initializer-list','mem-initializerthree-dots?;
    enterRuleBlock: mem-initializerthree-dots?|mem-initializer-list','mem-initializerthree-dots?
      enterRuleAltList: mem-initializerthree-dots?|mem-initializer-list','mem-initializerthree-dots?
        enterLabeledAlt: mem-initializerthree-dots?
          enterAlternative: mem-initializerthree-dots?
            enterElement: mem-initializer
              => element -> {mem-initializer}
              enterAtom: mem-initializer
                enterRuleref: mem-initializer
                exitRuleref: mem-initializer
              exitAtom: mem-initializer
            exitElement: mem-initializer
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
          exitAlternative: mem-initializerthree-dots?
        => elements -> ['{mem-initializer}', '[three-dots]']
            => alternative -> {mem-initializer} [three-dots]
        exitLabeledAlt: mem-initializerthree-dots?
        enterLabeledAlt: mem-initializer-list','mem-initializerthree-dots?
          enterAlternative: mem-initializer-list','mem-initializerthree-dots?
            enterElement: mem-initializer-list
              => element -> {mem-initializer-list}
              enterAtom: mem-initializer-list
                enterRuleref: mem-initializer-list
                exitRuleref: mem-initializer-list
              exitAtom: mem-initializer-list
            exitElement: mem-initializer-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: mem-initializer
              => element -> {mem-initializer}
              enterAtom: mem-initializer
                enterRuleref: mem-initializer
                exitRuleref: mem-initializer
              exitAtom: mem-initializer
            exitElement: mem-initializer
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
          exitAlternative: mem-initializer-list','mem-initializerthree-dots?
        => elements -> ['{mem-initializer-list}', ',', '{mem-initializer}', '[three-dots]']
            => alternative -> {mem-initializer-list} , {mem-initializer} [three-dots]
        exitLabeledAlt: mem-initializer-list','mem-initializerthree-dots?
      exitRuleAltList: mem-initializerthree-dots?|mem-initializer-list','mem-initializerthree-dots?
    exitRuleBlock: mem-initializerthree-dots?|mem-initializer-list','mem-initializerthree-dots?
  exitRuleSpec: mem-initializer-list:mem-initializerthree-dots?|mem-initializer-list','mem-initializerthree-dots?;

  enterRuleSpec: mem-initializer:mem-initializer-id'('expression-list?')'|mem-initializer-idbraced-init-list;
    enterRuleBlock: mem-initializer-id'('expression-list?')'|mem-initializer-idbraced-init-list
      enterRuleAltList: mem-initializer-id'('expression-list?')'|mem-initializer-idbraced-init-list
        enterLabeledAlt: mem-initializer-id'('expression-list?')'
          enterAlternative: mem-initializer-id'('expression-list?')'
            enterElement: mem-initializer-id
              => element -> {mem-initializer-id}
              enterAtom: mem-initializer-id
                enterRuleref: mem-initializer-id
                exitRuleref: mem-initializer-id
              exitAtom: mem-initializer-id
            exitElement: mem-initializer-id
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: expression-list?
              => element -> [expression-list]
              enterAtom: expression-list
                enterRuleref: expression-list
                exitRuleref: expression-list
              exitAtom: expression-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: expression-list?
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: mem-initializer-id'('expression-list?')'
        => elements -> ['{mem-initializer-id}', '(', '[expression-list]', ')']
            => alternative -> {mem-initializer-id} ( [expression-list] )
        exitLabeledAlt: mem-initializer-id'('expression-list?')'
        enterLabeledAlt: mem-initializer-idbraced-init-list
          enterAlternative: mem-initializer-idbraced-init-list
            enterElement: mem-initializer-id
              => element -> {mem-initializer-id}
              enterAtom: mem-initializer-id
                enterRuleref: mem-initializer-id
                exitRuleref: mem-initializer-id
              exitAtom: mem-initializer-id
            exitElement: mem-initializer-id
            enterElement: braced-init-list
              => element -> {braced-init-list}
              enterAtom: braced-init-list
                enterRuleref: braced-init-list
                exitRuleref: braced-init-list
              exitAtom: braced-init-list
            exitElement: braced-init-list
          exitAlternative: mem-initializer-idbraced-init-list
        => elements -> ['{mem-initializer-id}', '{braced-init-list}']
            => alternative -> {mem-initializer-id} {braced-init-list}
        exitLabeledAlt: mem-initializer-idbraced-init-list
      exitRuleAltList: mem-initializer-id'('expression-list?')'|mem-initializer-idbraced-init-list
    exitRuleBlock: mem-initializer-id'('expression-list?')'|mem-initializer-idbraced-init-list
  exitRuleSpec: mem-initializer:mem-initializer-id'('expression-list?')'|mem-initializer-idbraced-init-list;

  enterRuleSpec: mem-initializer-id:class-or-decltype|identifier;
    enterRuleBlock: class-or-decltype|identifier
      enterRuleAltList: class-or-decltype|identifier
        enterLabeledAlt: class-or-decltype
          enterAlternative: class-or-decltype
            enterElement: class-or-decltype
              => element -> {class-or-decltype}
              enterAtom: class-or-decltype
                enterRuleref: class-or-decltype
                exitRuleref: class-or-decltype
              exitAtom: class-or-decltype
            exitElement: class-or-decltype
          exitAlternative: class-or-decltype
        => elements -> ['{class-or-decltype}']
            => alternative -> {class-or-decltype}
        exitLabeledAlt: class-or-decltype
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
      exitRuleAltList: class-or-decltype|identifier
    exitRuleBlock: class-or-decltype|identifier
  exitRuleSpec: mem-initializer-id:class-or-decltype|identifier;

  enterRuleSpec: operator-function-id:'operator'operator;
    enterRuleBlock: 'operator'operator
      enterRuleAltList: 'operator'operator
        enterLabeledAlt: 'operator'operator
          enterAlternative: 'operator'operator
            enterElement: 'operator'
              => element -> operator
              enterAtom: 'operator'
                enterTerminal: 'operator'
                exitTerminal: 'operator'
              exitAtom: 'operator'
            exitElement: 'operator'
            enterElement: operator
              => element -> {operator}
              enterAtom: operator
                enterRuleref: operator
                exitRuleref: operator
              exitAtom: operator
            exitElement: operator
          exitAlternative: 'operator'operator
        => elements -> ['operator', '{operator}']
            => alternative -> operator {operator}
        exitLabeledAlt: 'operator'operator
      exitRuleAltList: 'operator'operator
    exitRuleBlock: 'operator'operator
  exitRuleSpec: operator-function-id:'operator'operator;

  enterRuleSpec: operator:'new'|'delete'|'new[]'|'delete[]'|'co_await'|'()'|'[]'|'->'|'->*'|'~'|'!'|'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'='|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'=='|'!='|'<'|'>'|'<='|'>='|'<=>'|'&&'|'||'|'<<'|'>>'|'<<='|'>>='|'++'|'--'|',';
    enterRuleBlock: 'new'|'delete'|'new[]'|'delete[]'|'co_await'|'()'|'[]'|'->'|'->*'|'~'|'!'|'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'='|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'=='|'!='|'<'|'>'|'<='|'>='|'<=>'|'&&'|'||'|'<<'|'>>'|'<<='|'>>='|'++'|'--'|','
      enterRuleAltList: 'new'|'delete'|'new[]'|'delete[]'|'co_await'|'()'|'[]'|'->'|'->*'|'~'|'!'|'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'='|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'=='|'!='|'<'|'>'|'<='|'>='|'<=>'|'&&'|'||'|'<<'|'>>'|'<<='|'>>='|'++'|'--'|','
        enterLabeledAlt: 'new'
          enterAlternative: 'new'
            enterElement: 'new'
              => element -> new
              enterAtom: 'new'
                enterTerminal: 'new'
                exitTerminal: 'new'
              exitAtom: 'new'
            exitElement: 'new'
          exitAlternative: 'new'
        => elements -> ['new']
            => alternative -> new
        exitLabeledAlt: 'new'
        enterLabeledAlt: 'delete'
          enterAlternative: 'delete'
            enterElement: 'delete'
              => element -> delete
              enterAtom: 'delete'
                enterTerminal: 'delete'
                exitTerminal: 'delete'
              exitAtom: 'delete'
            exitElement: 'delete'
          exitAlternative: 'delete'
        => elements -> ['delete']
            => alternative -> delete
        exitLabeledAlt: 'delete'
        enterLabeledAlt: 'new[]'
          enterAlternative: 'new[]'
            enterElement: 'new[]'
              => element -> new[]
              enterAtom: 'new[]'
                enterTerminal: 'new[]'
                exitTerminal: 'new[]'
              exitAtom: 'new[]'
            exitElement: 'new[]'
          exitAlternative: 'new[]'
        => elements -> ['new[]']
            => alternative -> new[]
        exitLabeledAlt: 'new[]'
        enterLabeledAlt: 'delete[]'
          enterAlternative: 'delete[]'
            enterElement: 'delete[]'
              => element -> delete[]
              enterAtom: 'delete[]'
                enterTerminal: 'delete[]'
                exitTerminal: 'delete[]'
              exitAtom: 'delete[]'
            exitElement: 'delete[]'
          exitAlternative: 'delete[]'
        => elements -> ['delete[]']
            => alternative -> delete[]
        exitLabeledAlt: 'delete[]'
        enterLabeledAlt: 'co_await'
          enterAlternative: 'co_await'
            enterElement: 'co_await'
              => element -> co_await
              enterAtom: 'co_await'
                enterTerminal: 'co_await'
                exitTerminal: 'co_await'
              exitAtom: 'co_await'
            exitElement: 'co_await'
          exitAlternative: 'co_await'
        => elements -> ['co_await']
            => alternative -> co_await
        exitLabeledAlt: 'co_await'
        enterLabeledAlt: '()'
          enterAlternative: '()'
            enterElement: '()'
              => element -> ()
              enterAtom: '()'
                enterTerminal: '()'
                exitTerminal: '()'
              exitAtom: '()'
            exitElement: '()'
          exitAlternative: '()'
        => elements -> ['()']
            => alternative -> ()
        exitLabeledAlt: '()'
        enterLabeledAlt: '[]'
          enterAlternative: '[]'
            enterElement: '[]'
              => element -> []
              enterAtom: '[]'
                enterTerminal: '[]'
                exitTerminal: '[]'
              exitAtom: '[]'
            exitElement: '[]'
          exitAlternative: '[]'
        => elements -> ['[]']
            => alternative -> []
        exitLabeledAlt: '[]'
        enterLabeledAlt: '->'
          enterAlternative: '->'
            enterElement: '->'
              => element -> ->
              enterAtom: '->'
                enterTerminal: '->'
                exitTerminal: '->'
              exitAtom: '->'
            exitElement: '->'
          exitAlternative: '->'
        => elements -> ['->']
            => alternative -> ->
        exitLabeledAlt: '->'
        enterLabeledAlt: '->*'
          enterAlternative: '->*'
            enterElement: '->*'
              => element -> ->*
              enterAtom: '->*'
                enterTerminal: '->*'
                exitTerminal: '->*'
              exitAtom: '->*'
            exitElement: '->*'
          exitAlternative: '->*'
        => elements -> ['->*']
            => alternative -> ->*
        exitLabeledAlt: '->*'
        enterLabeledAlt: '~'
          enterAlternative: '~'
            enterElement: '~'
              => element -> ~
              enterAtom: '~'
                enterTerminal: '~'
                exitTerminal: '~'
              exitAtom: '~'
            exitElement: '~'
          exitAlternative: '~'
        => elements -> ['~']
            => alternative -> ~
        exitLabeledAlt: '~'
        enterLabeledAlt: '!'
          enterAlternative: '!'
            enterElement: '!'
              => element -> !
              enterAtom: '!'
                enterTerminal: '!'
                exitTerminal: '!'
              exitAtom: '!'
            exitElement: '!'
          exitAlternative: '!'
        => elements -> ['!']
            => alternative -> !
        exitLabeledAlt: '!'
        enterLabeledAlt: '+'
          enterAlternative: '+'
            enterElement: '+'
              => element -> +
              enterAtom: '+'
                enterTerminal: '+'
                exitTerminal: '+'
              exitAtom: '+'
            exitElement: '+'
          exitAlternative: '+'
        => elements -> ['+']
            => alternative -> +
        exitLabeledAlt: '+'
        enterLabeledAlt: '-'
          enterAlternative: '-'
            enterElement: '-'
              => element -> -
              enterAtom: '-'
                enterTerminal: '-'
                exitTerminal: '-'
              exitAtom: '-'
            exitElement: '-'
          exitAlternative: '-'
        => elements -> ['-']
            => alternative -> -
        exitLabeledAlt: '-'
        enterLabeledAlt: '*'
          enterAlternative: '*'
            enterElement: '*'
              => element -> *
              enterAtom: '*'
                enterTerminal: '*'
                exitTerminal: '*'
              exitAtom: '*'
            exitElement: '*'
          exitAlternative: '*'
        => elements -> ['*']
            => alternative -> *
        exitLabeledAlt: '*'
        enterLabeledAlt: '/'
          enterAlternative: '/'
            enterElement: '/'
              => element -> /
              enterAtom: '/'
                enterTerminal: '/'
                exitTerminal: '/'
              exitAtom: '/'
            exitElement: '/'
          exitAlternative: '/'
        => elements -> ['/']
            => alternative -> /
        exitLabeledAlt: '/'
        enterLabeledAlt: '%'
          enterAlternative: '%'
            enterElement: '%'
              => element -> %
              enterAtom: '%'
                enterTerminal: '%'
                exitTerminal: '%'
              exitAtom: '%'
            exitElement: '%'
          exitAlternative: '%'
        => elements -> ['%']
            => alternative -> %
        exitLabeledAlt: '%'
        enterLabeledAlt: '^'
          enterAlternative: '^'
            enterElement: '^'
              => element -> ^
              enterAtom: '^'
                enterTerminal: '^'
                exitTerminal: '^'
              exitAtom: '^'
            exitElement: '^'
          exitAlternative: '^'
        => elements -> ['^']
            => alternative -> ^
        exitLabeledAlt: '^'
        enterLabeledAlt: '&'
          enterAlternative: '&'
            enterElement: '&'
              => element -> &
              enterAtom: '&'
                enterTerminal: '&'
                exitTerminal: '&'
              exitAtom: '&'
            exitElement: '&'
          exitAlternative: '&'
        => elements -> ['&']
            => alternative -> &
        exitLabeledAlt: '&'
        enterLabeledAlt: '|'
          enterAlternative: '|'
            enterElement: '|'
              => element -> |
              enterAtom: '|'
                enterTerminal: '|'
                exitTerminal: '|'
              exitAtom: '|'
            exitElement: '|'
          exitAlternative: '|'
        => elements -> ['|']
            => alternative -> |
        exitLabeledAlt: '|'
        enterLabeledAlt: '='
          enterAlternative: '='
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
          exitAlternative: '='
        => elements -> ['=']
            => alternative -> =
        exitLabeledAlt: '='
        enterLabeledAlt: '+='
          enterAlternative: '+='
            enterElement: '+='
              => element -> +=
              enterAtom: '+='
                enterTerminal: '+='
                exitTerminal: '+='
              exitAtom: '+='
            exitElement: '+='
          exitAlternative: '+='
        => elements -> ['+=']
            => alternative -> +=
        exitLabeledAlt: '+='
        enterLabeledAlt: '-='
          enterAlternative: '-='
            enterElement: '-='
              => element -> -=
              enterAtom: '-='
                enterTerminal: '-='
                exitTerminal: '-='
              exitAtom: '-='
            exitElement: '-='
          exitAlternative: '-='
        => elements -> ['-=']
            => alternative -> -=
        exitLabeledAlt: '-='
        enterLabeledAlt: '*='
          enterAlternative: '*='
            enterElement: '*='
              => element -> *=
              enterAtom: '*='
                enterTerminal: '*='
                exitTerminal: '*='
              exitAtom: '*='
            exitElement: '*='
          exitAlternative: '*='
        => elements -> ['*=']
            => alternative -> *=
        exitLabeledAlt: '*='
        enterLabeledAlt: '/='
          enterAlternative: '/='
            enterElement: '/='
              => element -> /=
              enterAtom: '/='
                enterTerminal: '/='
                exitTerminal: '/='
              exitAtom: '/='
            exitElement: '/='
          exitAlternative: '/='
        => elements -> ['/=']
            => alternative -> /=
        exitLabeledAlt: '/='
        enterLabeledAlt: '%='
          enterAlternative: '%='
            enterElement: '%='
              => element -> %=
              enterAtom: '%='
                enterTerminal: '%='
                exitTerminal: '%='
              exitAtom: '%='
            exitElement: '%='
          exitAlternative: '%='
        => elements -> ['%=']
            => alternative -> %=
        exitLabeledAlt: '%='
        enterLabeledAlt: '^='
          enterAlternative: '^='
            enterElement: '^='
              => element -> ^=
              enterAtom: '^='
                enterTerminal: '^='
                exitTerminal: '^='
              exitAtom: '^='
            exitElement: '^='
          exitAlternative: '^='
        => elements -> ['^=']
            => alternative -> ^=
        exitLabeledAlt: '^='
        enterLabeledAlt: '&='
          enterAlternative: '&='
            enterElement: '&='
              => element -> &=
              enterAtom: '&='
                enterTerminal: '&='
                exitTerminal: '&='
              exitAtom: '&='
            exitElement: '&='
          exitAlternative: '&='
        => elements -> ['&=']
            => alternative -> &=
        exitLabeledAlt: '&='
        enterLabeledAlt: '|='
          enterAlternative: '|='
            enterElement: '|='
              => element -> |=
              enterAtom: '|='
                enterTerminal: '|='
                exitTerminal: '|='
              exitAtom: '|='
            exitElement: '|='
          exitAlternative: '|='
        => elements -> ['|=']
            => alternative -> |=
        exitLabeledAlt: '|='
        enterLabeledAlt: '=='
          enterAlternative: '=='
            enterElement: '=='
              => element -> ==
              enterAtom: '=='
                enterTerminal: '=='
                exitTerminal: '=='
              exitAtom: '=='
            exitElement: '=='
          exitAlternative: '=='
        => elements -> ['==']
            => alternative -> ==
        exitLabeledAlt: '=='
        enterLabeledAlt: '!='
          enterAlternative: '!='
            enterElement: '!='
              => element -> !=
              enterAtom: '!='
                enterTerminal: '!='
                exitTerminal: '!='
              exitAtom: '!='
            exitElement: '!='
          exitAlternative: '!='
        => elements -> ['!=']
            => alternative -> !=
        exitLabeledAlt: '!='
        enterLabeledAlt: '<'
          enterAlternative: '<'
            enterElement: '<'
              => element -> <
              enterAtom: '<'
                enterTerminal: '<'
                exitTerminal: '<'
              exitAtom: '<'
            exitElement: '<'
          exitAlternative: '<'
        => elements -> ['<']
            => alternative -> <
        exitLabeledAlt: '<'
        enterLabeledAlt: '>'
          enterAlternative: '>'
            enterElement: '>'
              => element -> >
              enterAtom: '>'
                enterTerminal: '>'
                exitTerminal: '>'
              exitAtom: '>'
            exitElement: '>'
          exitAlternative: '>'
        => elements -> ['>']
            => alternative -> >
        exitLabeledAlt: '>'
        enterLabeledAlt: '<='
          enterAlternative: '<='
            enterElement: '<='
              => element -> <=
              enterAtom: '<='
                enterTerminal: '<='
                exitTerminal: '<='
              exitAtom: '<='
            exitElement: '<='
          exitAlternative: '<='
        => elements -> ['<=']
            => alternative -> <=
        exitLabeledAlt: '<='
        enterLabeledAlt: '>='
          enterAlternative: '>='
            enterElement: '>='
              => element -> >=
              enterAtom: '>='
                enterTerminal: '>='
                exitTerminal: '>='
              exitAtom: '>='
            exitElement: '>='
          exitAlternative: '>='
        => elements -> ['>=']
            => alternative -> >=
        exitLabeledAlt: '>='
        enterLabeledAlt: '<=>'
          enterAlternative: '<=>'
            enterElement: '<=>'
              => element -> <=>
              enterAtom: '<=>'
                enterTerminal: '<=>'
                exitTerminal: '<=>'
              exitAtom: '<=>'
            exitElement: '<=>'
          exitAlternative: '<=>'
        => elements -> ['<=>']
            => alternative -> <=>
        exitLabeledAlt: '<=>'
        enterLabeledAlt: '&&'
          enterAlternative: '&&'
            enterElement: '&&'
              => element -> &&
              enterAtom: '&&'
                enterTerminal: '&&'
                exitTerminal: '&&'
              exitAtom: '&&'
            exitElement: '&&'
          exitAlternative: '&&'
        => elements -> ['&&']
            => alternative -> &&
        exitLabeledAlt: '&&'
        enterLabeledAlt: '||'
          enterAlternative: '||'
            enterElement: '||'
              => element -> ||
              enterAtom: '||'
                enterTerminal: '||'
                exitTerminal: '||'
              exitAtom: '||'
            exitElement: '||'
          exitAlternative: '||'
        => elements -> ['||']
            => alternative -> ||
        exitLabeledAlt: '||'
        enterLabeledAlt: '<<'
          enterAlternative: '<<'
            enterElement: '<<'
              => element -> <<
              enterAtom: '<<'
                enterTerminal: '<<'
                exitTerminal: '<<'
              exitAtom: '<<'
            exitElement: '<<'
          exitAlternative: '<<'
        => elements -> ['<<']
            => alternative -> <<
        exitLabeledAlt: '<<'
        enterLabeledAlt: '>>'
          enterAlternative: '>>'
            enterElement: '>>'
              => element -> >>
              enterAtom: '>>'
                enterTerminal: '>>'
                exitTerminal: '>>'
              exitAtom: '>>'
            exitElement: '>>'
          exitAlternative: '>>'
        => elements -> ['>>']
            => alternative -> >>
        exitLabeledAlt: '>>'
        enterLabeledAlt: '<<='
          enterAlternative: '<<='
            enterElement: '<<='
              => element -> <<=
              enterAtom: '<<='
                enterTerminal: '<<='
                exitTerminal: '<<='
              exitAtom: '<<='
            exitElement: '<<='
          exitAlternative: '<<='
        => elements -> ['<<=']
            => alternative -> <<=
        exitLabeledAlt: '<<='
        enterLabeledAlt: '>>='
          enterAlternative: '>>='
            enterElement: '>>='
              => element -> >>=
              enterAtom: '>>='
                enterTerminal: '>>='
                exitTerminal: '>>='
              exitAtom: '>>='
            exitElement: '>>='
          exitAlternative: '>>='
        => elements -> ['>>=']
            => alternative -> >>=
        exitLabeledAlt: '>>='
        enterLabeledAlt: '++'
          enterAlternative: '++'
            enterElement: '++'
              => element -> ++
              enterAtom: '++'
                enterTerminal: '++'
                exitTerminal: '++'
              exitAtom: '++'
            exitElement: '++'
          exitAlternative: '++'
        => elements -> ['++']
            => alternative -> ++
        exitLabeledAlt: '++'
        enterLabeledAlt: '--'
          enterAlternative: '--'
            enterElement: '--'
              => element -> --
              enterAtom: '--'
                enterTerminal: '--'
                exitTerminal: '--'
              exitAtom: '--'
            exitElement: '--'
          exitAlternative: '--'
        => elements -> ['--']
            => alternative -> --
        exitLabeledAlt: '--'
        enterLabeledAlt: ','
          enterAlternative: ','
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
          exitAlternative: ','
        => elements -> [',']
            => alternative -> ,
        exitLabeledAlt: ','
      exitRuleAltList: 'new'|'delete'|'new[]'|'delete[]'|'co_await'|'()'|'[]'|'->'|'->*'|'~'|'!'|'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'='|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'=='|'!='|'<'|'>'|'<='|'>='|'<=>'|'&&'|'||'|'<<'|'>>'|'<<='|'>>='|'++'|'--'|','
    exitRuleBlock: 'new'|'delete'|'new[]'|'delete[]'|'co_await'|'()'|'[]'|'->'|'->*'|'~'|'!'|'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'='|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'=='|'!='|'<'|'>'|'<='|'>='|'<=>'|'&&'|'||'|'<<'|'>>'|'<<='|'>>='|'++'|'--'|','
  exitRuleSpec: operator:'new'|'delete'|'new[]'|'delete[]'|'co_await'|'()'|'[]'|'->'|'->*'|'~'|'!'|'+'|'-'|'*'|'/'|'%'|'^'|'&'|'|'|'='|'+='|'-='|'*='|'/='|'%='|'^='|'&='|'|='|'=='|'!='|'<'|'>'|'<='|'>='|'<=>'|'&&'|'||'|'<<'|'>>'|'<<='|'>>='|'++'|'--'|',';

  enterRuleSpec: literal-operator-id:'operator'unevaluated-stringidentifier|'operator'user-defined-string-literal;
    enterRuleBlock: 'operator'unevaluated-stringidentifier|'operator'user-defined-string-literal
      enterRuleAltList: 'operator'unevaluated-stringidentifier|'operator'user-defined-string-literal
        enterLabeledAlt: 'operator'unevaluated-stringidentifier
          enterAlternative: 'operator'unevaluated-stringidentifier
            enterElement: 'operator'
              => element -> operator
              enterAtom: 'operator'
                enterTerminal: 'operator'
                exitTerminal: 'operator'
              exitAtom: 'operator'
            exitElement: 'operator'
            enterElement: unevaluated-string
              => element -> {unevaluated-string}
              enterAtom: unevaluated-string
                enterRuleref: unevaluated-string
                exitRuleref: unevaluated-string
              exitAtom: unevaluated-string
            exitElement: unevaluated-string
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: 'operator'unevaluated-stringidentifier
        => elements -> ['operator', '{unevaluated-string}', '{identifier}']
            => alternative -> operator {unevaluated-string} {identifier}
        exitLabeledAlt: 'operator'unevaluated-stringidentifier
        enterLabeledAlt: 'operator'user-defined-string-literal
          enterAlternative: 'operator'user-defined-string-literal
            enterElement: 'operator'
              => element -> operator
              enterAtom: 'operator'
                enterTerminal: 'operator'
                exitTerminal: 'operator'
              exitAtom: 'operator'
            exitElement: 'operator'
            enterElement: user-defined-string-literal
              => element -> {user-defined-string-literal}
              enterAtom: user-defined-string-literal
                enterRuleref: user-defined-string-literal
                exitRuleref: user-defined-string-literal
              exitAtom: user-defined-string-literal
            exitElement: user-defined-string-literal
          exitAlternative: 'operator'user-defined-string-literal
        => elements -> ['operator', '{user-defined-string-literal}']
            => alternative -> operator {user-defined-string-literal}
        exitLabeledAlt: 'operator'user-defined-string-literal
      exitRuleAltList: 'operator'unevaluated-stringidentifier|'operator'user-defined-string-literal
    exitRuleBlock: 'operator'unevaluated-stringidentifier|'operator'user-defined-string-literal
  exitRuleSpec: literal-operator-id:'operator'unevaluated-stringidentifier|'operator'user-defined-string-literal;

  enterRuleSpec: template-declaration:template-headdeclaration|template-headconcept-definition;
    enterRuleBlock: template-headdeclaration|template-headconcept-definition
      enterRuleAltList: template-headdeclaration|template-headconcept-definition
        enterLabeledAlt: template-headdeclaration
          enterAlternative: template-headdeclaration
            enterElement: template-head
              => element -> {template-head}
              enterAtom: template-head
                enterRuleref: template-head
                exitRuleref: template-head
              exitAtom: template-head
            exitElement: template-head
            enterElement: declaration
              => element -> {declaration}
              enterAtom: declaration
                enterRuleref: declaration
                exitRuleref: declaration
              exitAtom: declaration
            exitElement: declaration
          exitAlternative: template-headdeclaration
        => elements -> ['{template-head}', '{declaration}']
            => alternative -> {template-head} {declaration}
        exitLabeledAlt: template-headdeclaration
        enterLabeledAlt: template-headconcept-definition
          enterAlternative: template-headconcept-definition
            enterElement: template-head
              => element -> {template-head}
              enterAtom: template-head
                enterRuleref: template-head
                exitRuleref: template-head
              exitAtom: template-head
            exitElement: template-head
            enterElement: concept-definition
              => element -> {concept-definition}
              enterAtom: concept-definition
                enterRuleref: concept-definition
                exitRuleref: concept-definition
              exitAtom: concept-definition
            exitElement: concept-definition
          exitAlternative: template-headconcept-definition
        => elements -> ['{template-head}', '{concept-definition}']
            => alternative -> {template-head} {concept-definition}
        exitLabeledAlt: template-headconcept-definition
      exitRuleAltList: template-headdeclaration|template-headconcept-definition
    exitRuleBlock: template-headdeclaration|template-headconcept-definition
  exitRuleSpec: template-declaration:template-headdeclaration|template-headconcept-definition;

  enterRuleSpec: template-head:'template<'template-parameter-list'>'requires-clause?;
    enterRuleBlock: 'template<'template-parameter-list'>'requires-clause?
      enterRuleAltList: 'template<'template-parameter-list'>'requires-clause?
        enterLabeledAlt: 'template<'template-parameter-list'>'requires-clause?
          enterAlternative: 'template<'template-parameter-list'>'requires-clause?
            enterElement: 'template<'
              => element -> template<
              enterAtom: 'template<'
                enterTerminal: 'template<'
                exitTerminal: 'template<'
              exitAtom: 'template<'
            exitElement: 'template<'
            enterElement: template-parameter-list
              => element -> {template-parameter-list}
              enterAtom: template-parameter-list
                enterRuleref: template-parameter-list
                exitRuleref: template-parameter-list
              exitAtom: template-parameter-list
            exitElement: template-parameter-list
            enterElement: '>'
              => element -> >
              enterAtom: '>'
                enterTerminal: '>'
                exitTerminal: '>'
              exitAtom: '>'
            exitElement: '>'
            enterElement: requires-clause?
              => element -> [requires-clause]
              enterAtom: requires-clause
                enterRuleref: requires-clause
                exitRuleref: requires-clause
              exitAtom: requires-clause
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: requires-clause?
          exitAlternative: 'template<'template-parameter-list'>'requires-clause?
        => elements -> ['template<', '{template-parameter-list}', '>', '[requires-clause]']
            => alternative -> template< {template-parameter-list} > [requires-clause]
        exitLabeledAlt: 'template<'template-parameter-list'>'requires-clause?
      exitRuleAltList: 'template<'template-parameter-list'>'requires-clause?
    exitRuleBlock: 'template<'template-parameter-list'>'requires-clause?
  exitRuleSpec: template-head:'template<'template-parameter-list'>'requires-clause?;

  enterRuleSpec: template-parameter-list:template-parameter|template-parameter-list','template-parameter;
    enterRuleBlock: template-parameter|template-parameter-list','template-parameter
      enterRuleAltList: template-parameter|template-parameter-list','template-parameter
        enterLabeledAlt: template-parameter
          enterAlternative: template-parameter
            enterElement: template-parameter
              => element -> {template-parameter}
              enterAtom: template-parameter
                enterRuleref: template-parameter
                exitRuleref: template-parameter
              exitAtom: template-parameter
            exitElement: template-parameter
          exitAlternative: template-parameter
        => elements -> ['{template-parameter}']
            => alternative -> {template-parameter}
        exitLabeledAlt: template-parameter
        enterLabeledAlt: template-parameter-list','template-parameter
          enterAlternative: template-parameter-list','template-parameter
            enterElement: template-parameter-list
              => element -> {template-parameter-list}
              enterAtom: template-parameter-list
                enterRuleref: template-parameter-list
                exitRuleref: template-parameter-list
              exitAtom: template-parameter-list
            exitElement: template-parameter-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: template-parameter
              => element -> {template-parameter}
              enterAtom: template-parameter
                enterRuleref: template-parameter
                exitRuleref: template-parameter
              exitAtom: template-parameter
            exitElement: template-parameter
          exitAlternative: template-parameter-list','template-parameter
        => elements -> ['{template-parameter-list}', ',', '{template-parameter}']
            => alternative -> {template-parameter-list} , {template-parameter}
        exitLabeledAlt: template-parameter-list','template-parameter
      exitRuleAltList: template-parameter|template-parameter-list','template-parameter
    exitRuleBlock: template-parameter|template-parameter-list','template-parameter
  exitRuleSpec: template-parameter-list:template-parameter|template-parameter-list','template-parameter;

  enterRuleSpec: requires-clause:'requires'constraint-logical-or-expression;
    enterRuleBlock: 'requires'constraint-logical-or-expression
      enterRuleAltList: 'requires'constraint-logical-or-expression
        enterLabeledAlt: 'requires'constraint-logical-or-expression
          enterAlternative: 'requires'constraint-logical-or-expression
            enterElement: 'requires'
              => element -> requires
              enterAtom: 'requires'
                enterTerminal: 'requires'
                exitTerminal: 'requires'
              exitAtom: 'requires'
            exitElement: 'requires'
            enterElement: constraint-logical-or-expression
              => element -> {constraint-logical-or-expression}
              enterAtom: constraint-logical-or-expression
                enterRuleref: constraint-logical-or-expression
                exitRuleref: constraint-logical-or-expression
              exitAtom: constraint-logical-or-expression
            exitElement: constraint-logical-or-expression
          exitAlternative: 'requires'constraint-logical-or-expression
        => elements -> ['requires', '{constraint-logical-or-expression}']
            => alternative -> requires {constraint-logical-or-expression}
        exitLabeledAlt: 'requires'constraint-logical-or-expression
      exitRuleAltList: 'requires'constraint-logical-or-expression
    exitRuleBlock: 'requires'constraint-logical-or-expression
  exitRuleSpec: requires-clause:'requires'constraint-logical-or-expression;

  enterRuleSpec: constraint-logical-or-expression:constraint-logical-and-expression|constraint-logical-or-expression'||'constraint-logical-and-expression;
    enterRuleBlock: constraint-logical-and-expression|constraint-logical-or-expression'||'constraint-logical-and-expression
      enterRuleAltList: constraint-logical-and-expression|constraint-logical-or-expression'||'constraint-logical-and-expression
        enterLabeledAlt: constraint-logical-and-expression
          enterAlternative: constraint-logical-and-expression
            enterElement: constraint-logical-and-expression
              => element -> {constraint-logical-and-expression}
              enterAtom: constraint-logical-and-expression
                enterRuleref: constraint-logical-and-expression
                exitRuleref: constraint-logical-and-expression
              exitAtom: constraint-logical-and-expression
            exitElement: constraint-logical-and-expression
          exitAlternative: constraint-logical-and-expression
        => elements -> ['{constraint-logical-and-expression}']
            => alternative -> {constraint-logical-and-expression}
        exitLabeledAlt: constraint-logical-and-expression
        enterLabeledAlt: constraint-logical-or-expression'||'constraint-logical-and-expression
          enterAlternative: constraint-logical-or-expression'||'constraint-logical-and-expression
            enterElement: constraint-logical-or-expression
              => element -> {constraint-logical-or-expression}
              enterAtom: constraint-logical-or-expression
                enterRuleref: constraint-logical-or-expression
                exitRuleref: constraint-logical-or-expression
              exitAtom: constraint-logical-or-expression
            exitElement: constraint-logical-or-expression
            enterElement: '||'
              => element -> ||
              enterAtom: '||'
                enterTerminal: '||'
                exitTerminal: '||'
              exitAtom: '||'
            exitElement: '||'
            enterElement: constraint-logical-and-expression
              => element -> {constraint-logical-and-expression}
              enterAtom: constraint-logical-and-expression
                enterRuleref: constraint-logical-and-expression
                exitRuleref: constraint-logical-and-expression
              exitAtom: constraint-logical-and-expression
            exitElement: constraint-logical-and-expression
          exitAlternative: constraint-logical-or-expression'||'constraint-logical-and-expression
        => elements -> ['{constraint-logical-or-expression}', '||', '{constraint-logical-and-expression}']
            => alternative -> {constraint-logical-or-expression} || {constraint-logical-and-expression}
        exitLabeledAlt: constraint-logical-or-expression'||'constraint-logical-and-expression
      exitRuleAltList: constraint-logical-and-expression|constraint-logical-or-expression'||'constraint-logical-and-expression
    exitRuleBlock: constraint-logical-and-expression|constraint-logical-or-expression'||'constraint-logical-and-expression
  exitRuleSpec: constraint-logical-or-expression:constraint-logical-and-expression|constraint-logical-or-expression'||'constraint-logical-and-expression;

  enterRuleSpec: constraint-logical-and-expression:primary-expression|constraint-logical-and-expression'&&'primary-expression;
    enterRuleBlock: primary-expression|constraint-logical-and-expression'&&'primary-expression
      enterRuleAltList: primary-expression|constraint-logical-and-expression'&&'primary-expression
        enterLabeledAlt: primary-expression
          enterAlternative: primary-expression
            enterElement: primary-expression
              => element -> {primary-expression}
              enterAtom: primary-expression
                enterRuleref: primary-expression
                exitRuleref: primary-expression
              exitAtom: primary-expression
            exitElement: primary-expression
          exitAlternative: primary-expression
        => elements -> ['{primary-expression}']
            => alternative -> {primary-expression}
        exitLabeledAlt: primary-expression
        enterLabeledAlt: constraint-logical-and-expression'&&'primary-expression
          enterAlternative: constraint-logical-and-expression'&&'primary-expression
            enterElement: constraint-logical-and-expression
              => element -> {constraint-logical-and-expression}
              enterAtom: constraint-logical-and-expression
                enterRuleref: constraint-logical-and-expression
                exitRuleref: constraint-logical-and-expression
              exitAtom: constraint-logical-and-expression
            exitElement: constraint-logical-and-expression
            enterElement: '&&'
              => element -> &&
              enterAtom: '&&'
                enterTerminal: '&&'
                exitTerminal: '&&'
              exitAtom: '&&'
            exitElement: '&&'
            enterElement: primary-expression
              => element -> {primary-expression}
              enterAtom: primary-expression
                enterRuleref: primary-expression
                exitRuleref: primary-expression
              exitAtom: primary-expression
            exitElement: primary-expression
          exitAlternative: constraint-logical-and-expression'&&'primary-expression
        => elements -> ['{constraint-logical-and-expression}', '&&', '{primary-expression}']
            => alternative -> {constraint-logical-and-expression} && {primary-expression}
        exitLabeledAlt: constraint-logical-and-expression'&&'primary-expression
      exitRuleAltList: primary-expression|constraint-logical-and-expression'&&'primary-expression
    exitRuleBlock: primary-expression|constraint-logical-and-expression'&&'primary-expression
  exitRuleSpec: constraint-logical-and-expression:primary-expression|constraint-logical-and-expression'&&'primary-expression;

  enterRuleSpec: template-parameter:type-parameter|parameter-declaration;
    enterRuleBlock: type-parameter|parameter-declaration
      enterRuleAltList: type-parameter|parameter-declaration
        enterLabeledAlt: type-parameter
          enterAlternative: type-parameter
            enterElement: type-parameter
              => element -> {type-parameter}
              enterAtom: type-parameter
                enterRuleref: type-parameter
                exitRuleref: type-parameter
              exitAtom: type-parameter
            exitElement: type-parameter
          exitAlternative: type-parameter
        => elements -> ['{type-parameter}']
            => alternative -> {type-parameter}
        exitLabeledAlt: type-parameter
        enterLabeledAlt: parameter-declaration
          enterAlternative: parameter-declaration
            enterElement: parameter-declaration
              => element -> {parameter-declaration}
              enterAtom: parameter-declaration
                enterRuleref: parameter-declaration
                exitRuleref: parameter-declaration
              exitAtom: parameter-declaration
            exitElement: parameter-declaration
          exitAlternative: parameter-declaration
        => elements -> ['{parameter-declaration}']
            => alternative -> {parameter-declaration}
        exitLabeledAlt: parameter-declaration
      exitRuleAltList: type-parameter|parameter-declaration
    exitRuleBlock: type-parameter|parameter-declaration
  exitRuleSpec: template-parameter:type-parameter|parameter-declaration;

  enterRuleSpec: type-parameter:type-parameter-keythree-dots?identifier?|type-parameter-keyidentifier?'='type-id|type-constraintthree-dots?identifier?|type-constraintidentifier?'='type-id|template-headtype-parameter-keythree-dots?identifier?|template-headtype-parameter-keyidentifier?'='id-expression;
    enterRuleBlock: type-parameter-keythree-dots?identifier?|type-parameter-keyidentifier?'='type-id|type-constraintthree-dots?identifier?|type-constraintidentifier?'='type-id|template-headtype-parameter-keythree-dots?identifier?|template-headtype-parameter-keyidentifier?'='id-expression
      enterRuleAltList: type-parameter-keythree-dots?identifier?|type-parameter-keyidentifier?'='type-id|type-constraintthree-dots?identifier?|type-constraintidentifier?'='type-id|template-headtype-parameter-keythree-dots?identifier?|template-headtype-parameter-keyidentifier?'='id-expression
        enterLabeledAlt: type-parameter-keythree-dots?identifier?
          enterAlternative: type-parameter-keythree-dots?identifier?
            enterElement: type-parameter-key
              => element -> {type-parameter-key}
              enterAtom: type-parameter-key
                enterRuleref: type-parameter-key
                exitRuleref: type-parameter-key
              exitAtom: type-parameter-key
            exitElement: type-parameter-key
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
            enterElement: identifier?
              => element -> [identifier]
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: identifier?
          exitAlternative: type-parameter-keythree-dots?identifier?
        => elements -> ['{type-parameter-key}', '[three-dots]', '[identifier]']
            => alternative -> {type-parameter-key} [three-dots] [identifier]
        exitLabeledAlt: type-parameter-keythree-dots?identifier?
        enterLabeledAlt: type-parameter-keyidentifier?'='type-id
          enterAlternative: type-parameter-keyidentifier?'='type-id
            enterElement: type-parameter-key
              => element -> {type-parameter-key}
              enterAtom: type-parameter-key
                enterRuleref: type-parameter-key
                exitRuleref: type-parameter-key
              exitAtom: type-parameter-key
            exitElement: type-parameter-key
            enterElement: identifier?
              => element -> [identifier]
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: identifier?
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
          exitAlternative: type-parameter-keyidentifier?'='type-id
        => elements -> ['{type-parameter-key}', '[identifier]', '=', '{type-id}']
            => alternative -> {type-parameter-key} [identifier] = {type-id}
        exitLabeledAlt: type-parameter-keyidentifier?'='type-id
        enterLabeledAlt: type-constraintthree-dots?identifier?
          enterAlternative: type-constraintthree-dots?identifier?
            enterElement: type-constraint
              => element -> {type-constraint}
              enterAtom: type-constraint
                enterRuleref: type-constraint
                exitRuleref: type-constraint
              exitAtom: type-constraint
            exitElement: type-constraint
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
            enterElement: identifier?
              => element -> [identifier]
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: identifier?
          exitAlternative: type-constraintthree-dots?identifier?
        => elements -> ['{type-constraint}', '[three-dots]', '[identifier]']
            => alternative -> {type-constraint} [three-dots] [identifier]
        exitLabeledAlt: type-constraintthree-dots?identifier?
        enterLabeledAlt: type-constraintidentifier?'='type-id
          enterAlternative: type-constraintidentifier?'='type-id
            enterElement: type-constraint
              => element -> {type-constraint}
              enterAtom: type-constraint
                enterRuleref: type-constraint
                exitRuleref: type-constraint
              exitAtom: type-constraint
            exitElement: type-constraint
            enterElement: identifier?
              => element -> [identifier]
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: identifier?
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
          exitAlternative: type-constraintidentifier?'='type-id
        => elements -> ['{type-constraint}', '[identifier]', '=', '{type-id}']
            => alternative -> {type-constraint} [identifier] = {type-id}
        exitLabeledAlt: type-constraintidentifier?'='type-id
        enterLabeledAlt: template-headtype-parameter-keythree-dots?identifier?
          enterAlternative: template-headtype-parameter-keythree-dots?identifier?
            enterElement: template-head
              => element -> {template-head}
              enterAtom: template-head
                enterRuleref: template-head
                exitRuleref: template-head
              exitAtom: template-head
            exitElement: template-head
            enterElement: type-parameter-key
              => element -> {type-parameter-key}
              enterAtom: type-parameter-key
                enterRuleref: type-parameter-key
                exitRuleref: type-parameter-key
              exitAtom: type-parameter-key
            exitElement: type-parameter-key
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
            enterElement: identifier?
              => element -> [identifier]
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: identifier?
          exitAlternative: template-headtype-parameter-keythree-dots?identifier?
        => elements -> ['{template-head}', '{type-parameter-key}', '[three-dots]', '[identifier]']
            => alternative -> {template-head} {type-parameter-key} [three-dots] [identifier]
        exitLabeledAlt: template-headtype-parameter-keythree-dots?identifier?
        enterLabeledAlt: template-headtype-parameter-keyidentifier?'='id-expression
          enterAlternative: template-headtype-parameter-keyidentifier?'='id-expression
            enterElement: template-head
              => element -> {template-head}
              enterAtom: template-head
                enterRuleref: template-head
                exitRuleref: template-head
              exitAtom: template-head
            exitElement: template-head
            enterElement: type-parameter-key
              => element -> {type-parameter-key}
              enterAtom: type-parameter-key
                enterRuleref: type-parameter-key
                exitRuleref: type-parameter-key
              exitAtom: type-parameter-key
            exitElement: type-parameter-key
            enterElement: identifier?
              => element -> [identifier]
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: identifier?
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
            enterElement: id-expression
              => element -> {id-expression}
              enterAtom: id-expression
                enterRuleref: id-expression
                exitRuleref: id-expression
              exitAtom: id-expression
            exitElement: id-expression
          exitAlternative: template-headtype-parameter-keyidentifier?'='id-expression
        => elements -> ['{template-head}', '{type-parameter-key}', '[identifier]', '=', '{id-expression}']
            => alternative -> {template-head} {type-parameter-key} [identifier] = {id-expression}
        exitLabeledAlt: template-headtype-parameter-keyidentifier?'='id-expression
      exitRuleAltList: type-parameter-keythree-dots?identifier?|type-parameter-keyidentifier?'='type-id|type-constraintthree-dots?identifier?|type-constraintidentifier?'='type-id|template-headtype-parameter-keythree-dots?identifier?|template-headtype-parameter-keyidentifier?'='id-expression
    exitRuleBlock: type-parameter-keythree-dots?identifier?|type-parameter-keyidentifier?'='type-id|type-constraintthree-dots?identifier?|type-constraintidentifier?'='type-id|template-headtype-parameter-keythree-dots?identifier?|template-headtype-parameter-keyidentifier?'='id-expression
  exitRuleSpec: type-parameter:type-parameter-keythree-dots?identifier?|type-parameter-keyidentifier?'='type-id|type-constraintthree-dots?identifier?|type-constraintidentifier?'='type-id|template-headtype-parameter-keythree-dots?identifier?|template-headtype-parameter-keyidentifier?'='id-expression;

  enterRuleSpec: type-parameter-key:'class'|'typename';
    enterRuleBlock: 'class'|'typename'
      enterRuleAltList: 'class'|'typename'
        enterLabeledAlt: 'class'
          enterAlternative: 'class'
            enterElement: 'class'
              => element -> class
              enterAtom: 'class'
                enterTerminal: 'class'
                exitTerminal: 'class'
              exitAtom: 'class'
            exitElement: 'class'
          exitAlternative: 'class'
        => elements -> ['class']
            => alternative -> class
        exitLabeledAlt: 'class'
        enterLabeledAlt: 'typename'
          enterAlternative: 'typename'
            enterElement: 'typename'
              => element -> typename
              enterAtom: 'typename'
                enterTerminal: 'typename'
                exitTerminal: 'typename'
              exitAtom: 'typename'
            exitElement: 'typename'
          exitAlternative: 'typename'
        => elements -> ['typename']
            => alternative -> typename
        exitLabeledAlt: 'typename'
      exitRuleAltList: 'class'|'typename'
    exitRuleBlock: 'class'|'typename'
  exitRuleSpec: type-parameter-key:'class'|'typename';

  enterRuleSpec: type-constraint:nested-name-specifier?concept-name|nested-name-specifier?concept-name'<'template-argument-list?'>';
    enterRuleBlock: nested-name-specifier?concept-name|nested-name-specifier?concept-name'<'template-argument-list?'>'
      enterRuleAltList: nested-name-specifier?concept-name|nested-name-specifier?concept-name'<'template-argument-list?'>'
        enterLabeledAlt: nested-name-specifier?concept-name
          enterAlternative: nested-name-specifier?concept-name
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: concept-name
              => element -> {concept-name}
              enterAtom: concept-name
                enterRuleref: concept-name
                exitRuleref: concept-name
              exitAtom: concept-name
            exitElement: concept-name
          exitAlternative: nested-name-specifier?concept-name
        => elements -> ['[nested-name-specifier]', '{concept-name}']
            => alternative -> [nested-name-specifier] {concept-name}
        exitLabeledAlt: nested-name-specifier?concept-name
        enterLabeledAlt: nested-name-specifier?concept-name'<'template-argument-list?'>'
          enterAlternative: nested-name-specifier?concept-name'<'template-argument-list?'>'
            enterElement: nested-name-specifier?
              => element -> [nested-name-specifier]
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: nested-name-specifier?
            enterElement: concept-name
              => element -> {concept-name}
              enterAtom: concept-name
                enterRuleref: concept-name
                exitRuleref: concept-name
              exitAtom: concept-name
            exitElement: concept-name
            enterElement: '<'
              => element -> <
              enterAtom: '<'
                enterTerminal: '<'
                exitTerminal: '<'
              exitAtom: '<'
            exitElement: '<'
            enterElement: template-argument-list?
              => element -> [template-argument-list]
              enterAtom: template-argument-list
                enterRuleref: template-argument-list
                exitRuleref: template-argument-list
              exitAtom: template-argument-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: template-argument-list?
            enterElement: '>'
              => element -> >
              enterAtom: '>'
                enterTerminal: '>'
                exitTerminal: '>'
              exitAtom: '>'
            exitElement: '>'
          exitAlternative: nested-name-specifier?concept-name'<'template-argument-list?'>'
        => elements -> ['[nested-name-specifier]', '{concept-name}', '<', '[template-argument-list]', '>']
            => alternative -> [nested-name-specifier] {concept-name} < [template-argument-list] >
        exitLabeledAlt: nested-name-specifier?concept-name'<'template-argument-list?'>'
      exitRuleAltList: nested-name-specifier?concept-name|nested-name-specifier?concept-name'<'template-argument-list?'>'
    exitRuleBlock: nested-name-specifier?concept-name|nested-name-specifier?concept-name'<'template-argument-list?'>'
  exitRuleSpec: type-constraint:nested-name-specifier?concept-name|nested-name-specifier?concept-name'<'template-argument-list?'>';

  enterRuleSpec: simple-template-id:template-name'<'template-argument-list?'>';
    enterRuleBlock: template-name'<'template-argument-list?'>'
      enterRuleAltList: template-name'<'template-argument-list?'>'
        enterLabeledAlt: template-name'<'template-argument-list?'>'
          enterAlternative: template-name'<'template-argument-list?'>'
            enterElement: template-name
              => element -> {template-name}
              enterAtom: template-name
                enterRuleref: template-name
                exitRuleref: template-name
              exitAtom: template-name
            exitElement: template-name
            enterElement: '<'
              => element -> <
              enterAtom: '<'
                enterTerminal: '<'
                exitTerminal: '<'
              exitAtom: '<'
            exitElement: '<'
            enterElement: template-argument-list?
              => element -> [template-argument-list]
              enterAtom: template-argument-list
                enterRuleref: template-argument-list
                exitRuleref: template-argument-list
              exitAtom: template-argument-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: template-argument-list?
            enterElement: '>'
              => element -> >
              enterAtom: '>'
                enterTerminal: '>'
                exitTerminal: '>'
              exitAtom: '>'
            exitElement: '>'
          exitAlternative: template-name'<'template-argument-list?'>'
        => elements -> ['{template-name}', '<', '[template-argument-list]', '>']
            => alternative -> {template-name} < [template-argument-list] >
        exitLabeledAlt: template-name'<'template-argument-list?'>'
      exitRuleAltList: template-name'<'template-argument-list?'>'
    exitRuleBlock: template-name'<'template-argument-list?'>'
  exitRuleSpec: simple-template-id:template-name'<'template-argument-list?'>';

  enterRuleSpec: template-id:simple-template-id|operator-function-id'<'template-argument-list?'>'|literal-operator-id'<'template-argument-list?'>';
    enterRuleBlock: simple-template-id|operator-function-id'<'template-argument-list?'>'|literal-operator-id'<'template-argument-list?'>'
      enterRuleAltList: simple-template-id|operator-function-id'<'template-argument-list?'>'|literal-operator-id'<'template-argument-list?'>'
        enterLabeledAlt: simple-template-id
          enterAlternative: simple-template-id
            enterElement: simple-template-id
              => element -> {simple-template-id}
              enterAtom: simple-template-id
                enterRuleref: simple-template-id
                exitRuleref: simple-template-id
              exitAtom: simple-template-id
            exitElement: simple-template-id
          exitAlternative: simple-template-id
        => elements -> ['{simple-template-id}']
            => alternative -> {simple-template-id}
        exitLabeledAlt: simple-template-id
        enterLabeledAlt: operator-function-id'<'template-argument-list?'>'
          enterAlternative: operator-function-id'<'template-argument-list?'>'
            enterElement: operator-function-id
              => element -> {operator-function-id}
              enterAtom: operator-function-id
                enterRuleref: operator-function-id
                exitRuleref: operator-function-id
              exitAtom: operator-function-id
            exitElement: operator-function-id
            enterElement: '<'
              => element -> <
              enterAtom: '<'
                enterTerminal: '<'
                exitTerminal: '<'
              exitAtom: '<'
            exitElement: '<'
            enterElement: template-argument-list?
              => element -> [template-argument-list]
              enterAtom: template-argument-list
                enterRuleref: template-argument-list
                exitRuleref: template-argument-list
              exitAtom: template-argument-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: template-argument-list?
            enterElement: '>'
              => element -> >
              enterAtom: '>'
                enterTerminal: '>'
                exitTerminal: '>'
              exitAtom: '>'
            exitElement: '>'
          exitAlternative: operator-function-id'<'template-argument-list?'>'
        => elements -> ['{operator-function-id}', '<', '[template-argument-list]', '>']
            => alternative -> {operator-function-id} < [template-argument-list] >
        exitLabeledAlt: operator-function-id'<'template-argument-list?'>'
        enterLabeledAlt: literal-operator-id'<'template-argument-list?'>'
          enterAlternative: literal-operator-id'<'template-argument-list?'>'
            enterElement: literal-operator-id
              => element -> {literal-operator-id}
              enterAtom: literal-operator-id
                enterRuleref: literal-operator-id
                exitRuleref: literal-operator-id
              exitAtom: literal-operator-id
            exitElement: literal-operator-id
            enterElement: '<'
              => element -> <
              enterAtom: '<'
                enterTerminal: '<'
                exitTerminal: '<'
              exitAtom: '<'
            exitElement: '<'
            enterElement: template-argument-list?
              => element -> [template-argument-list]
              enterAtom: template-argument-list
                enterRuleref: template-argument-list
                exitRuleref: template-argument-list
              exitAtom: template-argument-list
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: template-argument-list?
            enterElement: '>'
              => element -> >
              enterAtom: '>'
                enterTerminal: '>'
                exitTerminal: '>'
              exitAtom: '>'
            exitElement: '>'
          exitAlternative: literal-operator-id'<'template-argument-list?'>'
        => elements -> ['{literal-operator-id}', '<', '[template-argument-list]', '>']
            => alternative -> {literal-operator-id} < [template-argument-list] >
        exitLabeledAlt: literal-operator-id'<'template-argument-list?'>'
      exitRuleAltList: simple-template-id|operator-function-id'<'template-argument-list?'>'|literal-operator-id'<'template-argument-list?'>'
    exitRuleBlock: simple-template-id|operator-function-id'<'template-argument-list?'>'|literal-operator-id'<'template-argument-list?'>'
  exitRuleSpec: template-id:simple-template-id|operator-function-id'<'template-argument-list?'>'|literal-operator-id'<'template-argument-list?'>';

  enterRuleSpec: template-name:identifier;
    enterRuleBlock: identifier
      enterRuleAltList: identifier
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
      exitRuleAltList: identifier
    exitRuleBlock: identifier
  exitRuleSpec: template-name:identifier;

  enterRuleSpec: template-argument-list:template-argumentthree-dots?|template-argument-list','template-argumentthree-dots?;
    enterRuleBlock: template-argumentthree-dots?|template-argument-list','template-argumentthree-dots?
      enterRuleAltList: template-argumentthree-dots?|template-argument-list','template-argumentthree-dots?
        enterLabeledAlt: template-argumentthree-dots?
          enterAlternative: template-argumentthree-dots?
            enterElement: template-argument
              => element -> {template-argument}
              enterAtom: template-argument
                enterRuleref: template-argument
                exitRuleref: template-argument
              exitAtom: template-argument
            exitElement: template-argument
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
          exitAlternative: template-argumentthree-dots?
        => elements -> ['{template-argument}', '[three-dots]']
            => alternative -> {template-argument} [three-dots]
        exitLabeledAlt: template-argumentthree-dots?
        enterLabeledAlt: template-argument-list','template-argumentthree-dots?
          enterAlternative: template-argument-list','template-argumentthree-dots?
            enterElement: template-argument-list
              => element -> {template-argument-list}
              enterAtom: template-argument-list
                enterRuleref: template-argument-list
                exitRuleref: template-argument-list
              exitAtom: template-argument-list
            exitElement: template-argument-list
            enterElement: ','
              => element -> ,
              enterAtom: ','
                enterTerminal: ','
                exitTerminal: ','
              exitAtom: ','
            exitElement: ','
            enterElement: template-argument
              => element -> {template-argument}
              enterAtom: template-argument
                enterRuleref: template-argument
                exitRuleref: template-argument
              exitAtom: template-argument
            exitElement: template-argument
            enterElement: three-dots?
              => element -> [three-dots]
              enterAtom: three-dots
                enterRuleref: three-dots
                exitRuleref: three-dots
              exitAtom: three-dots
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: three-dots?
          exitAlternative: template-argument-list','template-argumentthree-dots?
        => elements -> ['{template-argument-list}', ',', '{template-argument}', '[three-dots]']
            => alternative -> {template-argument-list} , {template-argument} [three-dots]
        exitLabeledAlt: template-argument-list','template-argumentthree-dots?
      exitRuleAltList: template-argumentthree-dots?|template-argument-list','template-argumentthree-dots?
    exitRuleBlock: template-argumentthree-dots?|template-argument-list','template-argumentthree-dots?
  exitRuleSpec: template-argument-list:template-argumentthree-dots?|template-argument-list','template-argumentthree-dots?;

  enterRuleSpec: template-argument:constant-expression|type-id|id-expression|braced-init-list;
    enterRuleBlock: constant-expression|type-id|id-expression|braced-init-list
      enterRuleAltList: constant-expression|type-id|id-expression|braced-init-list
        enterLabeledAlt: constant-expression
          enterAlternative: constant-expression
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
          exitAlternative: constant-expression
        => elements -> ['{constant-expression}']
            => alternative -> {constant-expression}
        exitLabeledAlt: constant-expression
        enterLabeledAlt: type-id
          enterAlternative: type-id
            enterElement: type-id
              => element -> {type-id}
              enterAtom: type-id
                enterRuleref: type-id
                exitRuleref: type-id
              exitAtom: type-id
            exitElement: type-id
          exitAlternative: type-id
        => elements -> ['{type-id}']
            => alternative -> {type-id}
        exitLabeledAlt: type-id
        enterLabeledAlt: id-expression
          enterAlternative: id-expression
            enterElement: id-expression
              => element -> {id-expression}
              enterAtom: id-expression
                enterRuleref: id-expression
                exitRuleref: id-expression
              exitAtom: id-expression
            exitElement: id-expression
          exitAlternative: id-expression
        => elements -> ['{id-expression}']
            => alternative -> {id-expression}
        exitLabeledAlt: id-expression
        enterLabeledAlt: braced-init-list
          enterAlternative: braced-init-list
            enterElement: braced-init-list
              => element -> {braced-init-list}
              enterAtom: braced-init-list
                enterRuleref: braced-init-list
                exitRuleref: braced-init-list
              exitAtom: braced-init-list
            exitElement: braced-init-list
          exitAlternative: braced-init-list
        => elements -> ['{braced-init-list}']
            => alternative -> {braced-init-list}
        exitLabeledAlt: braced-init-list
      exitRuleAltList: constant-expression|type-id|id-expression|braced-init-list
    exitRuleBlock: constant-expression|type-id|id-expression|braced-init-list
  exitRuleSpec: template-argument:constant-expression|type-id|id-expression|braced-init-list;

  enterRuleSpec: constraint-expression:logical-or-expression;
    enterRuleBlock: logical-or-expression
      enterRuleAltList: logical-or-expression
        enterLabeledAlt: logical-or-expression
          enterAlternative: logical-or-expression
            enterElement: logical-or-expression
              => element -> {logical-or-expression}
              enterAtom: logical-or-expression
                enterRuleref: logical-or-expression
                exitRuleref: logical-or-expression
              exitAtom: logical-or-expression
            exitElement: logical-or-expression
          exitAlternative: logical-or-expression
        => elements -> ['{logical-or-expression}']
            => alternative -> {logical-or-expression}
        exitLabeledAlt: logical-or-expression
      exitRuleAltList: logical-or-expression
    exitRuleBlock: logical-or-expression
  exitRuleSpec: constraint-expression:logical-or-expression;

  enterRuleSpec: deduction-guide:explicit-specifier?template-name'('parameter-declaration-clause')->'simple-template-id';';
    enterRuleBlock: explicit-specifier?template-name'('parameter-declaration-clause')->'simple-template-id';'
      enterRuleAltList: explicit-specifier?template-name'('parameter-declaration-clause')->'simple-template-id';'
        enterLabeledAlt: explicit-specifier?template-name'('parameter-declaration-clause')->'simple-template-id';'
          enterAlternative: explicit-specifier?template-name'('parameter-declaration-clause')->'simple-template-id';'
            enterElement: explicit-specifier?
              => element -> [explicit-specifier]
              enterAtom: explicit-specifier
                enterRuleref: explicit-specifier
                exitRuleref: explicit-specifier
              exitAtom: explicit-specifier
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: explicit-specifier?
            enterElement: template-name
              => element -> {template-name}
              enterAtom: template-name
                enterRuleref: template-name
                exitRuleref: template-name
              exitAtom: template-name
            exitElement: template-name
            enterElement: '('
              => element -> (
              enterAtom: '('
                enterTerminal: '('
                exitTerminal: '('
              exitAtom: '('
            exitElement: '('
            enterElement: parameter-declaration-clause
              => element -> {parameter-declaration-clause}
              enterAtom: parameter-declaration-clause
                enterRuleref: parameter-declaration-clause
                exitRuleref: parameter-declaration-clause
              exitAtom: parameter-declaration-clause
            exitElement: parameter-declaration-clause
            enterElement: ')->'
              => element -> )->
              enterAtom: ')->'
                enterTerminal: ')->'
                exitTerminal: ')->'
              exitAtom: ')->'
            exitElement: ')->'
            enterElement: simple-template-id
              => element -> {simple-template-id}
              enterAtom: simple-template-id
                enterRuleref: simple-template-id
                exitRuleref: simple-template-id
              exitAtom: simple-template-id
            exitElement: simple-template-id
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: explicit-specifier?template-name'('parameter-declaration-clause')->'simple-template-id';'
        => elements -> ['[explicit-specifier]', '{template-name}', '(', '{parameter-declaration-clause}', ')->', '{simple-template-id}', ';']
            => alternative -> [explicit-specifier] {template-name} ( {parameter-declaration-clause} )-> {simple-template-id} ;
        exitLabeledAlt: explicit-specifier?template-name'('parameter-declaration-clause')->'simple-template-id';'
      exitRuleAltList: explicit-specifier?template-name'('parameter-declaration-clause')->'simple-template-id';'
    exitRuleBlock: explicit-specifier?template-name'('parameter-declaration-clause')->'simple-template-id';'
  exitRuleSpec: deduction-guide:explicit-specifier?template-name'('parameter-declaration-clause')->'simple-template-id';';

  enterRuleSpec: concept-definition:conceptconcept-nameattribute-specifier*'='constraint-expression';';
    enterRuleBlock: conceptconcept-nameattribute-specifier*'='constraint-expression';'
      enterRuleAltList: conceptconcept-nameattribute-specifier*'='constraint-expression';'
        enterLabeledAlt: conceptconcept-nameattribute-specifier*'='constraint-expression';'
          enterAlternative: conceptconcept-nameattribute-specifier*'='constraint-expression';'
            enterElement: concept
              => element -> {concept}
              enterAtom: concept
                enterRuleref: concept
                exitRuleref: concept
              exitAtom: concept
            exitElement: concept
            enterElement: concept-name
              => element -> {concept-name}
              enterAtom: concept-name
                enterRuleref: concept-name
                exitRuleref: concept-name
              exitAtom: concept-name
            exitElement: concept-name
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: '='
              => element -> =
              enterAtom: '='
                enterTerminal: '='
                exitTerminal: '='
              exitAtom: '='
            exitElement: '='
            enterElement: constraint-expression
              => element -> {constraint-expression}
              enterAtom: constraint-expression
                enterRuleref: constraint-expression
                exitRuleref: constraint-expression
              exitAtom: constraint-expression
            exitElement: constraint-expression
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
          exitAlternative: conceptconcept-nameattribute-specifier*'='constraint-expression';'
        => elements -> ['{concept}', '{concept-name}', '[attribute-specifier]...', '=', '{constraint-expression}', ';']
            => alternative -> {concept} {concept-name} [attribute-specifier]... = {constraint-expression} ;
        exitLabeledAlt: conceptconcept-nameattribute-specifier*'='constraint-expression';'
      exitRuleAltList: conceptconcept-nameattribute-specifier*'='constraint-expression';'
    exitRuleBlock: conceptconcept-nameattribute-specifier*'='constraint-expression';'
  exitRuleSpec: concept-definition:conceptconcept-nameattribute-specifier*'='constraint-expression';';

  enterRuleSpec: concept-name:identifier;
    enterRuleBlock: identifier
      enterRuleAltList: identifier
        enterLabeledAlt: identifier
          enterAlternative: identifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: identifier
        => elements -> ['{identifier}']
            => alternative -> {identifier}
        exitLabeledAlt: identifier
      exitRuleAltList: identifier
    exitRuleBlock: identifier
  exitRuleSpec: concept-name:identifier;

  enterRuleSpec: typename-specifier:'typename'nested-name-specifieridentifier|'typename'nested-name-specifiertemplate?simple-template-id;
    enterRuleBlock: 'typename'nested-name-specifieridentifier|'typename'nested-name-specifiertemplate?simple-template-id
      enterRuleAltList: 'typename'nested-name-specifieridentifier|'typename'nested-name-specifiertemplate?simple-template-id
        enterLabeledAlt: 'typename'nested-name-specifieridentifier
          enterAlternative: 'typename'nested-name-specifieridentifier
            enterElement: 'typename'
              => element -> typename
              enterAtom: 'typename'
                enterTerminal: 'typename'
                exitTerminal: 'typename'
              exitAtom: 'typename'
            exitElement: 'typename'
            enterElement: nested-name-specifier
              => element -> {nested-name-specifier}
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
            exitElement: nested-name-specifier
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: 'typename'nested-name-specifieridentifier
        => elements -> ['typename', '{nested-name-specifier}', '{identifier}']
            => alternative -> typename {nested-name-specifier} {identifier}
        exitLabeledAlt: 'typename'nested-name-specifieridentifier
        enterLabeledAlt: 'typename'nested-name-specifiertemplate?simple-template-id
          enterAlternative: 'typename'nested-name-specifiertemplate?simple-template-id
            enterElement: 'typename'
              => element -> typename
              enterAtom: 'typename'
                enterTerminal: 'typename'
                exitTerminal: 'typename'
              exitAtom: 'typename'
            exitElement: 'typename'
            enterElement: nested-name-specifier
              => element -> {nested-name-specifier}
              enterAtom: nested-name-specifier
                enterRuleref: nested-name-specifier
                exitRuleref: nested-name-specifier
              exitAtom: nested-name-specifier
            exitElement: nested-name-specifier
            enterElement: template?
              => element -> [template]
              enterAtom: template
                enterRuleref: template
                exitRuleref: template
              exitAtom: template
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: template?
            enterElement: simple-template-id
              => element -> {simple-template-id}
              enterAtom: simple-template-id
                enterRuleref: simple-template-id
                exitRuleref: simple-template-id
              exitAtom: simple-template-id
            exitElement: simple-template-id
          exitAlternative: 'typename'nested-name-specifiertemplate?simple-template-id
        => elements -> ['typename', '{nested-name-specifier}', '[template]', '{simple-template-id}']
            => alternative -> typename {nested-name-specifier} [template] {simple-template-id}
        exitLabeledAlt: 'typename'nested-name-specifiertemplate?simple-template-id
      exitRuleAltList: 'typename'nested-name-specifieridentifier|'typename'nested-name-specifiertemplate?simple-template-id
    exitRuleBlock: 'typename'nested-name-specifieridentifier|'typename'nested-name-specifiertemplate?simple-template-id
  exitRuleSpec: typename-specifier:'typename'nested-name-specifieridentifier|'typename'nested-name-specifiertemplate?simple-template-id;

  enterRuleSpec: extern:'extern';
    enterRuleBlock: 'extern'
      enterRuleAltList: 'extern'
        enterLabeledAlt: 'extern'
          enterAlternative: 'extern'
            enterElement: 'extern'
              => element -> extern
              enterAtom: 'extern'
                enterTerminal: 'extern'
                exitTerminal: 'extern'
              exitAtom: 'extern'
            exitElement: 'extern'
          exitAlternative: 'extern'
        => elements -> ['extern']
            => alternative -> extern
        exitLabeledAlt: 'extern'
      exitRuleAltList: 'extern'
    exitRuleBlock: 'extern'
  exitRuleSpec: extern:'extern';

  enterRuleSpec: explicit-instantiation:extern?'template'declaration;
    enterRuleBlock: extern?'template'declaration
      enterRuleAltList: extern?'template'declaration
        enterLabeledAlt: extern?'template'declaration
          enterAlternative: extern?'template'declaration
            enterElement: extern?
              => element -> [extern]
              enterAtom: extern
                enterRuleref: extern
                exitRuleref: extern
              exitAtom: extern
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: extern?
            enterElement: 'template'
              => element -> template
              enterAtom: 'template'
                enterTerminal: 'template'
                exitTerminal: 'template'
              exitAtom: 'template'
            exitElement: 'template'
            enterElement: declaration
              => element -> {declaration}
              enterAtom: declaration
                enterRuleref: declaration
                exitRuleref: declaration
              exitAtom: declaration
            exitElement: declaration
          exitAlternative: extern?'template'declaration
        => elements -> ['[extern]', 'template', '{declaration}']
            => alternative -> [extern] template {declaration}
        exitLabeledAlt: extern?'template'declaration
      exitRuleAltList: extern?'template'declaration
    exitRuleBlock: extern?'template'declaration
  exitRuleSpec: explicit-instantiation:extern?'template'declaration;

  enterRuleSpec: explicit-specialization:'template<>'declaration;
    enterRuleBlock: 'template<>'declaration
      enterRuleAltList: 'template<>'declaration
        enterLabeledAlt: 'template<>'declaration
          enterAlternative: 'template<>'declaration
            enterElement: 'template<>'
              => element -> template<>
              enterAtom: 'template<>'
                enterTerminal: 'template<>'
                exitTerminal: 'template<>'
              exitAtom: 'template<>'
            exitElement: 'template<>'
            enterElement: declaration
              => element -> {declaration}
              enterAtom: declaration
                enterRuleref: declaration
                exitRuleref: declaration
              exitAtom: declaration
            exitElement: declaration
          exitAlternative: 'template<>'declaration
        => elements -> ['template<>', '{declaration}']
            => alternative -> template<> {declaration}
        exitLabeledAlt: 'template<>'declaration
      exitRuleAltList: 'template<>'declaration
    exitRuleBlock: 'template<>'declaration
  exitRuleSpec: explicit-specialization:'template<>'declaration;

  enterRuleSpec: try-block:'try'compound-statementhandler-seq;
    enterRuleBlock: 'try'compound-statementhandler-seq
      enterRuleAltList: 'try'compound-statementhandler-seq
        enterLabeledAlt: 'try'compound-statementhandler-seq
          enterAlternative: 'try'compound-statementhandler-seq
            enterElement: 'try'
              => element -> try
              enterAtom: 'try'
                enterTerminal: 'try'
                exitTerminal: 'try'
              exitAtom: 'try'
            exitElement: 'try'
            enterElement: compound-statement
              => element -> {compound-statement}
              enterAtom: compound-statement
                enterRuleref: compound-statement
                exitRuleref: compound-statement
              exitAtom: compound-statement
            exitElement: compound-statement
            enterElement: handler-seq
              => element -> {handler-seq}
              enterAtom: handler-seq
                enterRuleref: handler-seq
                exitRuleref: handler-seq
              exitAtom: handler-seq
            exitElement: handler-seq
          exitAlternative: 'try'compound-statementhandler-seq
        => elements -> ['try', '{compound-statement}', '{handler-seq}']
            => alternative -> try {compound-statement} {handler-seq}
        exitLabeledAlt: 'try'compound-statementhandler-seq
      exitRuleAltList: 'try'compound-statementhandler-seq
    exitRuleBlock: 'try'compound-statementhandler-seq
  exitRuleSpec: try-block:'try'compound-statementhandler-seq;

  enterRuleSpec: function-try-block:'try'ctor-initializer?compound-statementhandler-seq;
    enterRuleBlock: 'try'ctor-initializer?compound-statementhandler-seq
      enterRuleAltList: 'try'ctor-initializer?compound-statementhandler-seq
        enterLabeledAlt: 'try'ctor-initializer?compound-statementhandler-seq
          enterAlternative: 'try'ctor-initializer?compound-statementhandler-seq
            enterElement: 'try'
              => element -> try
              enterAtom: 'try'
                enterTerminal: 'try'
                exitTerminal: 'try'
              exitAtom: 'try'
            exitElement: 'try'
            enterElement: ctor-initializer?
              => element -> [ctor-initializer]
              enterAtom: ctor-initializer
                enterRuleref: ctor-initializer
                exitRuleref: ctor-initializer
              exitAtom: ctor-initializer
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: ctor-initializer?
            enterElement: compound-statement
              => element -> {compound-statement}
              enterAtom: compound-statement
                enterRuleref: compound-statement
                exitRuleref: compound-statement
              exitAtom: compound-statement
            exitElement: compound-statement
            enterElement: handler-seq
              => element -> {handler-seq}
              enterAtom: handler-seq
                enterRuleref: handler-seq
                exitRuleref: handler-seq
              exitAtom: handler-seq
            exitElement: handler-seq
          exitAlternative: 'try'ctor-initializer?compound-statementhandler-seq
        => elements -> ['try', '[ctor-initializer]', '{compound-statement}', '{handler-seq}']
            => alternative -> try [ctor-initializer] {compound-statement} {handler-seq}
        exitLabeledAlt: 'try'ctor-initializer?compound-statementhandler-seq
      exitRuleAltList: 'try'ctor-initializer?compound-statementhandler-seq
    exitRuleBlock: 'try'ctor-initializer?compound-statementhandler-seq
  exitRuleSpec: function-try-block:'try'ctor-initializer?compound-statementhandler-seq;

  enterRuleSpec: handler-seq:handlerhandler-seq?;
    enterRuleBlock: handlerhandler-seq?
      enterRuleAltList: handlerhandler-seq?
        enterLabeledAlt: handlerhandler-seq?
          enterAlternative: handlerhandler-seq?
            enterElement: handler
              => element -> {handler}
              enterAtom: handler
                enterRuleref: handler
                exitRuleref: handler
              exitAtom: handler
            exitElement: handler
            enterElement: handler-seq?
              => element -> [handler-seq]
              enterAtom: handler-seq
                enterRuleref: handler-seq
                exitRuleref: handler-seq
              exitAtom: handler-seq
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: handler-seq?
          exitAlternative: handlerhandler-seq?
        => elements -> ['{handler}', '[handler-seq]']
            => alternative -> {handler} [handler-seq]
        exitLabeledAlt: handlerhandler-seq?
      exitRuleAltList: handlerhandler-seq?
    exitRuleBlock: handlerhandler-seq?
  exitRuleSpec: handler-seq:handlerhandler-seq?;

  enterRuleSpec: handler:'catch('exception-declaration')'compound-statement;
    enterRuleBlock: 'catch('exception-declaration')'compound-statement
      enterRuleAltList: 'catch('exception-declaration')'compound-statement
        enterLabeledAlt: 'catch('exception-declaration')'compound-statement
          enterAlternative: 'catch('exception-declaration')'compound-statement
            enterElement: 'catch('
              => element -> catch(
              enterAtom: 'catch('
                enterTerminal: 'catch('
                exitTerminal: 'catch('
              exitAtom: 'catch('
            exitElement: 'catch('
            enterElement: exception-declaration
              => element -> {exception-declaration}
              enterAtom: exception-declaration
                enterRuleref: exception-declaration
                exitRuleref: exception-declaration
              exitAtom: exception-declaration
            exitElement: exception-declaration
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
            enterElement: compound-statement
              => element -> {compound-statement}
              enterAtom: compound-statement
                enterRuleref: compound-statement
                exitRuleref: compound-statement
              exitAtom: compound-statement
            exitElement: compound-statement
          exitAlternative: 'catch('exception-declaration')'compound-statement
        => elements -> ['catch(', '{exception-declaration}', ')', '{compound-statement}']
            => alternative -> catch( {exception-declaration} ) {compound-statement}
        exitLabeledAlt: 'catch('exception-declaration')'compound-statement
      exitRuleAltList: 'catch('exception-declaration')'compound-statement
    exitRuleBlock: 'catch('exception-declaration')'compound-statement
  exitRuleSpec: handler:'catch('exception-declaration')'compound-statement;

  enterRuleSpec: exception-declaration:attribute-specifier*type-specifier-seqdeclarator|attribute-specifier*type-specifier-seqabstract-declarator?|'...';
    enterRuleBlock: attribute-specifier*type-specifier-seqdeclarator|attribute-specifier*type-specifier-seqabstract-declarator?|'...'
      enterRuleAltList: attribute-specifier*type-specifier-seqdeclarator|attribute-specifier*type-specifier-seqabstract-declarator?|'...'
        enterLabeledAlt: attribute-specifier*type-specifier-seqdeclarator
          enterAlternative: attribute-specifier*type-specifier-seqdeclarator
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: type-specifier-seq
              => element -> {type-specifier-seq}
              enterAtom: type-specifier-seq
                enterRuleref: type-specifier-seq
                exitRuleref: type-specifier-seq
              exitAtom: type-specifier-seq
            exitElement: type-specifier-seq
            enterElement: declarator
              => element -> {declarator}
              enterAtom: declarator
                enterRuleref: declarator
                exitRuleref: declarator
              exitAtom: declarator
            exitElement: declarator
          exitAlternative: attribute-specifier*type-specifier-seqdeclarator
        => elements -> ['[attribute-specifier]...', '{type-specifier-seq}', '{declarator}']
            => alternative -> [attribute-specifier]... {type-specifier-seq} {declarator}
        exitLabeledAlt: attribute-specifier*type-specifier-seqdeclarator
        enterLabeledAlt: attribute-specifier*type-specifier-seqabstract-declarator?
          enterAlternative: attribute-specifier*type-specifier-seqabstract-declarator?
            enterElement: attribute-specifier*
              => element -> [attribute-specifier]...
              enterAtom: attribute-specifier
                enterRuleref: attribute-specifier
                exitRuleref: attribute-specifier
              exitAtom: attribute-specifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: attribute-specifier*
            enterElement: type-specifier-seq
              => element -> {type-specifier-seq}
              enterAtom: type-specifier-seq
                enterRuleref: type-specifier-seq
                exitRuleref: type-specifier-seq
              exitAtom: type-specifier-seq
            exitElement: type-specifier-seq
            enterElement: abstract-declarator?
              => element -> [abstract-declarator]
              enterAtom: abstract-declarator
                enterRuleref: abstract-declarator
                exitRuleref: abstract-declarator
              exitAtom: abstract-declarator
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: abstract-declarator?
          exitAlternative: attribute-specifier*type-specifier-seqabstract-declarator?
        => elements -> ['[attribute-specifier]...', '{type-specifier-seq}', '[abstract-declarator]']
            => alternative -> [attribute-specifier]... {type-specifier-seq} [abstract-declarator]
        exitLabeledAlt: attribute-specifier*type-specifier-seqabstract-declarator?
        enterLabeledAlt: '...'
          enterAlternative: '...'
            enterElement: '...'
              => element -> ...
              enterAtom: '...'
                enterTerminal: '...'
                exitTerminal: '...'
              exitAtom: '...'
            exitElement: '...'
          exitAlternative: '...'
        => elements -> ['...']
            => alternative -> ...
        exitLabeledAlt: '...'
      exitRuleAltList: attribute-specifier*type-specifier-seqdeclarator|attribute-specifier*type-specifier-seqabstract-declarator?|'...'
    exitRuleBlock: attribute-specifier*type-specifier-seqdeclarator|attribute-specifier*type-specifier-seqabstract-declarator?|'...'
  exitRuleSpec: exception-declaration:attribute-specifier*type-specifier-seqdeclarator|attribute-specifier*type-specifier-seqabstract-declarator?|'...';

  enterRuleSpec: noexcept-specifier:'noexcept('constant-expression')'|'noexcept';
    enterRuleBlock: 'noexcept('constant-expression')'|'noexcept'
      enterRuleAltList: 'noexcept('constant-expression')'|'noexcept'
        enterLabeledAlt: 'noexcept('constant-expression')'
          enterAlternative: 'noexcept('constant-expression')'
            enterElement: 'noexcept('
              => element -> noexcept(
              enterAtom: 'noexcept('
                enterTerminal: 'noexcept('
                exitTerminal: 'noexcept('
              exitAtom: 'noexcept('
            exitElement: 'noexcept('
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'noexcept('constant-expression')'
        => elements -> ['noexcept(', '{constant-expression}', ')']
            => alternative -> noexcept( {constant-expression} )
        exitLabeledAlt: 'noexcept('constant-expression')'
        enterLabeledAlt: 'noexcept'
          enterAlternative: 'noexcept'
            enterElement: 'noexcept'
              => element -> noexcept
              enterAtom: 'noexcept'
                enterTerminal: 'noexcept'
                exitTerminal: 'noexcept'
              exitAtom: 'noexcept'
            exitElement: 'noexcept'
          exitAlternative: 'noexcept'
        => elements -> ['noexcept']
            => alternative -> noexcept
        exitLabeledAlt: 'noexcept'
      exitRuleAltList: 'noexcept('constant-expression')'|'noexcept'
    exitRuleBlock: 'noexcept('constant-expression')'|'noexcept'
  exitRuleSpec: noexcept-specifier:'noexcept('constant-expression')'|'noexcept';

  enterRuleSpec: preprocessing-file:group?|module-file;
    enterRuleBlock: group?|module-file
      enterRuleAltList: group?|module-file
        enterLabeledAlt: group?
          enterAlternative: group?
            enterElement: group?
              => element -> [group]
              enterAtom: group
                enterRuleref: group
                exitRuleref: group
              exitAtom: group
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: group?
          exitAlternative: group?
        => elements -> ['[group]']
            => alternative -> [group]
        exitLabeledAlt: group?
        enterLabeledAlt: module-file
          enterAlternative: module-file
            enterElement: module-file
              => element -> {module-file}
              enterAtom: module-file
                enterRuleref: module-file
                exitRuleref: module-file
              exitAtom: module-file
            exitElement: module-file
          exitAlternative: module-file
        => elements -> ['{module-file}']
            => alternative -> {module-file}
        exitLabeledAlt: module-file
      exitRuleAltList: group?|module-file
    exitRuleBlock: group?|module-file
  exitRuleSpec: preprocessing-file:group?|module-file;

  enterRuleSpec: module-file:pp-global-module-fragment?pp-modulegroup?pp-private-module-fragment?;
    enterRuleBlock: pp-global-module-fragment?pp-modulegroup?pp-private-module-fragment?
      enterRuleAltList: pp-global-module-fragment?pp-modulegroup?pp-private-module-fragment?
        enterLabeledAlt: pp-global-module-fragment?pp-modulegroup?pp-private-module-fragment?
          enterAlternative: pp-global-module-fragment?pp-modulegroup?pp-private-module-fragment?
            enterElement: pp-global-module-fragment?
              => element -> [pp-global-module-fragment]
              enterAtom: pp-global-module-fragment
                enterRuleref: pp-global-module-fragment
                exitRuleref: pp-global-module-fragment
              exitAtom: pp-global-module-fragment
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: pp-global-module-fragment?
            enterElement: pp-module
              => element -> {pp-module}
              enterAtom: pp-module
                enterRuleref: pp-module
                exitRuleref: pp-module
              exitAtom: pp-module
            exitElement: pp-module
            enterElement: group?
              => element -> [group]
              enterAtom: group
                enterRuleref: group
                exitRuleref: group
              exitAtom: group
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: group?
            enterElement: pp-private-module-fragment?
              => element -> [pp-private-module-fragment]
              enterAtom: pp-private-module-fragment
                enterRuleref: pp-private-module-fragment
                exitRuleref: pp-private-module-fragment
              exitAtom: pp-private-module-fragment
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: pp-private-module-fragment?
          exitAlternative: pp-global-module-fragment?pp-modulegroup?pp-private-module-fragment?
        => elements -> ['[pp-global-module-fragment]', '{pp-module}', '[group]', '[pp-private-module-fragment]']
            => alternative -> [pp-global-module-fragment] {pp-module} [group] [pp-private-module-fragment]
        exitLabeledAlt: pp-global-module-fragment?pp-modulegroup?pp-private-module-fragment?
      exitRuleAltList: pp-global-module-fragment?pp-modulegroup?pp-private-module-fragment?
    exitRuleBlock: pp-global-module-fragment?pp-modulegroup?pp-private-module-fragment?
  exitRuleSpec: module-file:pp-global-module-fragment?pp-modulegroup?pp-private-module-fragment?;

  enterRuleSpec: pp-global-module-fragment:'module;'new-linegroup?;
    enterRuleBlock: 'module;'new-linegroup?
      enterRuleAltList: 'module;'new-linegroup?
        enterLabeledAlt: 'module;'new-linegroup?
          enterAlternative: 'module;'new-linegroup?
            enterElement: 'module;'
              => element -> module;
              enterAtom: 'module;'
                enterTerminal: 'module;'
                exitTerminal: 'module;'
              exitAtom: 'module;'
            exitElement: 'module;'
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
            enterElement: group?
              => element -> [group]
              enterAtom: group
                enterRuleref: group
                exitRuleref: group
              exitAtom: group
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: group?
          exitAlternative: 'module;'new-linegroup?
        => elements -> ['module;', '{new-line}', '[group]']
            => alternative -> module; {new-line} [group]
        exitLabeledAlt: 'module;'new-linegroup?
      exitRuleAltList: 'module;'new-linegroup?
    exitRuleBlock: 'module;'new-linegroup?
  exitRuleSpec: pp-global-module-fragment:'module;'new-linegroup?;

  enterRuleSpec: pp-private-module-fragment:'module : private;'new-linegroup?;
    enterRuleBlock: 'module : private;'new-linegroup?
      enterRuleAltList: 'module : private;'new-linegroup?
        enterLabeledAlt: 'module : private;'new-linegroup?
          enterAlternative: 'module : private;'new-linegroup?
            enterElement: 'module : private;'
              => element -> module : private;
              enterAtom: 'module : private;'
                enterTerminal: 'module : private;'
                exitTerminal: 'module : private;'
              exitAtom: 'module : private;'
            exitElement: 'module : private;'
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
            enterElement: group?
              => element -> [group]
              enterAtom: group
                enterRuleref: group
                exitRuleref: group
              exitAtom: group
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: group?
          exitAlternative: 'module : private;'new-linegroup?
        => elements -> ['module : private;', '{new-line}', '[group]']
            => alternative -> module : private; {new-line} [group]
        exitLabeledAlt: 'module : private;'new-linegroup?
      exitRuleAltList: 'module : private;'new-linegroup?
    exitRuleBlock: 'module : private;'new-linegroup?
  exitRuleSpec: pp-private-module-fragment:'module : private;'new-linegroup?;

  enterRuleSpec: group:group-part|groupgroup-part;
    enterRuleBlock: group-part|groupgroup-part
      enterRuleAltList: group-part|groupgroup-part
        enterLabeledAlt: group-part
          enterAlternative: group-part
            enterElement: group-part
              => element -> {group-part}
              enterAtom: group-part
                enterRuleref: group-part
                exitRuleref: group-part
              exitAtom: group-part
            exitElement: group-part
          exitAlternative: group-part
        => elements -> ['{group-part}']
            => alternative -> {group-part}
        exitLabeledAlt: group-part
        enterLabeledAlt: groupgroup-part
          enterAlternative: groupgroup-part
            enterElement: group
              => element -> {group}
              enterAtom: group
                enterRuleref: group
                exitRuleref: group
              exitAtom: group
            exitElement: group
            enterElement: group-part
              => element -> {group-part}
              enterAtom: group-part
                enterRuleref: group-part
                exitRuleref: group-part
              exitAtom: group-part
            exitElement: group-part
          exitAlternative: groupgroup-part
        => elements -> ['{group}', '{group-part}']
            => alternative -> {group} {group-part}
        exitLabeledAlt: groupgroup-part
      exitRuleAltList: group-part|groupgroup-part
    exitRuleBlock: group-part|groupgroup-part
  exitRuleSpec: group:group-part|groupgroup-part;

  enterRuleSpec: group-part:control-line|if-section|text-line|'#'conditionally-supported-directive;
    enterRuleBlock: control-line|if-section|text-line|'#'conditionally-supported-directive
      enterRuleAltList: control-line|if-section|text-line|'#'conditionally-supported-directive
        enterLabeledAlt: control-line
          enterAlternative: control-line
            enterElement: control-line
              => element -> {control-line}
              enterAtom: control-line
                enterRuleref: control-line
                exitRuleref: control-line
              exitAtom: control-line
            exitElement: control-line
          exitAlternative: control-line
        => elements -> ['{control-line}']
            => alternative -> {control-line}
        exitLabeledAlt: control-line
        enterLabeledAlt: if-section
          enterAlternative: if-section
            enterElement: if-section
              => element -> {if-section}
              enterAtom: if-section
                enterRuleref: if-section
                exitRuleref: if-section
              exitAtom: if-section
            exitElement: if-section
          exitAlternative: if-section
        => elements -> ['{if-section}']
            => alternative -> {if-section}
        exitLabeledAlt: if-section
        enterLabeledAlt: text-line
          enterAlternative: text-line
            enterElement: text-line
              => element -> {text-line}
              enterAtom: text-line
                enterRuleref: text-line
                exitRuleref: text-line
              exitAtom: text-line
            exitElement: text-line
          exitAlternative: text-line
        => elements -> ['{text-line}']
            => alternative -> {text-line}
        exitLabeledAlt: text-line
        enterLabeledAlt: '#'conditionally-supported-directive
          enterAlternative: '#'conditionally-supported-directive
            enterElement: '#'
              => element -> #
              enterAtom: '#'
                enterTerminal: '#'
                exitTerminal: '#'
              exitAtom: '#'
            exitElement: '#'
            enterElement: conditionally-supported-directive
              => element -> {conditionally-supported-directive}
              enterAtom: conditionally-supported-directive
                enterRuleref: conditionally-supported-directive
                exitRuleref: conditionally-supported-directive
              exitAtom: conditionally-supported-directive
            exitElement: conditionally-supported-directive
          exitAlternative: '#'conditionally-supported-directive
        => elements -> ['#', '{conditionally-supported-directive}']
            => alternative -> # {conditionally-supported-directive}
        exitLabeledAlt: '#'conditionally-supported-directive
      exitRuleAltList: control-line|if-section|text-line|'#'conditionally-supported-directive
    exitRuleBlock: control-line|if-section|text-line|'#'conditionally-supported-directive
  exitRuleSpec: group-part:control-line|if-section|text-line|'#'conditionally-supported-directive;

  enterRuleSpec: control-line:'#include'preprocessing-token+new-line|pp-import|'#define'identifierreplacement-listnew-line|'#define'identifierlparenidentifier*')'preprocessing-token*new-line|'#define'identifierlparen'...)'preprocessing-token*new-line|'#define'identifierlparenidentifier+',...)'preprocessing-token*new-line|'#undef'identifiernew-line|'#line'preprocessing-token+new-line|'#error'preprocessing-token*new-line|'#warning'preprocessing-token*new-line|'#pragma'preprocessing-token*new-line|'#'new-line;
    enterRuleBlock: '#include'preprocessing-token+new-line|pp-import|'#define'identifierreplacement-listnew-line|'#define'identifierlparenidentifier*')'preprocessing-token*new-line|'#define'identifierlparen'...)'preprocessing-token*new-line|'#define'identifierlparenidentifier+',...)'preprocessing-token*new-line|'#undef'identifiernew-line|'#line'preprocessing-token+new-line|'#error'preprocessing-token*new-line|'#warning'preprocessing-token*new-line|'#pragma'preprocessing-token*new-line|'#'new-line
      enterRuleAltList: '#include'preprocessing-token+new-line|pp-import|'#define'identifierreplacement-listnew-line|'#define'identifierlparenidentifier*')'preprocessing-token*new-line|'#define'identifierlparen'...)'preprocessing-token*new-line|'#define'identifierlparenidentifier+',...)'preprocessing-token*new-line|'#undef'identifiernew-line|'#line'preprocessing-token+new-line|'#error'preprocessing-token*new-line|'#warning'preprocessing-token*new-line|'#pragma'preprocessing-token*new-line|'#'new-line
        enterLabeledAlt: '#include'preprocessing-token+new-line
          enterAlternative: '#include'preprocessing-token+new-line
            enterElement: '#include'
              => element -> #include
              enterAtom: '#include'
                enterTerminal: '#include'
                exitTerminal: '#include'
              exitAtom: '#include'
            exitElement: '#include'
            enterElement: preprocessing-token+
              => element -> {preprocessing-token}...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: preprocessing-token+
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: '#include'preprocessing-token+new-line
        => elements -> ['#include', '{preprocessing-token}...', '{new-line}']
            => alternative -> #include {preprocessing-token}... {new-line}
        exitLabeledAlt: '#include'preprocessing-token+new-line
        enterLabeledAlt: pp-import
          enterAlternative: pp-import
            enterElement: pp-import
              => element -> {pp-import}
              enterAtom: pp-import
                enterRuleref: pp-import
                exitRuleref: pp-import
              exitAtom: pp-import
            exitElement: pp-import
          exitAlternative: pp-import
        => elements -> ['{pp-import}']
            => alternative -> {pp-import}
        exitLabeledAlt: pp-import
        enterLabeledAlt: '#define'identifierreplacement-listnew-line
          enterAlternative: '#define'identifierreplacement-listnew-line
            enterElement: '#define'
              => element -> #define
              enterAtom: '#define'
                enterTerminal: '#define'
                exitTerminal: '#define'
              exitAtom: '#define'
            exitElement: '#define'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: replacement-list
              => element -> {replacement-list}
              enterAtom: replacement-list
                enterRuleref: replacement-list
                exitRuleref: replacement-list
              exitAtom: replacement-list
            exitElement: replacement-list
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: '#define'identifierreplacement-listnew-line
        => elements -> ['#define', '{identifier}', '{replacement-list}', '{new-line}']
            => alternative -> #define {identifier} {replacement-list} {new-line}
        exitLabeledAlt: '#define'identifierreplacement-listnew-line
        enterLabeledAlt: '#define'identifierlparenidentifier*')'preprocessing-token*new-line
          enterAlternative: '#define'identifierlparenidentifier*')'preprocessing-token*new-line
            enterElement: '#define'
              => element -> #define
              enterAtom: '#define'
                enterTerminal: '#define'
                exitTerminal: '#define'
              exitAtom: '#define'
            exitElement: '#define'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: lparen
              => element -> {lparen}
              enterAtom: lparen
                enterRuleref: lparen
                exitRuleref: lparen
              exitAtom: lparen
            exitElement: lparen
            enterElement: identifier*
              => element -> [identifier]...
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: identifier*
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
            enterElement: preprocessing-token*
              => element -> [preprocessing-token]...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: preprocessing-token*
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: '#define'identifierlparenidentifier*')'preprocessing-token*new-line
        => elements -> ['#define', '{identifier}', '{lparen}', '[identifier]...', ')', '[preprocessing-token]...', '{new-line}']
            => alternative -> #define {identifier} {lparen} [identifier]... ) [preprocessing-token]... {new-line}
        exitLabeledAlt: '#define'identifierlparenidentifier*')'preprocessing-token*new-line
        enterLabeledAlt: '#define'identifierlparen'...)'preprocessing-token*new-line
          enterAlternative: '#define'identifierlparen'...)'preprocessing-token*new-line
            enterElement: '#define'
              => element -> #define
              enterAtom: '#define'
                enterTerminal: '#define'
                exitTerminal: '#define'
              exitAtom: '#define'
            exitElement: '#define'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: lparen
              => element -> {lparen}
              enterAtom: lparen
                enterRuleref: lparen
                exitRuleref: lparen
              exitAtom: lparen
            exitElement: lparen
            enterElement: '...)'
              => element -> ...)
              enterAtom: '...)'
                enterTerminal: '...)'
                exitTerminal: '...)'
              exitAtom: '...)'
            exitElement: '...)'
            enterElement: preprocessing-token*
              => element -> [preprocessing-token]...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: preprocessing-token*
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: '#define'identifierlparen'...)'preprocessing-token*new-line
        => elements -> ['#define', '{identifier}', '{lparen}', '...)', '[preprocessing-token]...', '{new-line}']
            => alternative -> #define {identifier} {lparen} ...) [preprocessing-token]... {new-line}
        exitLabeledAlt: '#define'identifierlparen'...)'preprocessing-token*new-line
        enterLabeledAlt: '#define'identifierlparenidentifier+',...)'preprocessing-token*new-line
          enterAlternative: '#define'identifierlparenidentifier+',...)'preprocessing-token*new-line
            enterElement: '#define'
              => element -> #define
              enterAtom: '#define'
                enterTerminal: '#define'
                exitTerminal: '#define'
              exitAtom: '#define'
            exitElement: '#define'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: lparen
              => element -> {lparen}
              enterAtom: lparen
                enterRuleref: lparen
                exitRuleref: lparen
              exitAtom: lparen
            exitElement: lparen
            enterElement: identifier+
              => element -> {identifier}...
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: identifier+
            enterElement: ',...)'
              => element -> ,...)
              enterAtom: ',...)'
                enterTerminal: ',...)'
                exitTerminal: ',...)'
              exitAtom: ',...)'
            exitElement: ',...)'
            enterElement: preprocessing-token*
              => element -> [preprocessing-token]...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: preprocessing-token*
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: '#define'identifierlparenidentifier+',...)'preprocessing-token*new-line
        => elements -> ['#define', '{identifier}', '{lparen}', '{identifier}...', ',...)', '[preprocessing-token]...', '{new-line}']
            => alternative -> #define {identifier} {lparen} {identifier}... ,...) [preprocessing-token]... {new-line}
        exitLabeledAlt: '#define'identifierlparenidentifier+',...)'preprocessing-token*new-line
        enterLabeledAlt: '#undef'identifiernew-line
          enterAlternative: '#undef'identifiernew-line
            enterElement: '#undef'
              => element -> #undef
              enterAtom: '#undef'
                enterTerminal: '#undef'
                exitTerminal: '#undef'
              exitAtom: '#undef'
            exitElement: '#undef'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: '#undef'identifiernew-line
        => elements -> ['#undef', '{identifier}', '{new-line}']
            => alternative -> #undef {identifier} {new-line}
        exitLabeledAlt: '#undef'identifiernew-line
        enterLabeledAlt: '#line'preprocessing-token+new-line
          enterAlternative: '#line'preprocessing-token+new-line
            enterElement: '#line'
              => element -> #line
              enterAtom: '#line'
                enterTerminal: '#line'
                exitTerminal: '#line'
              exitAtom: '#line'
            exitElement: '#line'
            enterElement: preprocessing-token+
              => element -> {preprocessing-token}...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: preprocessing-token+
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: '#line'preprocessing-token+new-line
        => elements -> ['#line', '{preprocessing-token}...', '{new-line}']
            => alternative -> #line {preprocessing-token}... {new-line}
        exitLabeledAlt: '#line'preprocessing-token+new-line
        enterLabeledAlt: '#error'preprocessing-token*new-line
          enterAlternative: '#error'preprocessing-token*new-line
            enterElement: '#error'
              => element -> #error
              enterAtom: '#error'
                enterTerminal: '#error'
                exitTerminal: '#error'
              exitAtom: '#error'
            exitElement: '#error'
            enterElement: preprocessing-token*
              => element -> [preprocessing-token]...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: preprocessing-token*
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: '#error'preprocessing-token*new-line
        => elements -> ['#error', '[preprocessing-token]...', '{new-line}']
            => alternative -> #error [preprocessing-token]... {new-line}
        exitLabeledAlt: '#error'preprocessing-token*new-line
        enterLabeledAlt: '#warning'preprocessing-token*new-line
          enterAlternative: '#warning'preprocessing-token*new-line
            enterElement: '#warning'
              => element -> #warning
              enterAtom: '#warning'
                enterTerminal: '#warning'
                exitTerminal: '#warning'
              exitAtom: '#warning'
            exitElement: '#warning'
            enterElement: preprocessing-token*
              => element -> [preprocessing-token]...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: preprocessing-token*
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: '#warning'preprocessing-token*new-line
        => elements -> ['#warning', '[preprocessing-token]...', '{new-line}']
            => alternative -> #warning [preprocessing-token]... {new-line}
        exitLabeledAlt: '#warning'preprocessing-token*new-line
        enterLabeledAlt: '#pragma'preprocessing-token*new-line
          enterAlternative: '#pragma'preprocessing-token*new-line
            enterElement: '#pragma'
              => element -> #pragma
              enterAtom: '#pragma'
                enterTerminal: '#pragma'
                exitTerminal: '#pragma'
              exitAtom: '#pragma'
            exitElement: '#pragma'
            enterElement: preprocessing-token*
              => element -> [preprocessing-token]...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: preprocessing-token*
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: '#pragma'preprocessing-token*new-line
        => elements -> ['#pragma', '[preprocessing-token]...', '{new-line}']
            => alternative -> #pragma [preprocessing-token]... {new-line}
        exitLabeledAlt: '#pragma'preprocessing-token*new-line
        enterLabeledAlt: '#'new-line
          enterAlternative: '#'new-line
            enterElement: '#'
              => element -> #
              enterAtom: '#'
                enterTerminal: '#'
                exitTerminal: '#'
              exitAtom: '#'
            exitElement: '#'
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: '#'new-line
        => elements -> ['#', '{new-line}']
            => alternative -> # {new-line}
        exitLabeledAlt: '#'new-line
      exitRuleAltList: '#include'preprocessing-token+new-line|pp-import|'#define'identifierreplacement-listnew-line|'#define'identifierlparenidentifier*')'preprocessing-token*new-line|'#define'identifierlparen'...)'preprocessing-token*new-line|'#define'identifierlparenidentifier+',...)'preprocessing-token*new-line|'#undef'identifiernew-line|'#line'preprocessing-token+new-line|'#error'preprocessing-token*new-line|'#warning'preprocessing-token*new-line|'#pragma'preprocessing-token*new-line|'#'new-line
    exitRuleBlock: '#include'preprocessing-token+new-line|pp-import|'#define'identifierreplacement-listnew-line|'#define'identifierlparenidentifier*')'preprocessing-token*new-line|'#define'identifierlparen'...)'preprocessing-token*new-line|'#define'identifierlparenidentifier+',...)'preprocessing-token*new-line|'#undef'identifiernew-line|'#line'preprocessing-token+new-line|'#error'preprocessing-token*new-line|'#warning'preprocessing-token*new-line|'#pragma'preprocessing-token*new-line|'#'new-line
  exitRuleSpec: control-line:'#include'preprocessing-token+new-line|pp-import|'#define'identifierreplacement-listnew-line|'#define'identifierlparenidentifier*')'preprocessing-token*new-line|'#define'identifierlparen'...)'preprocessing-token*new-line|'#define'identifierlparenidentifier+',...)'preprocessing-token*new-line|'#undef'identifiernew-line|'#line'preprocessing-token+new-line|'#error'preprocessing-token*new-line|'#warning'preprocessing-token*new-line|'#pragma'preprocessing-token*new-line|'#'new-line;

  enterRuleSpec: if-section:if-groupelif-groups?else-group?endif-line;
    enterRuleBlock: if-groupelif-groups?else-group?endif-line
      enterRuleAltList: if-groupelif-groups?else-group?endif-line
        enterLabeledAlt: if-groupelif-groups?else-group?endif-line
          enterAlternative: if-groupelif-groups?else-group?endif-line
            enterElement: if-group
              => element -> {if-group}
              enterAtom: if-group
                enterRuleref: if-group
                exitRuleref: if-group
              exitAtom: if-group
            exitElement: if-group
            enterElement: elif-groups?
              => element -> [elif-groups]
              enterAtom: elif-groups
                enterRuleref: elif-groups
                exitRuleref: elif-groups
              exitAtom: elif-groups
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: elif-groups?
            enterElement: else-group?
              => element -> [else-group]
              enterAtom: else-group
                enterRuleref: else-group
                exitRuleref: else-group
              exitAtom: else-group
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: else-group?
            enterElement: endif-line
              => element -> {endif-line}
              enterAtom: endif-line
                enterRuleref: endif-line
                exitRuleref: endif-line
              exitAtom: endif-line
            exitElement: endif-line
          exitAlternative: if-groupelif-groups?else-group?endif-line
        => elements -> ['{if-group}', '[elif-groups]', '[else-group]', '{endif-line}']
            => alternative -> {if-group} [elif-groups] [else-group] {endif-line}
        exitLabeledAlt: if-groupelif-groups?else-group?endif-line
      exitRuleAltList: if-groupelif-groups?else-group?endif-line
    exitRuleBlock: if-groupelif-groups?else-group?endif-line
  exitRuleSpec: if-section:if-groupelif-groups?else-group?endif-line;

  enterRuleSpec: if-group:'#if'constant-expressionnew-linegroup?|'#ifdef'identifiernew-linegroup?|'#ifndef'identifiernew-linegroup?;
    enterRuleBlock: '#if'constant-expressionnew-linegroup?|'#ifdef'identifiernew-linegroup?|'#ifndef'identifiernew-linegroup?
      enterRuleAltList: '#if'constant-expressionnew-linegroup?|'#ifdef'identifiernew-linegroup?|'#ifndef'identifiernew-linegroup?
        enterLabeledAlt: '#if'constant-expressionnew-linegroup?
          enterAlternative: '#if'constant-expressionnew-linegroup?
            enterElement: '#if'
              => element -> #if
              enterAtom: '#if'
                enterTerminal: '#if'
                exitTerminal: '#if'
              exitAtom: '#if'
            exitElement: '#if'
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
            enterElement: group?
              => element -> [group]
              enterAtom: group
                enterRuleref: group
                exitRuleref: group
              exitAtom: group
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: group?
          exitAlternative: '#if'constant-expressionnew-linegroup?
        => elements -> ['#if', '{constant-expression}', '{new-line}', '[group]']
            => alternative -> #if {constant-expression} {new-line} [group]
        exitLabeledAlt: '#if'constant-expressionnew-linegroup?
        enterLabeledAlt: '#ifdef'identifiernew-linegroup?
          enterAlternative: '#ifdef'identifiernew-linegroup?
            enterElement: '#ifdef'
              => element -> #ifdef
              enterAtom: '#ifdef'
                enterTerminal: '#ifdef'
                exitTerminal: '#ifdef'
              exitAtom: '#ifdef'
            exitElement: '#ifdef'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
            enterElement: group?
              => element -> [group]
              enterAtom: group
                enterRuleref: group
                exitRuleref: group
              exitAtom: group
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: group?
          exitAlternative: '#ifdef'identifiernew-linegroup?
        => elements -> ['#ifdef', '{identifier}', '{new-line}', '[group]']
            => alternative -> #ifdef {identifier} {new-line} [group]
        exitLabeledAlt: '#ifdef'identifiernew-linegroup?
        enterLabeledAlt: '#ifndef'identifiernew-linegroup?
          enterAlternative: '#ifndef'identifiernew-linegroup?
            enterElement: '#ifndef'
              => element -> #ifndef
              enterAtom: '#ifndef'
                enterTerminal: '#ifndef'
                exitTerminal: '#ifndef'
              exitAtom: '#ifndef'
            exitElement: '#ifndef'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
            enterElement: group?
              => element -> [group]
              enterAtom: group
                enterRuleref: group
                exitRuleref: group
              exitAtom: group
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: group?
          exitAlternative: '#ifndef'identifiernew-linegroup?
        => elements -> ['#ifndef', '{identifier}', '{new-line}', '[group]']
            => alternative -> #ifndef {identifier} {new-line} [group]
        exitLabeledAlt: '#ifndef'identifiernew-linegroup?
      exitRuleAltList: '#if'constant-expressionnew-linegroup?|'#ifdef'identifiernew-linegroup?|'#ifndef'identifiernew-linegroup?
    exitRuleBlock: '#if'constant-expressionnew-linegroup?|'#ifdef'identifiernew-linegroup?|'#ifndef'identifiernew-linegroup?
  exitRuleSpec: if-group:'#if'constant-expressionnew-linegroup?|'#ifdef'identifiernew-linegroup?|'#ifndef'identifiernew-linegroup?;

  enterRuleSpec: elif-groups:elif-group|elif-groupselif-group;
    enterRuleBlock: elif-group|elif-groupselif-group
      enterRuleAltList: elif-group|elif-groupselif-group
        enterLabeledAlt: elif-group
          enterAlternative: elif-group
            enterElement: elif-group
              => element -> {elif-group}
              enterAtom: elif-group
                enterRuleref: elif-group
                exitRuleref: elif-group
              exitAtom: elif-group
            exitElement: elif-group
          exitAlternative: elif-group
        => elements -> ['{elif-group}']
            => alternative -> {elif-group}
        exitLabeledAlt: elif-group
        enterLabeledAlt: elif-groupselif-group
          enterAlternative: elif-groupselif-group
            enterElement: elif-groups
              => element -> {elif-groups}
              enterAtom: elif-groups
                enterRuleref: elif-groups
                exitRuleref: elif-groups
              exitAtom: elif-groups
            exitElement: elif-groups
            enterElement: elif-group
              => element -> {elif-group}
              enterAtom: elif-group
                enterRuleref: elif-group
                exitRuleref: elif-group
              exitAtom: elif-group
            exitElement: elif-group
          exitAlternative: elif-groupselif-group
        => elements -> ['{elif-groups}', '{elif-group}']
            => alternative -> {elif-groups} {elif-group}
        exitLabeledAlt: elif-groupselif-group
      exitRuleAltList: elif-group|elif-groupselif-group
    exitRuleBlock: elif-group|elif-groupselif-group
  exitRuleSpec: elif-groups:elif-group|elif-groupselif-group;

  enterRuleSpec: elif-group:'#elif'constant-expressionnew-linegroup?|'#elifdef'identifiernew-linegroup?|'#elifndef'identifiernew-linegroup?;
    enterRuleBlock: '#elif'constant-expressionnew-linegroup?|'#elifdef'identifiernew-linegroup?|'#elifndef'identifiernew-linegroup?
      enterRuleAltList: '#elif'constant-expressionnew-linegroup?|'#elifdef'identifiernew-linegroup?|'#elifndef'identifiernew-linegroup?
        enterLabeledAlt: '#elif'constant-expressionnew-linegroup?
          enterAlternative: '#elif'constant-expressionnew-linegroup?
            enterElement: '#elif'
              => element -> #elif
              enterAtom: '#elif'
                enterTerminal: '#elif'
                exitTerminal: '#elif'
              exitAtom: '#elif'
            exitElement: '#elif'
            enterElement: constant-expression
              => element -> {constant-expression}
              enterAtom: constant-expression
                enterRuleref: constant-expression
                exitRuleref: constant-expression
              exitAtom: constant-expression
            exitElement: constant-expression
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
            enterElement: group?
              => element -> [group]
              enterAtom: group
                enterRuleref: group
                exitRuleref: group
              exitAtom: group
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: group?
          exitAlternative: '#elif'constant-expressionnew-linegroup?
        => elements -> ['#elif', '{constant-expression}', '{new-line}', '[group]']
            => alternative -> #elif {constant-expression} {new-line} [group]
        exitLabeledAlt: '#elif'constant-expressionnew-linegroup?
        enterLabeledAlt: '#elifdef'identifiernew-linegroup?
          enterAlternative: '#elifdef'identifiernew-linegroup?
            enterElement: '#elifdef'
              => element -> #elifdef
              enterAtom: '#elifdef'
                enterTerminal: '#elifdef'
                exitTerminal: '#elifdef'
              exitAtom: '#elifdef'
            exitElement: '#elifdef'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
            enterElement: group?
              => element -> [group]
              enterAtom: group
                enterRuleref: group
                exitRuleref: group
              exitAtom: group
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: group?
          exitAlternative: '#elifdef'identifiernew-linegroup?
        => elements -> ['#elifdef', '{identifier}', '{new-line}', '[group]']
            => alternative -> #elifdef {identifier} {new-line} [group]
        exitLabeledAlt: '#elifdef'identifiernew-linegroup?
        enterLabeledAlt: '#elifndef'identifiernew-linegroup?
          enterAlternative: '#elifndef'identifiernew-linegroup?
            enterElement: '#elifndef'
              => element -> #elifndef
              enterAtom: '#elifndef'
                enterTerminal: '#elifndef'
                exitTerminal: '#elifndef'
              exitAtom: '#elifndef'
            exitElement: '#elifndef'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
            enterElement: group?
              => element -> [group]
              enterAtom: group
                enterRuleref: group
                exitRuleref: group
              exitAtom: group
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: group?
          exitAlternative: '#elifndef'identifiernew-linegroup?
        => elements -> ['#elifndef', '{identifier}', '{new-line}', '[group]']
            => alternative -> #elifndef {identifier} {new-line} [group]
        exitLabeledAlt: '#elifndef'identifiernew-linegroup?
      exitRuleAltList: '#elif'constant-expressionnew-linegroup?|'#elifdef'identifiernew-linegroup?|'#elifndef'identifiernew-linegroup?
    exitRuleBlock: '#elif'constant-expressionnew-linegroup?|'#elifdef'identifiernew-linegroup?|'#elifndef'identifiernew-linegroup?
  exitRuleSpec: elif-group:'#elif'constant-expressionnew-linegroup?|'#elifdef'identifiernew-linegroup?|'#elifndef'identifiernew-linegroup?;

  enterRuleSpec: else-group:'#else'new-linegroup?;
    enterRuleBlock: '#else'new-linegroup?
      enterRuleAltList: '#else'new-linegroup?
        enterLabeledAlt: '#else'new-linegroup?
          enterAlternative: '#else'new-linegroup?
            enterElement: '#else'
              => element -> #else
              enterAtom: '#else'
                enterTerminal: '#else'
                exitTerminal: '#else'
              exitAtom: '#else'
            exitElement: '#else'
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
            enterElement: group?
              => element -> [group]
              enterAtom: group
                enterRuleref: group
                exitRuleref: group
              exitAtom: group
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: group?
          exitAlternative: '#else'new-linegroup?
        => elements -> ['#else', '{new-line}', '[group]']
            => alternative -> #else {new-line} [group]
        exitLabeledAlt: '#else'new-linegroup?
      exitRuleAltList: '#else'new-linegroup?
    exitRuleBlock: '#else'new-linegroup?
  exitRuleSpec: else-group:'#else'new-linegroup?;

  enterRuleSpec: endif-line:'#endif'new-line;
    enterRuleBlock: '#endif'new-line
      enterRuleAltList: '#endif'new-line
        enterLabeledAlt: '#endif'new-line
          enterAlternative: '#endif'new-line
            enterElement: '#endif'
              => element -> #endif
              enterAtom: '#endif'
                enterTerminal: '#endif'
                exitTerminal: '#endif'
              exitAtom: '#endif'
            exitElement: '#endif'
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: '#endif'new-line
        => elements -> ['#endif', '{new-line}']
            => alternative -> #endif {new-line}
        exitLabeledAlt: '#endif'new-line
      exitRuleAltList: '#endif'new-line
    exitRuleBlock: '#endif'new-line
  exitRuleSpec: endif-line:'#endif'new-line;

  enterRuleSpec: text-line:preprocessing-token*new-line;
    enterRuleBlock: preprocessing-token*new-line
      enterRuleAltList: preprocessing-token*new-line
        enterLabeledAlt: preprocessing-token*new-line
          enterAlternative: preprocessing-token*new-line
            enterElement: preprocessing-token*
              => element -> [preprocessing-token]...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: preprocessing-token*
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: preprocessing-token*new-line
        => elements -> ['[preprocessing-token]...', '{new-line}']
            => alternative -> [preprocessing-token]... {new-line}
        exitLabeledAlt: preprocessing-token*new-line
      exitRuleAltList: preprocessing-token*new-line
    exitRuleBlock: preprocessing-token*new-line
  exitRuleSpec: text-line:preprocessing-token*new-line;

  enterRuleSpec: conditionally-supported-directive:preprocessing-token+new-line;
    enterRuleBlock: preprocessing-token+new-line
      enterRuleAltList: preprocessing-token+new-line
        enterLabeledAlt: preprocessing-token+new-line
          enterAlternative: preprocessing-token+new-line
            enterElement: preprocessing-token+
              => element -> {preprocessing-token}...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: preprocessing-token+
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: preprocessing-token+new-line
        => elements -> ['{preprocessing-token}...', '{new-line}']
            => alternative -> {preprocessing-token}... {new-line}
        exitLabeledAlt: preprocessing-token+new-line
      exitRuleAltList: preprocessing-token+new-line
    exitRuleBlock: preprocessing-token+new-line
  exitRuleSpec: conditionally-supported-directive:preprocessing-token+new-line;

  enterRuleSpec: lparen:'<<<Enter a ( character not immediately preceded by whitespace.>>>';
    enterRuleBlock: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
      enterRuleAltList: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
        enterLabeledAlt: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
          enterAlternative: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
            enterElement: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
              => element -> <<<Enter a ( character not immediately preceded by whitespace.>>>
              enterAtom: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
                enterTerminal: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
                exitTerminal: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
              exitAtom: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
            exitElement: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
          exitAlternative: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
        => elements -> ['<<<Enter a ( character not immediately preceded by whitespace.>>>']
            => alternative -> <<<Enter a ( character not immediately preceded by whitespace.>>>
        exitLabeledAlt: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
      exitRuleAltList: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
    exitRuleBlock: '<<<Enter a ( character not immediately preceded by whitespace.>>>'
  exitRuleSpec: lparen:'<<<Enter a ( character not immediately preceded by whitespace.>>>';

  enterRuleSpec: new-line:'<<<Enter the new-line \\n character.>>>';
    enterRuleBlock: '<<<Enter the new-line \\n character.>>>'
      enterRuleAltList: '<<<Enter the new-line \\n character.>>>'
        enterLabeledAlt: '<<<Enter the new-line \\n character.>>>'
          enterAlternative: '<<<Enter the new-line \\n character.>>>'
            enterElement: '<<<Enter the new-line \\n character.>>>'
              => element -> <<<Enter the new-line \\n character.>>>
              enterAtom: '<<<Enter the new-line \\n character.>>>'
                enterTerminal: '<<<Enter the new-line \\n character.>>>'
                exitTerminal: '<<<Enter the new-line \\n character.>>>'
              exitAtom: '<<<Enter the new-line \\n character.>>>'
            exitElement: '<<<Enter the new-line \\n character.>>>'
          exitAlternative: '<<<Enter the new-line \\n character.>>>'
        => elements -> ['<<<Enter the new-line \\\\n character.>>>']
            => alternative -> <<<Enter the new-line \\n character.>>>
        exitLabeledAlt: '<<<Enter the new-line \\n character.>>>'
      exitRuleAltList: '<<<Enter the new-line \\n character.>>>'
    exitRuleBlock: '<<<Enter the new-line \\n character.>>>'
  exitRuleSpec: new-line:'<<<Enter the new-line \\n character.>>>';

  enterRuleSpec: defined-macro-expression:'defined'identifier|'defined('identifier')';
    enterRuleBlock: 'defined'identifier|'defined('identifier')'
      enterRuleAltList: 'defined'identifier|'defined('identifier')'
        enterLabeledAlt: 'defined'identifier
          enterAlternative: 'defined'identifier
            enterElement: 'defined'
              => element -> defined
              enterAtom: 'defined'
                enterTerminal: 'defined'
                exitTerminal: 'defined'
              exitAtom: 'defined'
            exitElement: 'defined'
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
          exitAlternative: 'defined'identifier
        => elements -> ['defined', '{identifier}']
            => alternative -> defined {identifier}
        exitLabeledAlt: 'defined'identifier
        enterLabeledAlt: 'defined('identifier')'
          enterAlternative: 'defined('identifier')'
            enterElement: 'defined('
              => element -> defined(
              enterAtom: 'defined('
                enterTerminal: 'defined('
                exitTerminal: 'defined('
              exitAtom: 'defined('
            exitElement: 'defined('
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: 'defined('identifier')'
        => elements -> ['defined(', '{identifier}', ')']
            => alternative -> defined( {identifier} )
        exitLabeledAlt: 'defined('identifier')'
      exitRuleAltList: 'defined'identifier|'defined('identifier')'
    exitRuleBlock: 'defined'identifier|'defined('identifier')'
  exitRuleSpec: defined-macro-expression:'defined'identifier|'defined('identifier')';

  enterRuleSpec: header-name-tokens:string-literal|'<'h-preprocessing-token+'>';
    enterRuleBlock: string-literal|'<'h-preprocessing-token+'>'
      enterRuleAltList: string-literal|'<'h-preprocessing-token+'>'
        enterLabeledAlt: string-literal
          enterAlternative: string-literal
            enterElement: string-literal
              => element -> {string-literal}
              enterAtom: string-literal
                enterRuleref: string-literal
                exitRuleref: string-literal
              exitAtom: string-literal
            exitElement: string-literal
          exitAlternative: string-literal
        => elements -> ['{string-literal}']
            => alternative -> {string-literal}
        exitLabeledAlt: string-literal
        enterLabeledAlt: '<'h-preprocessing-token+'>'
          enterAlternative: '<'h-preprocessing-token+'>'
            enterElement: '<'
              => element -> <
              enterAtom: '<'
                enterTerminal: '<'
                exitTerminal: '<'
              exitAtom: '<'
            exitElement: '<'
            enterElement: h-preprocessing-token+
              => element -> {h-preprocessing-token}...
              enterAtom: h-preprocessing-token
                enterRuleref: h-preprocessing-token
                exitRuleref: h-preprocessing-token
              exitAtom: h-preprocessing-token
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: h-preprocessing-token+
            enterElement: '>'
              => element -> >
              enterAtom: '>'
                enterTerminal: '>'
                exitTerminal: '>'
              exitAtom: '>'
            exitElement: '>'
          exitAlternative: '<'h-preprocessing-token+'>'
        => elements -> ['<', '{h-preprocessing-token}...', '>']
            => alternative -> < {h-preprocessing-token}... >
        exitLabeledAlt: '<'h-preprocessing-token+'>'
      exitRuleAltList: string-literal|'<'h-preprocessing-token+'>'
    exitRuleBlock: string-literal|'<'h-preprocessing-token+'>'
  exitRuleSpec: header-name-tokens:string-literal|'<'h-preprocessing-token+'>';

  enterRuleSpec: has-include-expression:'__has_include('header-name')'|'__has_include('header-name-tokens')';
    enterRuleBlock: '__has_include('header-name')'|'__has_include('header-name-tokens')'
      enterRuleAltList: '__has_include('header-name')'|'__has_include('header-name-tokens')'
        enterLabeledAlt: '__has_include('header-name')'
          enterAlternative: '__has_include('header-name')'
            enterElement: '__has_include('
              => element -> __has_include(
              enterAtom: '__has_include('
                enterTerminal: '__has_include('
                exitTerminal: '__has_include('
              exitAtom: '__has_include('
            exitElement: '__has_include('
            enterElement: header-name
              => element -> {header-name}
              enterAtom: header-name
                enterRuleref: header-name
                exitRuleref: header-name
              exitAtom: header-name
            exitElement: header-name
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '__has_include('header-name')'
        => elements -> ['__has_include(', '{header-name}', ')']
            => alternative -> __has_include( {header-name} )
        exitLabeledAlt: '__has_include('header-name')'
        enterLabeledAlt: '__has_include('header-name-tokens')'
          enterAlternative: '__has_include('header-name-tokens')'
            enterElement: '__has_include('
              => element -> __has_include(
              enterAtom: '__has_include('
                enterTerminal: '__has_include('
                exitTerminal: '__has_include('
              exitAtom: '__has_include('
            exitElement: '__has_include('
            enterElement: header-name-tokens
              => element -> {header-name-tokens}
              enterAtom: header-name-tokens
                enterRuleref: header-name-tokens
                exitRuleref: header-name-tokens
              exitAtom: header-name-tokens
            exitElement: header-name-tokens
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '__has_include('header-name-tokens')'
        => elements -> ['__has_include(', '{header-name-tokens}', ')']
            => alternative -> __has_include( {header-name-tokens} )
        exitLabeledAlt: '__has_include('header-name-tokens')'
      exitRuleAltList: '__has_include('header-name')'|'__has_include('header-name-tokens')'
    exitRuleBlock: '__has_include('header-name')'|'__has_include('header-name-tokens')'
  exitRuleSpec: has-include-expression:'__has_include('header-name')'|'__has_include('header-name-tokens')';

  enterRuleSpec: has-attribute-expression:'__has_cpp_attribute('preprocessing-token+')';
    enterRuleBlock: '__has_cpp_attribute('preprocessing-token+')'
      enterRuleAltList: '__has_cpp_attribute('preprocessing-token+')'
        enterLabeledAlt: '__has_cpp_attribute('preprocessing-token+')'
          enterAlternative: '__has_cpp_attribute('preprocessing-token+')'
            enterElement: '__has_cpp_attribute('
              => element -> __has_cpp_attribute(
              enterAtom: '__has_cpp_attribute('
                enterTerminal: '__has_cpp_attribute('
                exitTerminal: '__has_cpp_attribute('
              exitAtom: '__has_cpp_attribute('
            exitElement: '__has_cpp_attribute('
            enterElement: preprocessing-token+
              => element -> {preprocessing-token}...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: preprocessing-token+
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '__has_cpp_attribute('preprocessing-token+')'
        => elements -> ['__has_cpp_attribute(', '{preprocessing-token}...', ')']
            => alternative -> __has_cpp_attribute( {preprocessing-token}... )
        exitLabeledAlt: '__has_cpp_attribute('preprocessing-token+')'
      exitRuleAltList: '__has_cpp_attribute('preprocessing-token+')'
    exitRuleBlock: '__has_cpp_attribute('preprocessing-token+')'
  exitRuleSpec: has-attribute-expression:'__has_cpp_attribute('preprocessing-token+')';

  enterRuleSpec: export:'export';
    enterRuleBlock: 'export'
      enterRuleAltList: 'export'
        enterLabeledAlt: 'export'
          enterAlternative: 'export'
            enterElement: 'export'
              => element -> export
              enterAtom: 'export'
                enterTerminal: 'export'
                exitTerminal: 'export'
              exitAtom: 'export'
            exitElement: 'export'
          exitAlternative: 'export'
        => elements -> ['export']
            => alternative -> export
        exitLabeledAlt: 'export'
      exitRuleAltList: 'export'
    exitRuleBlock: 'export'
  exitRuleSpec: export:'export';

  enterRuleSpec: pp-module:export?'module'preprocessing-token*';'new-line;
    enterRuleBlock: export?'module'preprocessing-token*';'new-line
      enterRuleAltList: export?'module'preprocessing-token*';'new-line
        enterLabeledAlt: export?'module'preprocessing-token*';'new-line
          enterAlternative: export?'module'preprocessing-token*';'new-line
            enterElement: export?
              => element -> [export]
              enterAtom: export
                enterRuleref: export
                exitRuleref: export
              exitAtom: export
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: export?
            enterElement: 'module'
              => element -> module
              enterAtom: 'module'
                enterTerminal: 'module'
                exitTerminal: 'module'
              exitAtom: 'module'
            exitElement: 'module'
            enterElement: preprocessing-token*
              => element -> [preprocessing-token]...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: preprocessing-token*
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: export?'module'preprocessing-token*';'new-line
        => elements -> ['[export]', 'module', '[preprocessing-token]...', ';', '{new-line}']
            => alternative -> [export] module [preprocessing-token]... ; {new-line}
        exitLabeledAlt: export?'module'preprocessing-token*';'new-line
      exitRuleAltList: export?'module'preprocessing-token*';'new-line
    exitRuleBlock: export?'module'preprocessing-token*';'new-line
  exitRuleSpec: pp-module:export?'module'preprocessing-token*';'new-line;

  enterRuleSpec: pp-import:export?'import'header-namepreprocessing-token*';'new-line|export?'import'header-name-tokenspreprocessing-token*';'new-line|export?'import'preprocessing-token+';'new-line;
    enterRuleBlock: export?'import'header-namepreprocessing-token*';'new-line|export?'import'header-name-tokenspreprocessing-token*';'new-line|export?'import'preprocessing-token+';'new-line
      enterRuleAltList: export?'import'header-namepreprocessing-token*';'new-line|export?'import'header-name-tokenspreprocessing-token*';'new-line|export?'import'preprocessing-token+';'new-line
        enterLabeledAlt: export?'import'header-namepreprocessing-token*';'new-line
          enterAlternative: export?'import'header-namepreprocessing-token*';'new-line
            enterElement: export?
              => element -> [export]
              enterAtom: export
                enterRuleref: export
                exitRuleref: export
              exitAtom: export
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: export?
            enterElement: 'import'
              => element -> import
              enterAtom: 'import'
                enterTerminal: 'import'
                exitTerminal: 'import'
              exitAtom: 'import'
            exitElement: 'import'
            enterElement: header-name
              => element -> {header-name}
              enterAtom: header-name
                enterRuleref: header-name
                exitRuleref: header-name
              exitAtom: header-name
            exitElement: header-name
            enterElement: preprocessing-token*
              => element -> [preprocessing-token]...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: preprocessing-token*
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: export?'import'header-namepreprocessing-token*';'new-line
        => elements -> ['[export]', 'import', '{header-name}', '[preprocessing-token]...', ';', '{new-line}']
            => alternative -> [export] import {header-name} [preprocessing-token]... ; {new-line}
        exitLabeledAlt: export?'import'header-namepreprocessing-token*';'new-line
        enterLabeledAlt: export?'import'header-name-tokenspreprocessing-token*';'new-line
          enterAlternative: export?'import'header-name-tokenspreprocessing-token*';'new-line
            enterElement: export?
              => element -> [export]
              enterAtom: export
                enterRuleref: export
                exitRuleref: export
              exitAtom: export
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: export?
            enterElement: 'import'
              => element -> import
              enterAtom: 'import'
                enterTerminal: 'import'
                exitTerminal: 'import'
              exitAtom: 'import'
            exitElement: 'import'
            enterElement: header-name-tokens
              => element -> {header-name-tokens}
              enterAtom: header-name-tokens
                enterRuleref: header-name-tokens
                exitRuleref: header-name-tokens
              exitAtom: header-name-tokens
            exitElement: header-name-tokens
            enterElement: preprocessing-token*
              => element -> [preprocessing-token]...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: preprocessing-token*
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: export?'import'header-name-tokenspreprocessing-token*';'new-line
        => elements -> ['[export]', 'import', '{header-name-tokens}', '[preprocessing-token]...', ';', '{new-line}']
            => alternative -> [export] import {header-name-tokens} [preprocessing-token]... ; {new-line}
        exitLabeledAlt: export?'import'header-name-tokenspreprocessing-token*';'new-line
        enterLabeledAlt: export?'import'preprocessing-token+';'new-line
          enterAlternative: export?'import'preprocessing-token+';'new-line
            enterElement: export?
              => element -> [export]
              enterAtom: export
                enterRuleref: export
                exitRuleref: export
              exitAtom: export
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: export?
            enterElement: 'import'
              => element -> import
              enterAtom: 'import'
                enterTerminal: 'import'
                exitTerminal: 'import'
              exitAtom: 'import'
            exitElement: 'import'
            enterElement: preprocessing-token+
              => element -> {preprocessing-token}...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: +
              exitEbnfSuffix: +
            exitElement: preprocessing-token+
            enterElement: ';'
              => element -> ;
              enterAtom: ';'
                enterTerminal: ';'
                exitTerminal: ';'
              exitAtom: ';'
            exitElement: ';'
            enterElement: new-line
              => element -> {new-line}
              enterAtom: new-line
                enterRuleref: new-line
                exitRuleref: new-line
              exitAtom: new-line
            exitElement: new-line
          exitAlternative: export?'import'preprocessing-token+';'new-line
        => elements -> ['[export]', 'import', '{preprocessing-token}...', ';', '{new-line}']
            => alternative -> [export] import {preprocessing-token}... ; {new-line}
        exitLabeledAlt: export?'import'preprocessing-token+';'new-line
      exitRuleAltList: export?'import'header-namepreprocessing-token*';'new-line|export?'import'header-name-tokenspreprocessing-token*';'new-line|export?'import'preprocessing-token+';'new-line
    exitRuleBlock: export?'import'header-namepreprocessing-token*';'new-line|export?'import'header-name-tokenspreprocessing-token*';'new-line|export?'import'preprocessing-token+';'new-line
  exitRuleSpec: pp-import:export?'import'header-namepreprocessing-token*';'new-line|export?'import'header-name-tokenspreprocessing-token*';'new-line|export?'import'preprocessing-token+';'new-line;

  enterRuleSpec: va-replacement:'__VA-OPT__('preprocessing-token*')';
    enterRuleBlock: '__VA-OPT__('preprocessing-token*')'
      enterRuleAltList: '__VA-OPT__('preprocessing-token*')'
        enterLabeledAlt: '__VA-OPT__('preprocessing-token*')'
          enterAlternative: '__VA-OPT__('preprocessing-token*')'
            enterElement: '__VA-OPT__('
              => element -> __VA-OPT__(
              enterAtom: '__VA-OPT__('
                enterTerminal: '__VA-OPT__('
                exitTerminal: '__VA-OPT__('
              exitAtom: '__VA-OPT__('
            exitElement: '__VA-OPT__('
            enterElement: preprocessing-token*
              => element -> [preprocessing-token]...
              enterAtom: preprocessing-token
                enterRuleref: preprocessing-token
                exitRuleref: preprocessing-token
              exitAtom: preprocessing-token
              enterEbnfSuffix: *
              exitEbnfSuffix: *
            exitElement: preprocessing-token*
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '__VA-OPT__('preprocessing-token*')'
        => elements -> ['__VA-OPT__(', '[preprocessing-token]...', ')']
            => alternative -> __VA-OPT__( [preprocessing-token]... )
        exitLabeledAlt: '__VA-OPT__('preprocessing-token*')'
      exitRuleAltList: '__VA-OPT__('preprocessing-token*')'
    exitRuleBlock: '__VA-OPT__('preprocessing-token*')'
  exitRuleSpec: va-replacement:'__VA-OPT__('preprocessing-token*')';

  enterRuleSpec: ms-call-modifier:'__cdecl'|'__clrcall'|'__stdcall'|'__fastcall'|'__thiscall'|'__vectorcall';
    enterRuleBlock: '__cdecl'|'__clrcall'|'__stdcall'|'__fastcall'|'__thiscall'|'__vectorcall'
      enterRuleAltList: '__cdecl'|'__clrcall'|'__stdcall'|'__fastcall'|'__thiscall'|'__vectorcall'
        enterLabeledAlt: '__cdecl'
          enterAlternative: '__cdecl'
            enterElement: '__cdecl'
              => element -> __cdecl
              enterAtom: '__cdecl'
                enterTerminal: '__cdecl'
                exitTerminal: '__cdecl'
              exitAtom: '__cdecl'
            exitElement: '__cdecl'
          exitAlternative: '__cdecl'
        => elements -> ['__cdecl']
            => alternative -> __cdecl
        exitLabeledAlt: '__cdecl'
        enterLabeledAlt: '__clrcall'
          enterAlternative: '__clrcall'
            enterElement: '__clrcall'
              => element -> __clrcall
              enterAtom: '__clrcall'
                enterTerminal: '__clrcall'
                exitTerminal: '__clrcall'
              exitAtom: '__clrcall'
            exitElement: '__clrcall'
          exitAlternative: '__clrcall'
        => elements -> ['__clrcall']
            => alternative -> __clrcall
        exitLabeledAlt: '__clrcall'
        enterLabeledAlt: '__stdcall'
          enterAlternative: '__stdcall'
            enterElement: '__stdcall'
              => element -> __stdcall
              enterAtom: '__stdcall'
                enterTerminal: '__stdcall'
                exitTerminal: '__stdcall'
              exitAtom: '__stdcall'
            exitElement: '__stdcall'
          exitAlternative: '__stdcall'
        => elements -> ['__stdcall']
            => alternative -> __stdcall
        exitLabeledAlt: '__stdcall'
        enterLabeledAlt: '__fastcall'
          enterAlternative: '__fastcall'
            enterElement: '__fastcall'
              => element -> __fastcall
              enterAtom: '__fastcall'
                enterTerminal: '__fastcall'
                exitTerminal: '__fastcall'
              exitAtom: '__fastcall'
            exitElement: '__fastcall'
          exitAlternative: '__fastcall'
        => elements -> ['__fastcall']
            => alternative -> __fastcall
        exitLabeledAlt: '__fastcall'
        enterLabeledAlt: '__thiscall'
          enterAlternative: '__thiscall'
            enterElement: '__thiscall'
              => element -> __thiscall
              enterAtom: '__thiscall'
                enterTerminal: '__thiscall'
                exitTerminal: '__thiscall'
              exitAtom: '__thiscall'
            exitElement: '__thiscall'
          exitAlternative: '__thiscall'
        => elements -> ['__thiscall']
            => alternative -> __thiscall
        exitLabeledAlt: '__thiscall'
        enterLabeledAlt: '__vectorcall'
          enterAlternative: '__vectorcall'
            enterElement: '__vectorcall'
              => element -> __vectorcall
              enterAtom: '__vectorcall'
                enterTerminal: '__vectorcall'
                exitTerminal: '__vectorcall'
              exitAtom: '__vectorcall'
            exitElement: '__vectorcall'
          exitAlternative: '__vectorcall'
        => elements -> ['__vectorcall']
            => alternative -> __vectorcall
        exitLabeledAlt: '__vectorcall'
      exitRuleAltList: '__cdecl'|'__clrcall'|'__stdcall'|'__fastcall'|'__thiscall'|'__vectorcall'
    exitRuleBlock: '__cdecl'|'__clrcall'|'__stdcall'|'__fastcall'|'__thiscall'|'__vectorcall'
  exitRuleSpec: ms-call-modifier:'__cdecl'|'__clrcall'|'__stdcall'|'__fastcall'|'__thiscall'|'__vectorcall';

  enterRuleSpec: ms-call-modifier-seq:ms-call-modifierms-call-modifier-seq?;
    enterRuleBlock: ms-call-modifierms-call-modifier-seq?
      enterRuleAltList: ms-call-modifierms-call-modifier-seq?
        enterLabeledAlt: ms-call-modifierms-call-modifier-seq?
          enterAlternative: ms-call-modifierms-call-modifier-seq?
            enterElement: ms-call-modifier
              => element -> {ms-call-modifier}
              enterAtom: ms-call-modifier
                enterRuleref: ms-call-modifier
                exitRuleref: ms-call-modifier
              exitAtom: ms-call-modifier
            exitElement: ms-call-modifier
            enterElement: ms-call-modifier-seq?
              => element -> [ms-call-modifier-seq]
              enterAtom: ms-call-modifier-seq
                enterRuleref: ms-call-modifier-seq
                exitRuleref: ms-call-modifier-seq
              exitAtom: ms-call-modifier-seq
              enterEbnfSuffix: ?
              exitEbnfSuffix: ?
            exitElement: ms-call-modifier-seq?
          exitAlternative: ms-call-modifierms-call-modifier-seq?
        => elements -> ['{ms-call-modifier}', '[ms-call-modifier-seq]']
            => alternative -> {ms-call-modifier} [ms-call-modifier-seq]
        exitLabeledAlt: ms-call-modifierms-call-modifier-seq?
      exitRuleAltList: ms-call-modifierms-call-modifier-seq?
    exitRuleBlock: ms-call-modifierms-call-modifier-seq?
  exitRuleSpec: ms-call-modifier-seq:ms-call-modifierms-call-modifier-seq?;

  enterRuleSpec: ms-pointer-modifier:'__restrict'|'__uptr'|'__sptr'|'_unaligned'|'__unaligned';
    enterRuleBlock: '__restrict'|'__uptr'|'__sptr'|'_unaligned'|'__unaligned'
      enterRuleAltList: '__restrict'|'__uptr'|'__sptr'|'_unaligned'|'__unaligned'
        enterLabeledAlt: '__restrict'
          enterAlternative: '__restrict'
            enterElement: '__restrict'
              => element -> __restrict
              enterAtom: '__restrict'
                enterTerminal: '__restrict'
                exitTerminal: '__restrict'
              exitAtom: '__restrict'
            exitElement: '__restrict'
          exitAlternative: '__restrict'
        => elements -> ['__restrict']
            => alternative -> __restrict
        exitLabeledAlt: '__restrict'
        enterLabeledAlt: '__uptr'
          enterAlternative: '__uptr'
            enterElement: '__uptr'
              => element -> __uptr
              enterAtom: '__uptr'
                enterTerminal: '__uptr'
                exitTerminal: '__uptr'
              exitAtom: '__uptr'
            exitElement: '__uptr'
          exitAlternative: '__uptr'
        => elements -> ['__uptr']
            => alternative -> __uptr
        exitLabeledAlt: '__uptr'
        enterLabeledAlt: '__sptr'
          enterAlternative: '__sptr'
            enterElement: '__sptr'
              => element -> __sptr
              enterAtom: '__sptr'
                enterTerminal: '__sptr'
                exitTerminal: '__sptr'
              exitAtom: '__sptr'
            exitElement: '__sptr'
          exitAlternative: '__sptr'
        => elements -> ['__sptr']
            => alternative -> __sptr
        exitLabeledAlt: '__sptr'
        enterLabeledAlt: '_unaligned'
          enterAlternative: '_unaligned'
            enterElement: '_unaligned'
              => element -> _unaligned
              enterAtom: '_unaligned'
                enterTerminal: '_unaligned'
                exitTerminal: '_unaligned'
              exitAtom: '_unaligned'
            exitElement: '_unaligned'
          exitAlternative: '_unaligned'
        => elements -> ['_unaligned']
            => alternative -> _unaligned
        exitLabeledAlt: '_unaligned'
        enterLabeledAlt: '__unaligned'
          enterAlternative: '__unaligned'
            enterElement: '__unaligned'
              => element -> __unaligned
              enterAtom: '__unaligned'
                enterTerminal: '__unaligned'
                exitTerminal: '__unaligned'
              exitAtom: '__unaligned'
            exitElement: '__unaligned'
          exitAlternative: '__unaligned'
        => elements -> ['__unaligned']
            => alternative -> __unaligned
        exitLabeledAlt: '__unaligned'
      exitRuleAltList: '__restrict'|'__uptr'|'__sptr'|'_unaligned'|'__unaligned'
    exitRuleBlock: '__restrict'|'__uptr'|'__sptr'|'_unaligned'|'__unaligned'
  exitRuleSpec: ms-pointer-modifier:'__restrict'|'__uptr'|'__sptr'|'_unaligned'|'__unaligned';

  enterRuleSpec: ms-declspec-modifier:'__declspec('identifier')';
    enterRuleBlock: '__declspec('identifier')'
      enterRuleAltList: '__declspec('identifier')'
        enterLabeledAlt: '__declspec('identifier')'
          enterAlternative: '__declspec('identifier')'
            enterElement: '__declspec('
              => element -> __declspec(
              enterAtom: '__declspec('
                enterTerminal: '__declspec('
                exitTerminal: '__declspec('
              exitAtom: '__declspec('
            exitElement: '__declspec('
            enterElement: identifier
              => element -> {identifier}
              enterAtom: identifier
                enterRuleref: identifier
                exitRuleref: identifier
              exitAtom: identifier
            exitElement: identifier
            enterElement: ')'
              => element -> )
              enterAtom: ')'
                enterTerminal: ')'
                exitTerminal: ')'
              exitAtom: ')'
            exitElement: ')'
          exitAlternative: '__declspec('identifier')'
        => elements -> ['__declspec(', '{identifier}', ')']
            => alternative -> __declspec( {identifier} )
        exitLabeledAlt: '__declspec('identifier')'
      exitRuleAltList: '__declspec('identifier')'
    exitRuleBlock: '__declspec('identifier')'
  exitRuleSpec: ms-declspec-modifier:'__declspec('identifier')';

attribute-specifier -> , 
placeholder_name: typedef-name
placeholder_name: namespace-name
placeholder_name: namespace-alias
placeholder_name: class-name
placeholder_name: enum-name
placeholder_name: template-name
placeholder_name: n-char
placeholder_name: named-universal-character
placeholder_name: hexadecimal-digit
placeholder_name: hex-quad
placeholder_name: hex-quad-quad
placeholder_name: universal-character-name
placeholder_name: non-whitespace-character-literal
placeholder_name: preprocessing-token
placeholder_name: token
placeholder_name: h-char
placeholder_name: q-char
placeholder_name: header-name
placeholder_name: pp-number
placeholder_name: identifier
placeholder_name: translation-character-xid-start
placeholder_name: translation-character-xid-continue
placeholder_name: identifier-start
placeholder_name: identifier-continue
placeholder_name: nondigit
placeholder_name: digit
placeholder_name: keyword
placeholder_name: preprocessing-op-or-punc
placeholder_name: preprocessing-operator
placeholder_name: operator-or-punctuator
placeholder_name: literal
placeholder_name: integer-literal
placeholder_name: simple-quote-char
placeholder_name: binary-literal
placeholder_name: octal-literal
placeholder_name: decimal-literal
placeholder_name: hexadecimal-literal
placeholder_name: binary-digit
placeholder_name: octal-digit
placeholder_name: nonzero-digit
placeholder_name: hexadecimal-prefix
placeholder_name: hexadecimal-digit-sequence
placeholder_name: integer-suffix
placeholder_name: unsigned-suffix
placeholder_name: long-suffix
placeholder_name: long-long-suffix
placeholder_name: size-suffix
placeholder_name: character-literal
placeholder_name: encoding-prefix
placeholder_name: c-char
placeholder_name: basic-c-char
placeholder_name: escape-sequence
placeholder_name: simple-escape-sequence
placeholder_name: simple-escape-sequence-char
placeholder_name: numeric-escape-sequence
placeholder_name: octal-escape-sequence
placeholder_name: hexadecimal-escape-sequence
placeholder_name: conditional-escape-sequence
placeholder_name: conditional-escape-sequence-char
placeholder_name: floating-point-literal
placeholder_name: decimal-floating-point-literal
placeholder_name: hexadecimal-floating-point-literal
placeholder_name: fractional-constant
placeholder_name: hexadecimal-fractional-constant
placeholder_name: exponent-part
placeholder_name: binary-exponent-part
placeholder_name: sign
placeholder_name: digit-sequence
placeholder_name: floating-point-suffix
placeholder_name: string-literal
placeholder_name: s-char
placeholder_name: basic-s-char
placeholder_name: raw-string
placeholder_name: r-char
placeholder_name: d-char
placeholder_name: boolean-literal
placeholder_name: pointer-literal
placeholder_name: user-defined-literal
placeholder_name: user-defined-integer-literal
placeholder_name: user-defined-floating-point-literal
placeholder_name: user-defined-string-literal
placeholder_name: user-defined-character-literal
placeholder_name: ud-suffix
placeholder_name: translation-unit
placeholder_name: primary-expression
placeholder_name: id-expression
placeholder_name: unqualified-id
placeholder_name: template
placeholder_name: qualified-id
placeholder_name: nested-name-specifier
placeholder_name: pack-index-expression
placeholder_name: lambda-expression
placeholder_name: lambda-introducer
placeholder_name: lambda-declarator
placeholder_name: lambda-specifier
placeholder_name: lambda-capture
placeholder_name: capture-default
placeholder_name: capture-list
placeholder_name: capture
placeholder_name: simple-capture
placeholder_name: and-three-dots
placeholder_name: init-capture
placeholder_name: fold-expression
placeholder_name: fold-operator
placeholder_name: requires-expression
placeholder_name: requirement-parameter-list
placeholder_name: requirement-body
placeholder_name: requirement
placeholder_name: simple-requirement
placeholder_name: type-requirement
placeholder_name: compound-requirement
placeholder_name: return-type-requirement
placeholder_name: nested-requirement
placeholder_name: dot-template
placeholder_name: arrow-template
placeholder_name: postfix-expression
placeholder_name: expression-list
placeholder_name: unary-expression
placeholder_name: unary-operator
placeholder_name: await-expression
placeholder_name: noexcept-expression
placeholder_name: nesting-operator
placeholder_name: new-expression
placeholder_name: new-placement
placeholder_name: new-type-id
placeholder_name: new-declarator
placeholder_name: noptr-new-declarator
placeholder_name: new-initializer
placeholder_name: delete-expression
placeholder_name: cast-expression
placeholder_name: pm-expression
placeholder_name: multiplicative-expression
placeholder_name: additive-expression
placeholder_name: shift-expression
placeholder_name: compare-expression
placeholder_name: relational-expression
placeholder_name: equality-expression
placeholder_name: and-expression
placeholder_name: exclusive-or-expression
placeholder_name: inclusive-or-expression
placeholder_name: logical-and-expression
placeholder_name: logical-or-expression
placeholder_name: conditional-expression
placeholder_name: yield-expression
placeholder_name: throw-expression
placeholder_name: assignment-expression
placeholder_name: assignment-operator
placeholder_name: expression
placeholder_name: constant-expression
placeholder_name: statement
placeholder_name: init-statement
placeholder_name: condition
placeholder_name: label
placeholder_name: labeled-statement
placeholder_name: expression-statement
placeholder_name: compound-statement
placeholder_name: if-constexpr
placeholder_name: if-exlamation-mark
placeholder_name: selection-statement
placeholder_name: iteration-statement
placeholder_name: for-range-declaration
placeholder_name: for-range-initializer
placeholder_name: jump-statement
placeholder_name: coroutine-return-statement
placeholder_name: declaration-statement
placeholder_name: declaration
placeholder_name: name-declaration
placeholder_name: special-declaration
placeholder_name: block-declaration
placeholder_name: nodeclspec-function-declaration
placeholder_name: alias-declaration
placeholder_name: simple-declaration
placeholder_name: static-assert-declaration
placeholder_name: empty-declaration
placeholder_name: attribute-declaration
placeholder_name: decl-specifier
placeholder_name: decl-specifier-seq
placeholder_name: storage-class-specifier
placeholder_name: function-specifier
placeholder_name: explicit-specifier
placeholder_name: type-specifier
placeholder_name: type-specifier-seq
placeholder_name: defining-type-specifier
placeholder_name: defining-type-specifier-seq
placeholder_name: simple-type-specifier
placeholder_name: type-name
placeholder_name: computed-type-specifier
placeholder_name: pack-index-specifier
placeholder_name: elaborated-type-specifier
placeholder_name: decltype-specifier
placeholder_name: placeholder-type-specifier
placeholder_name: init-declarator-list
placeholder_name: init-declarator
placeholder_name: declarator
placeholder_name: ptr-declarator
placeholder_name: noptr-declarator
placeholder_name: parameters-and-qualifiers
placeholder_name: trailing-return-type
placeholder_name: ptr-operator
placeholder_name: cv-qualifier
placeholder_name: ref-qualifier
placeholder_name: three-dots
placeholder_name: declarator-id
placeholder_name: type-id
placeholder_name: defining-type-id
placeholder_name: abstract-declarator
placeholder_name: ptr-abstract-declarator
placeholder_name: noptr-abstract-declarator
placeholder_name: abstract-pack-declarator
placeholder_name: noptr-abstract-pack-declarator
placeholder_name: parameter-declaration-clause
placeholder_name: parameter-declaration-list
placeholder_name: this
placeholder_name: parameter-declaration
placeholder_name: initializer
placeholder_name: brace-or-equal-initializer
placeholder_name: initializer-clause
placeholder_name: comma
placeholder_name: braced-init-list
placeholder_name: initializer-list
placeholder_name: designated-initializer-list
placeholder_name: designated-initializer-clause
placeholder_name: designator
placeholder_name: expr-or-braced-init-list
placeholder_name: function-definition
placeholder_name: function-body
placeholder_name: enum-specifier
placeholder_name: enum-head
placeholder_name: enum-head-name
placeholder_name: opaque-enum-declaration
placeholder_name: enum-key
placeholder_name: enum-base
placeholder_name: enumerator-list
placeholder_name: enumerator-definition
placeholder_name: enumerator
placeholder_name: using-enum-declaration
placeholder_name: using-enum-declarator
placeholder_name: namespace-definition
placeholder_name: inline
placeholder_name: nested-inline
placeholder_name: named-namespace-definition
placeholder_name: unnamed-namespace-definition
placeholder_name: nested-namespace-definition
placeholder_name: enclosing-namespace-specifier
placeholder_name: namespace-body
placeholder_name: namespace-alias-definition
placeholder_name: qualified-namespace-specifier
placeholder_name: using-directive
placeholder_name: using-declaration
placeholder_name: using-declarator-list
placeholder_name: typename
placeholder_name: using-declarator
placeholder_name: asm-declaration
placeholder_name: linkage-specification
placeholder_name: attribute-specifier
placeholder_name: alignment-specifier
placeholder_name: attribute-using-prefix
placeholder_name: attribute-list
placeholder_name: attribute
placeholder_name: attribute-token
placeholder_name: attribute-scoped-token
placeholder_name: attribute-namespace
placeholder_name: attribute-argument-clause
placeholder_name: balanced-token-seq
placeholder_name: non_balanced_token
placeholder_name: balanced-token
placeholder_name: module-declaration
placeholder_name: module-name
placeholder_name: module-partition
placeholder_name: module-name-qualifier
placeholder_name: export-declaration
placeholder_name: module-import-declaration
placeholder_name: global-module-fragment
placeholder_name: -module-fragment
placeholder_name: class-specifier
placeholder_name: class-head
placeholder_name: class-head-name
placeholder_name: class-virt-specifier
placeholder_name: class-key
placeholder_name: member-specification
placeholder_name: member-declaration
placeholder_name: member-declarator-list
placeholder_name: member-declarator
placeholder_name: virt-specifier-seq
placeholder_name: virt-specifier
placeholder_name: pure-specifier
placeholder_name: conversion-function-id
placeholder_name: conversion-type-id
placeholder_name: conversion-declarator
placeholder_name: base-clause
placeholder_name: base-specifier-list
placeholder_name: virtual
placeholder_name: base-specifier
placeholder_name: class-or-decltype
placeholder_name: access-specifier
placeholder_name: ctor-initializer
placeholder_name: mem-initializer-list
placeholder_name: mem-initializer
placeholder_name: mem-initializer-id
placeholder_name: operator-function-id
placeholder_name: operator
placeholder_name: literal-operator-id
placeholder_name: template-declaration
placeholder_name: template-head
placeholder_name: template-parameter-list
placeholder_name: requires-clause
placeholder_name: constraint-logical-or-expression
placeholder_name: constraint-logical-and-expression
placeholder_name: template-parameter
placeholder_name: type-parameter
placeholder_name: type-parameter-key
placeholder_name: type-constraint
placeholder_name: simple-template-id
placeholder_name: template-id
placeholder_name: template-argument-list
placeholder_name: template-argument
placeholder_name: constraint-expression
placeholder_name: deduction-guide
placeholder_name: concept-definition
placeholder_name: concept-name
placeholder_name: typename-specifier
placeholder_name: extern
placeholder_name: explicit-instantiation
placeholder_name: explicit-specialization
placeholder_name: try-block
placeholder_name: function-try-block
placeholder_name: handler-seq
placeholder_name: handler
placeholder_name: exception-declaration
placeholder_name: noexcept-specifier
placeholder_name: preprocessing-file
placeholder_name: module-file
placeholder_name: pp-global-module-fragment
placeholder_name: pp-private-module-fragment
placeholder_name: group
placeholder_name: group-part
placeholder_name: control-line
placeholder_name: if-section
placeholder_name: if-group
placeholder_name: elif-groups
placeholder_name: elif-group
placeholder_name: else-group
placeholder_name: endif-line
placeholder_name: text-line
placeholder_name: conditionally-supported-directive
placeholder_name: lparen
placeholder_name: new-line
placeholder_name: defined-macro-expression
placeholder_name: header-name-tokens
placeholder_name: has-include-expression
placeholder_name: has-attribute-expression
placeholder_name: export
placeholder_name: pp-module
placeholder_name: pp-import
placeholder_name: va-replacement
placeholder_name: ms-call-modifier
placeholder_name: ms-call-modifier-seq
placeholder_name: ms-pointer-modifier
placeholder_name: ms-declspec-modifier
    => createElseMenuPlaceholder -> typedef-name ->
      => identifier
      => simple-template-id
    => createElseMenuPlaceholder -> namespace-name ->
      => identifier
      => namespace-alias
    => createElseNonTerminalPlaceholder -> namespace-alias -> {identifier}
    => createElseMenuPlaceholder -> class-name ->
      => identifier
      => simple-template-id
    => createElseNonTerminalPlaceholder -> enum-name -> {identifier}
    => createElseNonTerminalPlaceholder -> template-name -> {identifier}
    => createElseTerminalPlaceholder -> n-char
    => createElseNonTerminalPlaceholder -> named-universal-character -> \\N{ {n-char} }
    => createElseMenuPlaceholder -> hexadecimal-digit ->
      => 0
      => 1
      => 2
      => 3
      => 4
      => 5
      => 6
      => 7
      => 8
      => 9
      => a
      => b
      => c
      => d
      => e
      => f
      => A
      => B
      => C
      => D
      => E
      => F
    => createElseTerminalPlaceholder -> hex-quad
    => createElseTerminalPlaceholder -> hex-quad-quad
    => createElseMenuPlaceholder -> universal-character-name ->
      => \\u {hex-quad}
      => \\U {hex-quad-quad}
      => \\u{ {hexadecimal-digit} }
      => named-universal-character
    => createElseTerminalPlaceholder -> non-whitespace-character-literal
    => createElseMenuPlaceholder -> preprocessing-token ->
      => header-name
      => {import-keyword}
      => {module-keyword}
      => {export-keyword}
      => identifier
      => pp-number
      => character-literal
      => user-defined-character-literal
      => string-literal
      => user-defined-string-literal
      => preprocessing-op-or-punc
      => non-whitespace-character-literal
    => createElseMenuPlaceholder -> token ->
      => identifier
      => keyword
      => literal
      => operator-or-punctuator
    => createElseTerminalPlaceholder -> h-char
    => createElseTerminalPlaceholder -> q-char
    => createElseMenuPlaceholder -> header-name ->
      => < {h-char} >
      => " {q-char} "
    => createElseMenuPlaceholder -> pp-number ->
      => digit
      => . {digit}
      => {pp-number} {digit}
      => {pp-number} {identifier-nondigit}
      => {pp-number} \' {digit}
      => {pp-number} \' {nondigit}
      => {pp-number} e {sign}
      => {pp-number} E {sign}
      => {pp-number} p {sign}
      => {pp-number} P {sign}
      => {pp-number} .
    => createElseMenuPlaceholder -> identifier ->
      => identifier-start
      => {identifier} {identifier-continue}
    => createElseTerminalPlaceholder -> translation-character-xid-start
    => createElseTerminalPlaceholder -> translation-character-xid-continue
    => createElseMenuPlaceholder -> identifier-start ->
      => nondigit
      => translation-character-xid-start
    => createElseMenuPlaceholder -> identifier-continue ->
      => digit
      => nondigit
      => translation-character-xid-continue
    => createElseMenuPlaceholder -> nondigit ->
      => a
      => b
      => c
      => d
      => e
      => f
      => g
      => h
      => i
      => j
      => k
      => l
      => m
      => n
      => o
      => p
      => q
      => r
      => s
      => t
      => u
      => v
      => w
      => x
      => y
      => z
      => A
      => B
      => C
      => D
      => E
      => F
      => G
      => H
      => I
      => J
      => K
      => L
      => M
      => N
      => O
      => P
      => Q
      => R
      => S
      => T
      => U
      => V
      => W
      => X
      => Y
      => Z
      => _
    => createElseMenuPlaceholder -> digit ->
      => 0
      => 1
      => 2
      => 3
      => 4
      => 5
      => 6
      => 7
      => 8
      => 9
    => createElseMenuPlaceholder -> keyword ->
      => alignas
      => alignof
      => asm
      => auto
      => bool
      => break
      => case
      => catch
      => char
      => char8_t
      => char16_t
      => char32_t
      => class
      => concept
      => const
      => consteval
      => constexpr
      => constinit
      => const_cast
      => continue
      => co_await
      => co_return
      => co_yield
      => decltype
      => default
      => delete
      => do
      => double
      => dynamic_cast
      => else
      => enum
      => explicit
      => export
      => extern
      => false
      => float
      => for
      => friend
      => goto
      => if
      => inline
      => int
      => long
      => mutable
      => namespace
      => new
      => noexcept
      => nullptr
      => operator
      => private
      => protected
      => public
      => register
      => reinterpret_cast
      => requires
      => return
      => short
      => signed
      => sizeof
      => static
      => static_assert
      => static_cast
      => struct
      => switch
      => template
      => this
      => thread_local
      => throw
      => true
      => try
      => typedef
      => typeid
      => typename
      => union
      => unsigned
      => using
      => virtual
      => void
      => volatile
      => wchar_t
      => while
      => {import-keyword}
      => {module-keyword}
      => {export-keyword}
    => createElseMenuPlaceholder -> preprocessing-op-or-punc ->
      => preprocessing-operator
      => operator-or-punctuator
    => createElseMenuPlaceholder -> preprocessing-operator ->
      => #
      => ##
      => %:
      => %:%:
    => createElseMenuPlaceholder -> operator-or-punctuator ->
      => {
      => }
      => [
      => ]
      => (
      => )
      => <:
      => :>
      => <%
      => %>
      => ;
      => :
      => ...
      => ?
      => ::
      => .
      => .*
      => ->
      => ->*
      => ~
      => !
      => +
      => -
      => *
      => /
      => %
      => ^
      => &
      => |
      => =
      => +=
      => -=
      => *=
      => /=
      => %=
      => ^=
      => &=
      => |=
      => ==
      => !=
      => <
      => >
      => <=
      => >=
      => <=>
      => &&
      => ||
      => <<
      => >>
      => <<=
      => >>=
      => ++
      => --
      => 
      => and
      => or
      => xor
      => not
      => bitand
      => bitor
      => compl
      => and_eq
      => or_eq
      => xor_eq
      => not_eq
    => createElseMenuPlaceholder -> literal ->
      => integer-literal
      => character-literal
      => floating-point-literal
      => string-literal
      => boolean-literal
      => pointer-literal
      => user-defined-literal
    => createElseMenuPlaceholder -> integer-literal ->
      => {binary-literal} [integer-suffix]
      => {octal-literal} [integer-suffix]
      => {decimal-literal} [integer-suffix]
      => {hexadecimal-literal} [integer-suffix]
    => createElseNonTerminalPlaceholder -> simple-quote-char -> \'
    => createElseMenuPlaceholder -> binary-literal ->
      => 0b {binary-digit}
      => 0B {binary-digit}
      => {binary-literal} [simple-quote-char] {binary-digit}
    => createElseMenuPlaceholder -> octal-literal ->
      => 0
      => {octal-literal} [simple-quote-char] {octal-digit}
    => createElseMenuPlaceholder -> decimal-literal ->
      => nonzero-digit
      => {decimal-literal} [simple-quote-char] {digit}
    => createElseNonTerminalPlaceholder -> hexadecimal-literal -> {hexadecimal-prefix} {hexadecimal-digit-sequence}
    => createElseMenuPlaceholder -> binary-digit ->
      => 0
      => 1
    => createElseMenuPlaceholder -> octal-digit ->
      => 0
      => 1
      => 2
      => 3
      => 4
      => 5
      => 6
      => 7
    => createElseMenuPlaceholder -> nonzero-digit ->
      => 1
      => 2
      => 3
      => 4
      => 5
      => 6
      => 7
      => 8
      => 9
    => createElseMenuPlaceholder -> hexadecimal-prefix ->
      => 0x
      => 0X
    => createElseMenuPlaceholder -> hexadecimal-digit-sequence ->
      => hexadecimal-digit
      => {hexadecimal-digit-sequence} [simple-quote-char] {hexadecimal-digit}
    => createElseMenuPlaceholder -> integer-suffix ->
      => {unsigned-suffix} [long-suffix]
      => {unsigned-suffix} [long-long-suffix]
      => {unsigned-suffix} [size-suffix]
      => {long-suffix} [unsigned-suffix]
      => {long-long-suffix} [unsigned-suffix]
      => {size-suffix} [unsigned-suffix]
    => createElseMenuPlaceholder -> unsigned-suffix ->
      => u
      => U
    => createElseMenuPlaceholder -> long-suffix ->
      => l
      => L
    => createElseMenuPlaceholder -> long-long-suffix ->
      => ll
      => LL
    => createElseMenuPlaceholder -> size-suffix ->
      => z
      => Z
    => createElseNonTerminalPlaceholder -> character-literal -> [encoding-prefix] \' {c-char}... \'
    => createElseMenuPlaceholder -> encoding-prefix ->
      => u8
      => u
      => U
      => L
    => createElseMenuPlaceholder -> c-char ->
      => basic-c-char
      => escape-sequence
      => universal-character-name
    => createElseTerminalPlaceholder -> basic-c-char
    => createElseMenuPlaceholder -> escape-sequence ->
      => simple-escape-sequence
      => numeric-escape-sequence
      => conditional-escape-sequence
    => createElseNonTerminalPlaceholder -> simple-escape-sequence -> \\ {simple-escape-sequence-char}
    => createElseMenuPlaceholder -> simple-escape-sequence-char ->
      => \'
      => "
      => ?
      => \\
      => a
      => b
      => f
      => n
      => r
      => t
      => v
    => createElseMenuPlaceholder -> numeric-escape-sequence ->
      => octal-escape-sequence
      => hexadecimal-escape-sequence
    => createElseMenuPlaceholder -> octal-escape-sequence ->
      => \\ {octal-digit}
      => \\ {octal-digit} {octal-digit}
      => \\ {octal-digit} {octal-digit} {octal-digit}
      => \\o{ {octal-digit}... }
    => createElseMenuPlaceholder -> hexadecimal-escape-sequence ->
      => \\x {hexadecimal-digit}
      => \\x{ {hexadecimal-digit} }
    => createElseNonTerminalPlaceholder -> conditional-escape-sequence -> \\ {conditional-escape-sequence-char}
    => createElseTerminalPlaceholder -> conditional-escape-sequence-char
    => createElseMenuPlaceholder -> floating-point-literal ->
      => decimal-floating-point-literal
      => hexadecimal-floating-point-literal
    => createElseMenuPlaceholder -> decimal-floating-point-literal ->
      => {fractional-constant} [exponent-part] [floating-point-suffix]
      => {digit-sequence} {exponent-part} [floating-point-suffix]
    => createElseMenuPlaceholder -> hexadecimal-floating-point-literal ->
      => {hexadecimal-prefix} {hexadecimal-fractional-constant} {binary-exponent-part} [floating-point-suffix]
      => {hexadecimal-prefix} {hexadecimal-digit-sequence} {binary-exponent-part} [floating-point-suffix]
    => createElseMenuPlaceholder -> fractional-constant ->
      => [digit-sequence] . {digit-sequence}
      => {digit-sequence} .
    => createElseMenuPlaceholder -> hexadecimal-fractional-constant ->
      => [hexadecimal-digit-sequence] . {hexadecimal-digit-sequence}
      => {hexadecimal-digit-sequence} .
    => createElseMenuPlaceholder -> exponent-part ->
      => e [sign] {digit-sequence}
      => E [sign] {digit-sequence}
    => createElseMenuPlaceholder -> binary-exponent-part ->
      => p [sign] {digit-sequence}
      => P [sign] {digit-sequence}
    => createElseMenuPlaceholder -> sign ->
      => +
      => -
    => createElseMenuPlaceholder -> digit-sequence ->
      => digit
      => {digit-sequence} [simple-quote-char] {digit}
    => createElseMenuPlaceholder -> floating-point-suffix ->
      => f
      => l
      => f16
      => f32
      => f64
      => f128
      => bf16
      => F
      => L
      => F16
      => F32
      => F64
      => F128
      => BF16
    => createElseMenuPlaceholder -> string-literal ->
      => [encoding-prefix] " [s-char]... "
      => [encoding-prefix] R {raw-string}
    => createElseMenuPlaceholder -> s-char ->
      => basic-s-char
      => escape-sequence
      => universal-character-name
    => createElseTerminalPlaceholder -> basic-s-char
    => createElseNonTerminalPlaceholder -> raw-string -> " [d-char]... ( [r-char]... ) [d-char]... "
    => createElseTerminalPlaceholder -> r-char
    => createElseTerminalPlaceholder -> d-char
    => createElseMenuPlaceholder -> boolean-literal ->
      => false
      => true
    => createElseNonTerminalPlaceholder -> pointer-literal -> nullptr
    => createElseMenuPlaceholder -> user-defined-literal ->
      => user-defined-integer-literal
      => user-defined-floating-point-literal
      => user-defined-string-literal
      => user-defined-character-literal
    => createElseMenuPlaceholder -> user-defined-integer-literal ->
      => {decimal-literal} {ud-suffix}
      => {octal-literal} {ud-suffix}
      => {hexadecimal-literal} {ud-suffix}
      => {binary-literal} {ud-suffix}
    => createElseMenuPlaceholder -> user-defined-floating-point-literal ->
      => {fractional-constant} [exponent-part] {ud-suffix}
      => {digit-sequence} {exponent-part} {ud-suffix}
      => {hexadecimal-prefix} {hexadecimal-fractional-constant} {binary-exponent-part} {ud-suffix}
      => {hexadecimal-prefix} {hexadecimal-digit-sequence} {binary-exponent-part} {ud-suffix}
    => createElseNonTerminalPlaceholder -> user-defined-string-literal -> {string-literal} {ud-suffix}
    => createElseNonTerminalPlaceholder -> user-defined-character-literal -> {character-literal} {ud-suffix}
    => createElseNonTerminalPlaceholder -> ud-suffix -> {identifier}
    => createElseMenuPlaceholder -> translation-unit ->
      => [declaration]...
      => [global-module-fragment] {module-declaration} [declaration]... [private-module-fragment]
    => createElseMenuPlaceholder -> primary-expression ->
      => literal
      => this
      => ( {expression} )
      => id-expression
      => lambda-expression
      => fold-expression
      => requires-expression
    => createElseMenuPlaceholder -> id-expression ->
      => unqualified-id
      => qualified-id
      => pack-index-expression
    => createElseMenuPlaceholder -> unqualified-id ->
      => identifier
      => operator-function-id
      => conversion-function-id
      => literal-operator-id
      => ~ {type-name}
      => ~ {computed-type-specifier}
      => template-id
    => createElseNonTerminalPlaceholder -> template -> template
    => createElseNonTerminalPlaceholder -> qualified-id -> {nested-name-specifier} [template] {unqualified-id}
    => createElseMenuPlaceholder -> nested-name-specifier ->
      => ::
      => {type-name} ::
      => {namespace-name} ::
      => {computed-type-specifier} ::
      => {nested-name-specifier} {identifier} ::
      => {nested-name-specifier} [template] {simple-template-id} ::
    => createElseNonTerminalPlaceholder -> pack-index-expression -> {id-expression} ... [ {constant-expression} ]
    => createElseMenuPlaceholder -> lambda-expression ->
      => {lambda-introducer} [attribute-specifier]... {lambda-declarator} {compound-statement}
      => {lambda-introducer} < {template-parameter-list} > [requires-clause] [attribute-specifier]... {lambda-declarator} {compound-statement}
    => createElseNonTerminalPlaceholder -> lambda-introducer -> [ [lambda-capture] ]
    => createElseMenuPlaceholder -> lambda-declarator ->
      => {lambda-specifier}... [noexcept-specifier] [attribute-specifier]... [trailing-return-type]
      => {noexcept-specifier} [attribute-specifier]... [trailing-return-type]
      => trailing-return-type
      => ( {parameter-declaration-clause} ) [lambda-specifier]... [noexcept-specifier] [attribute-specifier]... [trailing-return-type] [requires-clause]
    => createElseMenuPlaceholder -> lambda-specifier ->
      => consteval
      => constexpr
      => mutable
      => static
    => createElseMenuPlaceholder -> lambda-capture ->
      => capture-default
      => capture-list
      => {capture-default} , {capture-list}
    => createElseMenuPlaceholder -> capture-default ->
      => &
      => =
    => createElseMenuPlaceholder -> capture-list ->
      => capture
      => {capture-list} , {capture}
    => createElseMenuPlaceholder -> capture ->
      => simple-capture
      => init-capture
    => createElseMenuPlaceholder -> simple-capture ->
      => {identifier} [three-dots]
      => & {identifier} [three-dots]
      => this
      => *this
    => createElseNonTerminalPlaceholder -> and-three-dots -> & ...
    => createElseMenuPlaceholder -> init-capture ->
      => [three-dots] {identifier} {initializer}
      => [and-three-dots] {identifier} {initializer}
    => createElseMenuPlaceholder -> fold-expression ->
      => ( {cast-expression} {fold-operator} ...)
      => (... {fold-operator} {cast-expression} )
      => ( {cast-expression} {fold-operator} ... {fold-operator} {cast-expression} )
    => createElseMenuPlaceholder -> fold-operator ->
      => +
      => -
      => *
      => /
      => %
      => ^
      => &
      => |
      => <<
      => >>
      => +=
      => -=
      => *=
      => /=
      => %=
      => ^=
      => &=
      => |=
      => <<=
      => >>=
      => =
      => ==
      => !=
      => <
      => >
      => <=
      => >=
      => &&
      => ||
      => 
      => .*
      => ->*
    => createElseNonTerminalPlaceholder -> requires-expression -> requires [requirement-parameter-list] {requirement-body}
    => createElseNonTerminalPlaceholder -> requirement-parameter-list -> ( {parameter-declaration-clause} )
    => createElseNonTerminalPlaceholder -> requirement-body -> { {requirement}... }
    => createElseMenuPlaceholder -> requirement ->
      => simple-requirement
      => type-requirement
      => compound-requirement
      => nested-requirement
    => createElseNonTerminalPlaceholder -> simple-requirement -> {expression} ;
    => createElseNonTerminalPlaceholder -> type-requirement -> typename [nested-name-specifier] {type-name} ;
    => createElseNonTerminalPlaceholder -> compound-requirement -> { {expression} } [noexcept] [return-type-requirement] ;
    => createElseNonTerminalPlaceholder -> return-type-requirement -> -> {type-constraint}
    => createElseNonTerminalPlaceholder -> nested-requirement -> requires {constraint-expression} ;
    => createElseNonTerminalPlaceholder -> dot-template -> .template
    => createElseNonTerminalPlaceholder -> arrow-template -> ->template
    => createElseMenuPlaceholder -> postfix-expression ->
      => primary-expression
      => {postfix-expression} [ [expression-list] ]
      => {postfix-expression} ( [expression-list] )
      => {simple-type-specifier} ( [expression-list] )
      => {typename-specifier} ( [expression-list] )
      => {simple-type-specifier} {braced-init-list}
      => {typename-specifier} {braced-init-list}
      => {postfix-expression} [dot-template] {id-expression}
      => {postfix-expression} [arrow-template] {id-expression}
      => {postfix-expression} ++
      => {postfix-expression} --
      => dynamic-cast< {type-id} >( {expression} )
      => static-cast< {type-id} >( {expression} )
      => reinterpret-cast< {type-id} >( {expression} )
      => const-cast< {type-id} >( {expression} )
      => typeid( {expression} )
      => typeid( {type-id} )
    => createElseNonTerminalPlaceholder -> expression-list -> {initializer-list}
    => createElseMenuPlaceholder -> unary-expression ->
      => postfix-expression
      => {unary-operator} {cast-expression}
      => ++ {cast-expression}
      => -- {cast-expression}
      => await-expression
      => sizeof {unary-expression}
      => sizeof( {type-id} )
      => sizeof...( {identifier} )
      => alignof( {type-id} )
      => noexcept-expression
      => new-expression
      => delete-expression
    => createElseMenuPlaceholder -> unary-operator ->
      => *
      => &
      => +
      => -
      => !
      => ~
    => createElseNonTerminalPlaceholder -> await-expression -> co_await {cast-expression}
    => createElseNonTerminalPlaceholder -> noexcept-expression -> noexcept( {expression} )
    => createElseNonTerminalPlaceholder -> nesting-operator -> ::
    => createElseMenuPlaceholder -> new-expression ->
      => [nesting-operator] new [new-placement] {new-type-id} [new-initializer]
      => [nesting-operator] new [new-placement] ( {type-id} ) [new-initializer]
    => createElseNonTerminalPlaceholder -> new-placement -> ( {expression-list} )
    => createElseNonTerminalPlaceholder -> new-type-id -> {type-specifier-seq} [new-declarator]
    => createElseMenuPlaceholder -> new-declarator ->
      => {ptr-operator} [new-declarator]
      => noptr-new-declarator
    => createElseMenuPlaceholder -> noptr-new-declarator ->
      => [ [expression] ] [attribute-specifier]...
      => {noptr-new-declarator} [ {constant-expression} ] [attribute-specifier]...
    => createElseMenuPlaceholder -> new-initializer ->
      => ( [expression-list] )
      => braced-init-list
    => createElseMenuPlaceholder -> delete-expression ->
      => [nesting-operator] delete {cast-expression}
      => [nesting-operator] delete[] {cast-expression}
    => createElseMenuPlaceholder -> cast-expression ->
      => unary-expression
      => ( {type-id} ) {cast-expression}
    => createElseMenuPlaceholder -> pm-expression ->
      => cast-expression
      => {pm-expression} .* {cast-expression}
      => {pm-expression} ->* {cast-expression}
    => createElseMenuPlaceholder -> multiplicative-expression ->
      => pm-expression
      => {multiplicative-expression} * {pm-expression}
      => {multiplicative-expression} / {pm-expression}
      => {multiplicative-expression} % {pm-expression}
    => createElseMenuPlaceholder -> additive-expression ->
      => multiplicative-expression
      => {additive-expression} + {multiplicative-expression}
      => {additive-expression} - {multiplicative-expression}
    => createElseMenuPlaceholder -> shift-expression ->
      => additive-expression
      => {shift-expression} << {additive-expression}
      => {shift-expression} >> {additive-expression}
    => createElseMenuPlaceholder -> compare-expression ->
      => shift-expression
      => {compare-expression} <=> {shift-expression}
    => createElseMenuPlaceholder -> relational-expression ->
      => compare-expression
      => {relational-expression} < {compare-expression}
      => {relational-expression} > {compare-expression}
      => {relational-expression} <= {compare-expression}
      => {relational-expression} >= {compare-expression}
    => createElseMenuPlaceholder -> equality-expression ->
      => relational-expression
      => {equality-expression} == {relational-expression}
      => {equality-expression} != {relational-expression}
    => createElseMenuPlaceholder -> and-expression ->
      => equality-expression
      => {and-expression} & {equality-expression}
    => createElseMenuPlaceholder -> exclusive-or-expression ->
      => and-expression
      => {exclusive-or-expression} ^ {and-expression}
    => createElseMenuPlaceholder -> inclusive-or-expression ->
      => exclusive-or-expression
      => {inclusive-or-expression} | {exclusive-or-expression}
    => createElseMenuPlaceholder -> logical-and-expression ->
      => inclusive-or-expression
      => {logical-and-expression} && {inclusive-or-expression}
    => createElseMenuPlaceholder -> logical-or-expression ->
      => logical-and-expression
      => {logical-or-expression} || {logical-and-expression}
    => createElseMenuPlaceholder -> conditional-expression ->
      => logical-or-expression
      => {logical-or-expression} ? {expression} : {assignment-expression}
    => createElseMenuPlaceholder -> yield-expression ->
      => co_yield {assignment-expression}
      => co_yield {braced-init-list}
    => createElseNonTerminalPlaceholder -> throw-expression -> throw [assignment-expression]
    => createElseMenuPlaceholder -> assignment-expression ->
      => conditional-expression
      => yield-expression
      => throw-expression
      => {logical-or-expression} {assignment-operator} {initializer-clause}
    => createElseMenuPlaceholder -> assignment-operator ->
      => =
      => *=
      => /=
      => %=
      => +=
      => -=
      => >>=
      => <<=
      => &=
      => ^=
      => |=
    => createElseMenuPlaceholder -> expression ->
      => assignment-expression
      => {expression} , {assignment-expression}
    => createElseNonTerminalPlaceholder -> constant-expression -> {conditional-expression}
    => createElseMenuPlaceholder -> statement ->
      => labeled-statement
      => [attribute-specifier]... {expression-statement}
      => [attribute-specifier]... {compound-statement}
      => [attribute-specifier]... {selection-statement}
      => [attribute-specifier]... {iteration-statement}
      => [attribute-specifier]... {jump-statement}
      => declaration-statement
      => [attribute-specifier]... {try-block}
    => createElseMenuPlaceholder -> init-statement ->
      => expression-statement
      => simple-declaration
      => alias-declaration
    => createElseMenuPlaceholder -> condition ->
      => expression
      => [attribute-specifier]... {decl-specifier-seq} {declarator} {brace-or-equal-initializer}
    => createElseMenuPlaceholder -> label ->
      => [attribute-specifier]... {identifier} :
      => [attribute-specifier]... case {constant-expression} :
      => [attribute-specifier]... default:
    => createElseNonTerminalPlaceholder -> labeled-statement -> {label} {statement}
    => createElseNonTerminalPlaceholder -> expression-statement -> [expression] ;
    => createElseNonTerminalPlaceholder -> compound-statement -> { [statement]... [label]... }
    => createElseNonTerminalPlaceholder -> if-constexpr -> if constexpr
    => createElseNonTerminalPlaceholder -> if-exlamation-mark -> if !
    => createElseMenuPlaceholder -> selection-statement ->
      => [if-constexpr] ( [init-statement] {condition} ) {statement}
      => [if-constexpr] ( [init-statement] {condition} ) {statement} else {statement}
      => [if-exlamation-mark] consteval {compound-statement}
      => [if-exlamation-mark] consteval {compound-statement} else {statement}
      => switch( [init-statement] {condition} ) {statement}
    => createElseMenuPlaceholder -> iteration-statement ->
      => while( {condition} ) {statement}
      => do {statement} while( {expression} );
      => for( {init-statement} [condition] ; [expression] ) {statement}
      => for( [init-statement] {for-range-declaration} : {for-range-initializer} ) {statement}
    => createElseMenuPlaceholder -> for-range-declaration ->
      => [attribute-specifier]... {decl-specifier-seq} {declarator}
      => [attribute-specifier]... {decl-specifier-seq} [ref-qualifier] [ {identifier}... ]
    => createElseNonTerminalPlaceholder -> for-range-initializer -> {expr-or-braced-init-list}
    => createElseMenuPlaceholder -> jump-statement ->
      => break;
      => continue;
      => return [expr-or-braced-init-list] ;
      => coroutine-return-statement
      => goto {identifier} ;
    => createElseNonTerminalPlaceholder -> coroutine-return-statement -> co_return [expr-or-braced-init-list] ;
    => createElseNonTerminalPlaceholder -> declaration-statement -> {block-declaration}
    => createElseMenuPlaceholder -> declaration ->
      => name-declaration
      => special-declaration
    => createElseMenuPlaceholder -> name-declaration ->
      => block-declaration
      => nodeclspec-function-declaration
      => function-definition
      => template-declaration
      => deduction-guide
      => linkage-specification
      => namespace-definition
      => empty-declaration
      => attribute-declaration
      => module-import-declaration
    => createElseMenuPlaceholder -> special-declaration ->
      => explicit-instantiation
      => explicit-specialization
      => export-declaration
    => createElseMenuPlaceholder -> block-declaration ->
      => simple-declaration
      => asm-declaration
      => namespace-alias-definition
      => using-declaration
      => using-enum-declaration
      => using-directive
      => static-assert-declaration
      => alias-declaration
      => opaque-enum-declaration
    => createElseNonTerminalPlaceholder -> nodeclspec-function-declaration -> [attribute-specifier]... {declarator} ;
    => createElseNonTerminalPlaceholder -> alias-declaration -> using {identifier} [attribute-specifier]... = {defining-type-id} ;
    => createElseMenuPlaceholder -> simple-declaration ->
      => {decl-specifier-seq} [init-declarator-list] ;
      => [attribute-specifier]... {decl-specifier-seq} {init-declarator-list} ;
      => [attribute-specifier]... {decl-specifier-seq} [ref-qualifier] [ {identifier}... ] {initializer} ;
    => createElseMenuPlaceholder -> static-assert-declaration ->
      => static-assert( {constant-expression} );
      => static-assert( {constant-expression} , {static-assert-message} );
    => createElseNonTerminalPlaceholder -> empty-declaration -> ;
    => createElseNonTerminalPlaceholder -> attribute-declaration -> {attribute-specifier}... ;
    => createElseMenuPlaceholder -> decl-specifier ->
      => storage-class-specifier
      => defining-type-specifier
      => function-specifier
      => friend
      => typedef
      => constexpr
      => consteval
      => constinit
      => inline
    => createElseMenuPlaceholder -> decl-specifier-seq ->
      => {decl-specifier} [attribute-specifier]...
      => {decl-specifier} {decl-specifier-seq}
    => createElseMenuPlaceholder -> storage-class-specifier ->
      => static
      => thread_local
      => extern
      => mutable
    => createElseMenuPlaceholder -> function-specifier ->
      => virtual
      => explicit-specifier
    => createElseMenuPlaceholder -> explicit-specifier ->
      => explicit( {constant-expression} )
      => explicit
    => createElseMenuPlaceholder -> type-specifier ->
      => simple-type-specifier
      => elaborated-type-specifier
      => typename-specifier
      => cv-qualifier
    => createElseMenuPlaceholder -> type-specifier-seq ->
      => {type-specifier} [attribute-specifier]...
      => {type-specifier} {type-specifier-seq}
    => createElseMenuPlaceholder -> defining-type-specifier ->
      => type-specifier
      => class-specifier
      => enum-specifier
    => createElseMenuPlaceholder -> defining-type-specifier-seq ->
      => {defining-type-specifier} [attribute-specifier]...
      => {defining-type-specifier} {defining-type-specifier-seq}
    => createElseMenuPlaceholder -> simple-type-specifier ->
      => [nested-name-specifier] {type-name}
      => {nested-name-specifier} template {simple-template-id}
      => computed-type-specifier
      => placeholder-type-specifier
      => [nested-name-specifier] {template-name}
      => char
      => char8_t
      => char16_t
      => char32_t
      => wchar_t
      => bool
      => short
      => int
      => long
      => signed
      => unsigned
      => float
      => double
      => void
    => createElseMenuPlaceholder -> type-name ->
      => class-name
      => enum-name
      => typedef-name
    => createElseMenuPlaceholder -> computed-type-specifier ->
      => decltype-specifier
      => pack-index-specifier
    => createElseNonTerminalPlaceholder -> pack-index-specifier -> {typedef-name} ...[ {constant-expression} ]
    => createElseMenuPlaceholder -> elaborated-type-specifier ->
      => {class-key} [attribute-specifier]... [nested-name-specifier] {identifier}
      => {class-key} {simple-template-id}
      => {class-key} {nested-name-specifier} [template] {simple-template-id}
      => enum [nested-name-specifier] {identifier}
    => createElseNonTerminalPlaceholder -> decltype-specifier -> decltype( {expression} )
    => createElseMenuPlaceholder -> placeholder-type-specifier ->
      => [type-constraint] auto
      => [type-constraint] decltype(auto)
    => createElseMenuPlaceholder -> init-declarator-list ->
      => init-declarator
      => {init-declarator-list} , {init-declarator}
    => createElseMenuPlaceholder -> init-declarator ->
      => {declarator} [initializer]
      => {declarator} {requires-clause}
    => createElseMenuPlaceholder -> declarator ->
      => ptr-declarator
      => {noptr-declarator} {parameters-and-qualifiers} {trailing-return-type}
    => createElseMenuPlaceholder -> ptr-declarator ->
      => noptr-declarator
      => {ptr-operator} {ptr-declarator}
    => createElseMenuPlaceholder -> noptr-declarator ->
      => {declarator-id} [attribute-specifier]...
      => {noptr-declarator} {parameters-and-qualifiers}
      => {noptr-declarator} [ [constant-expression] ] [attribute-specifier]...
      => ( {ptr-declarator} )
    => createElseNonTerminalPlaceholder -> parameters-and-qualifiers -> ( {parameter-declaration-clause} ) [cv-qualifier]... [ref-qualifier] [noexcept-specifier] [attribute-specifier]...
    => createElseNonTerminalPlaceholder -> trailing-return-type -> -> {type-id}
    => createElseMenuPlaceholder -> ptr-operator ->
      => * [attribute-specifier]... [cv-qualifier]...
      => & [attribute-specifier]...
      => && [attribute-specifier]...
      => {nested-name-specifier} * [attribute-specifier]... [cv-qualifier]...
      => [ms-based-modifier] * [attribute-specifier]... [ms-pointer-modifier]... [cv-qualifier]...
      => [ms-based-modifier] {nested-name-specifier} * [attribute-specifier]... [ms-pointer-modifier]... [cv-qualifier]...
    => createElseMenuPlaceholder -> cv-qualifier ->
      => const
      => volatile
    => createElseMenuPlaceholder -> ref-qualifier ->
      => &
      => &&
    => createElseNonTerminalPlaceholder -> three-dots -> ...
    => createElseNonTerminalPlaceholder -> declarator-id -> [three-dots] {id-expression}
    => createElseNonTerminalPlaceholder -> type-id -> {type-specifier-seq} [abstract-declarator]
    => createElseNonTerminalPlaceholder -> defining-type-id -> {defining-type-specifier-seq} [abstract-declarator]
    => createElseMenuPlaceholder -> abstract-declarator ->
      => ptr-abstract-declarator
      => [noptr-abstract-declarator] {parameters-and-qualifiers} {trailing-return-type}
      => abstract-pack-declarator
    => createElseMenuPlaceholder -> ptr-abstract-declarator ->
      => noptr-abstract-declarator
      => {ptr-operator} [ptr-abstract-declarator]
    => createElseMenuPlaceholder -> noptr-abstract-declarator ->
      => [noptr-abstract-declarator] {parameters-and-qualifiers}
      => [noptr-abstract-declarator] [ [constant-expression] ] [attribute-specifier]...
      => ( {ptr-abstract-declarator} )
    => createElseMenuPlaceholder -> abstract-pack-declarator ->
      => noptr-abstract-pack-declarator
      => {ptr-operator} {abstract-pack-declarator}
    => createElseMenuPlaceholder -> noptr-abstract-pack-declarator ->
      => {noptr-abstract-pack-declarator} {parameters-and-qualifiers}
      => ...
    => createElseMenuPlaceholder -> parameter-declaration-clause ->
      => [parameter-declaration-list] [three-dots]
      => {parameter-declaration-list} , ...
    => createElseMenuPlaceholder -> parameter-declaration-list ->
      => parameter-declaration
      => {parameter-declaration-list} , {parameter-declaration}
    => createElseNonTerminalPlaceholder -> this -> this
    => createElseMenuPlaceholder -> parameter-declaration ->
      => [attribute-specifier]... [this] {decl-specifier-seq} {declarator}
      => [attribute-specifier]... {decl-specifier-seq} {declarator} = {initializer-clause}
      => [attribute-specifier]... [this] {decl-specifier-seq} [abstract-declarator]
      => [attribute-specifier]... {decl-specifier-seq} [abstract-declarator] = {initializer-clause}
    => createElseMenuPlaceholder -> initializer ->
      => brace-or-equal-initializer
      => ( {expression-list} )
    => createElseMenuPlaceholder -> brace-or-equal-initializer ->
      => = {initializer-clause}
      => braced-init-list
    => createElseMenuPlaceholder -> initializer-clause ->
      => assignment-expression
      => braced-init-list
    => createElseNonTerminalPlaceholder -> comma -> ,
    => createElseMenuPlaceholder -> braced-init-list ->
      => { {initializer-list} [comma] }
      => { {designated-initializer-list} [comma] }
      => 
    => createElseMenuPlaceholder -> initializer-list ->
      => {initializer-clause} [three-dots]
      => {initializer-list} , {initializer-clause} [three-dots]
    => createElseMenuPlaceholder -> designated-initializer-list ->
      => designated-initializer-clause
      => {designated-initializer-list} , {designated-initializer-clause}
    => createElseNonTerminalPlaceholder -> designated-initializer-clause -> {designator} {brace-or-equal-initializer}
    => createElseNonTerminalPlaceholder -> designator -> . {identifier}
    => createElseMenuPlaceholder -> expr-or-braced-init-list ->
      => expression
      => braced-init-list
    => createElseMenuPlaceholder -> function-definition ->
      => [attribute-specifier]... [decl-specifier-seq] {declarator} [virt-specifier-seq] {function-body}
      => [attribute-specifier]... [decl-specifier-seq] {declarator} {requires-clause} {function-body}
    => createElseMenuPlaceholder -> function-body ->
      => [ctor-initializer] {compound-statement}
      => function-try-block
      => = default;
      => = delete;
    => createElseMenuPlaceholder -> enum-specifier ->
      => {enum-head} { [enumerator-list] }
      => {enum-head} { {enumerator-list} , }
    => createElseNonTerminalPlaceholder -> enum-head -> {enum-key} [attribute-specifier]... [enum-head-name] [enum-base]
    => createElseNonTerminalPlaceholder -> enum-head-name -> [nested-name-specifier] {identifier}
    => createElseNonTerminalPlaceholder -> opaque-enum-declaration -> {enum-key} [attribute-specifier]... {enum-head-name} [enum-base] ;
    => createElseMenuPlaceholder -> enum-key ->
      => enum
      => enum class
      => enum struct
    => createElseNonTerminalPlaceholder -> enum-base -> : {type-specifier-seq}
    => createElseMenuPlaceholder -> enumerator-list ->
      => enumerator-definition
      => {enumerator-list} , {enumerator-definition}
    => createElseMenuPlaceholder -> enumerator-definition ->
      => enumerator
      => {enumerator} = {constant-expression}
    => createElseNonTerminalPlaceholder -> enumerator -> {identifier} [attribute-specifier]...
    => createElseNonTerminalPlaceholder -> using-enum-declaration -> using enum {using-enum-declarator} ;
    => createElseMenuPlaceholder -> using-enum-declarator ->
      => [nested-name-specifier] {identifier}
      => [nested-name-specifier] {simple-template-id}
    => createElseMenuPlaceholder -> namespace-definition ->
      => named-namespace-definition
      => unnamed-namespace-definition
      => nested-namespace-definition
    => createElseNonTerminalPlaceholder -> inline -> inline
    => createElseNonTerminalPlaceholder -> nested-inline -> :: inline
    => createElseNonTerminalPlaceholder -> named-namespace-definition -> [inline] namespace [attribute-specifier]... {identifier} { {namespace-body} }
    => createElseNonTerminalPlaceholder -> unnamed-namespace-definition -> [inline] namespace [attribute-specifier]... { {namespace-body} }
    => createElseNonTerminalPlaceholder -> nested-namespace-definition -> namespace {enclosing-namespace-specifier} [nested-inline] {identifier} { {namespace-body} }
    => createElseMenuPlaceholder -> enclosing-namespace-specifier ->
      => identifier
      => {enclosing-namespace-specifier} [nested-inline] {identifier}
    => createElseNonTerminalPlaceholder -> namespace-body -> [declaration]...
    => createElseNonTerminalPlaceholder -> namespace-alias-definition -> namespace {identifier} = {qualified-namespace-specifier} ;
    => createElseNonTerminalPlaceholder -> qualified-namespace-specifier -> [nested-name-specifier] {namespace-name}
    => createElseNonTerminalPlaceholder -> using-directive -> [attribute-specifier]... using namespace [nested-name-specifier] {namespace-name} ;
    => createElseNonTerminalPlaceholder -> using-declaration -> using {using-declarator-list} ;
    => createElseMenuPlaceholder -> using-declarator-list ->
      => {using-declarator} [three-dots]
      => {using-declarator-list} , {using-declarator} [three-dots]
    => createElseNonTerminalPlaceholder -> typename -> typename
    => createElseNonTerminalPlaceholder -> using-declarator -> [typename] {nested-name-specifier} {unqualified-id}
    => createElseNonTerminalPlaceholder -> asm-declaration -> [attribute-specifier]... asm( {balanced-token-seq} );
    => createElseMenuPlaceholder -> linkage-specification ->
      => extern {unevaluated-string} { [declaration]... }
      => extern {unevaluated-string} {name-declaration}
    => createElseMenuPlaceholder -> attribute-specifier ->
      => [[ [attribute-using-prefix] {attribute-list} ]]
      => alignment-specifier
    => createElseMenuPlaceholder -> alignment-specifier ->
      => alignas( {type-id} [three-dots] )
      => alignas( {constant-expression} [three-dots] )
    => createElseNonTerminalPlaceholder -> attribute-using-prefix -> using {attribute-namespace} :
    => createElseMenuPlaceholder -> attribute-list ->
      => attribute
      => {attribute-list} , [attribute]
      => {attribute} ...
      => {attribute-list} , {attribute} ...
    => createElseNonTerminalPlaceholder -> attribute -> {attribute-token} [attribute-argument-clause]
    => createElseMenuPlaceholder -> attribute-token ->
      => identifier
      => attribute-scoped-token
    => createElseNonTerminalPlaceholder -> attribute-scoped-token -> {attribute-namespace} :: {identifier}
    => createElseNonTerminalPlaceholder -> attribute-namespace -> {identifier}
    => createElseNonTerminalPlaceholder -> attribute-argument-clause -> ( [balanced-token-seq] )
    => createElseMenuPlaceholder -> balanced-token-seq ->
      => balanced-token
      => {balanced-token-seq} {balanced-token}
    => createElseTerminalPlaceholder -> non_balanced_token
    => createElseMenuPlaceholder -> balanced-token ->
      => ( [balanced-token-seq] )
      => [ [balanced-token-seq] ]
      => { [balanced-token-seq] }
      => non_balanced_token
    => createElseNonTerminalPlaceholder -> module-declaration -> [export-keyword] {module-keyword} {module-name} [module-partition] [attribute-specifier]... ;
    => createElseNonTerminalPlaceholder -> module-name -> [module-name-qualifier] {identifier}
    => createElseNonTerminalPlaceholder -> module-partition -> : [module-name-qualifier] {identifier}
    => createElseMenuPlaceholder -> module-name-qualifier ->
      => {identifier} .
      => {module-name-qualifier} {identifier} .
    => createElseMenuPlaceholder -> export-declaration ->
      => export {name-declaration}
      => export { [declaration]... }
      => {export-keyword} {module-import-declaration}
    => createElseMenuPlaceholder -> module-import-declaration ->
      => {import-keyword} {module-name} [attribute-specifier]... ;
      => {import-keyword} {module-partition} [attribute-specifier]... ;
      => {import-keyword} {header-name} [attribute-specifier]... ;
    => createElseNonTerminalPlaceholder -> global-module-fragment -> {module-keyword} ; [declaration]...
    => createElseNonTerminalPlaceholder -> -module-fragment -> {module-keyword} : private; [declaration]...
    => createElseNonTerminalPlaceholder -> class-specifier -> {class-head} { [member-specification] }
    => createElseMenuPlaceholder -> class-head ->
      => {class-key} [attribute-specifier]... {class-head-name} [class-virt-specifier] [base-clause]
      => {class-key} [attribute-specifier]... [base-clause]
    => createElseNonTerminalPlaceholder -> class-head-name -> [nested-name-specifier] {class-name}
    => createElseNonTerminalPlaceholder -> class-virt-specifier -> final
    => createElseMenuPlaceholder -> class-key ->
      => class
      => struct
      => union
    => createElseMenuPlaceholder -> member-specification ->
      => {member-declaration} [member-specification]
      => {access-specifier} : [member-specification]
    => createElseMenuPlaceholder -> member-declaration ->
      => [attribute-specifier]... [decl-specifier-seq] [member-declarator-list] ;
      => function-definition
      => using-declaration
      => using-enum-declaration
      => static-assert-declaration
      => template-declaration
      => explicit-specialization
      => deduction-guide
      => alias-declaration
      => opaque-enum-declaration
      => empty-declaration
    => createElseMenuPlaceholder -> member-declarator-list ->
      => member-declarator
      => {member-declarator-list} , {member-declarator}
    => createElseMenuPlaceholder -> member-declarator ->
      => {declarator} [virt-specifier-seq] [pure-specifier]
      => {declarator} {requires-clause}
      => {declarator} [brace-or-equal-initializer]
      => [identifier] [attribute-specifier]... : {constant-expression} [brace-or-equal-initializer]
    => createElseMenuPlaceholder -> virt-specifier-seq ->
      => virt-specifier
      => {virt-specifier-seq} {virt-specifier}
    => createElseMenuPlaceholder -> virt-specifier ->
      => override
      => final
    => createElseNonTerminalPlaceholder -> pure-specifier -> = 0
    => createElseNonTerminalPlaceholder -> conversion-function-id -> operator {conversion-type-id}
    => createElseNonTerminalPlaceholder -> conversion-type-id -> {type-specifier-seq} [conversion-declarator]
    => createElseNonTerminalPlaceholder -> conversion-declarator -> {ptr-operator} [conversion-declarator]
    => createElseNonTerminalPlaceholder -> base-clause -> : {base-specifier-list}
    => createElseMenuPlaceholder -> base-specifier-list ->
      => {base-specifier} [three-dots]
      => {base-specifier-list} , {base-specifier} [three-dots]
    => createElseNonTerminalPlaceholder -> virtual -> virtual
    => createElseMenuPlaceholder -> base-specifier ->
      => [attribute-specifier]... {class-or-decltype}
      => [attribute-specifier]... virtual [access-specifier] {class-or-decltype}
      => [attribute-specifier]... {access-specifier} [virtual] {class-or-decltype}
    => createElseMenuPlaceholder -> class-or-decltype ->
      => [nested-name-specifier] {type-name}
      => {nested-name-specifier} template {simple-template-id}
      => decltype-specifier
    => createElseMenuPlaceholder -> access-specifier ->
      => private
      => protected
      => public
    => createElseNonTerminalPlaceholder -> ctor-initializer -> : {mem-initializer-list}
    => createElseMenuPlaceholder -> mem-initializer-list ->
      => {mem-initializer} [three-dots]
      => {mem-initializer-list} , {mem-initializer} [three-dots]
    => createElseMenuPlaceholder -> mem-initializer ->
      => {mem-initializer-id} ( [expression-list] )
      => {mem-initializer-id} {braced-init-list}
    => createElseMenuPlaceholder -> mem-initializer-id ->
      => class-or-decltype
      => identifier
    => createElseNonTerminalPlaceholder -> operator-function-id -> operator {operator}
    => createElseMenuPlaceholder -> operator ->
      => new
      => delete
      => new[]
      => delete[]
      => co_await
      => ()
      => 
      => ->
      => ->*
      => ~
      => !
      => +
      => -
      => *
      => /
      => %
      => ^
      => &
      => |
      => =
      => +=
      => -=
      => *=
      => /=
      => %=
      => ^=
      => &=
      => |=
      => ==
      => !=
      => <
      => >
      => <=
      => >=
      => <=>
      => &&
      => ||
      => <<
      => >>
      => <<=
      => >>=
      => ++
      => --
      => ,
    => createElseMenuPlaceholder -> literal-operator-id ->
      => operator {unevaluated-string} {identifier}
      => operator {user-defined-string-literal}
    => createElseMenuPlaceholder -> template-declaration ->
      => {template-head} {declaration}
      => {template-head} {concept-definition}
    => createElseNonTerminalPlaceholder -> template-head -> template< {template-parameter-list} > [requires-clause]
    => createElseMenuPlaceholder -> template-parameter-list ->
      => template-parameter
      => {template-parameter-list} , {template-parameter}
    => createElseNonTerminalPlaceholder -> requires-clause -> requires {constraint-logical-or-expression}
    => createElseMenuPlaceholder -> constraint-logical-or-expression ->
      => constraint-logical-and-expression
      => {constraint-logical-or-expression} || {constraint-logical-and-expression}
    => createElseMenuPlaceholder -> constraint-logical-and-expression ->
      => primary-expression
      => {constraint-logical-and-expression} && {primary-expression}
    => createElseMenuPlaceholder -> template-parameter ->
      => type-parameter
      => parameter-declaration
    => createElseMenuPlaceholder -> type-parameter ->
      => {type-parameter-key} [three-dots] [identifier]
      => {type-parameter-key} [identifier] = {type-id}
      => {type-constraint} [three-dots] [identifier]
      => {type-constraint} [identifier] = {type-id}
      => {template-head} {type-parameter-key} [three-dots] [identifier]
      => {template-head} {type-parameter-key} [identifier] = {id-expression}
    => createElseMenuPlaceholder -> type-parameter-key ->
      => class
      => typename
    => createElseMenuPlaceholder -> type-constraint ->
      => [nested-name-specifier] {concept-name}
      => [nested-name-specifier] {concept-name} < [template-argument-list] >
    => createElseNonTerminalPlaceholder -> simple-template-id -> {template-name} < [template-argument-list] >
    => createElseMenuPlaceholder -> template-id ->
      => simple-template-id
      => {operator-function-id} < [template-argument-list] >
      => {literal-operator-id} < [template-argument-list] >
    => createElseMenuPlaceholder -> template-argument-list ->
      => {template-argument} [three-dots]
      => {template-argument-list} , {template-argument} [three-dots]
    => createElseMenuPlaceholder -> template-argument ->
      => constant-expression
      => type-id
      => id-expression
      => braced-init-list
    => createElseNonTerminalPlaceholder -> constraint-expression -> {logical-or-expression}
    => createElseNonTerminalPlaceholder -> deduction-guide -> [explicit-specifier] {template-name} ( {parameter-declaration-clause} )-> {simple-template-id} ;
    => createElseNonTerminalPlaceholder -> concept-definition -> {concept} {concept-name} [attribute-specifier]... = {constraint-expression} ;
    => createElseNonTerminalPlaceholder -> concept-name -> {identifier}
    => createElseMenuPlaceholder -> typename-specifier ->
      => typename {nested-name-specifier} {identifier}
      => typename {nested-name-specifier} [template] {simple-template-id}
    => createElseNonTerminalPlaceholder -> extern -> extern
    => createElseNonTerminalPlaceholder -> explicit-instantiation -> [extern] template {declaration}
    => createElseNonTerminalPlaceholder -> explicit-specialization -> template<> {declaration}
    => createElseNonTerminalPlaceholder -> try-block -> try {compound-statement} {handler-seq}
    => createElseNonTerminalPlaceholder -> function-try-block -> try [ctor-initializer] {compound-statement} {handler-seq}
    => createElseNonTerminalPlaceholder -> handler-seq -> {handler} [handler-seq]
    => createElseNonTerminalPlaceholder -> handler -> catch( {exception-declaration} ) {compound-statement}
    => createElseMenuPlaceholder -> exception-declaration ->
      => [attribute-specifier]... {type-specifier-seq} {declarator}
      => [attribute-specifier]... {type-specifier-seq} [abstract-declarator]
      => ...
    => createElseMenuPlaceholder -> noexcept-specifier ->
      => noexcept( {constant-expression} )
      => noexcept
    => createElseMenuPlaceholder -> preprocessing-file ->
      => group
      => module-file
    => createElseNonTerminalPlaceholder -> module-file -> [pp-global-module-fragment] {pp-module} [group] [pp-private-module-fragment]
    => createElseNonTerminalPlaceholder -> pp-global-module-fragment -> module; {new-line} [group]
    => createElseNonTerminalPlaceholder -> pp-private-module-fragment -> module : private; {new-line} [group]
    => createElseMenuPlaceholder -> group ->
      => group-part
      => {group} {group-part}
    => createElseMenuPlaceholder -> group-part ->
      => control-line
      => if-section
      => text-line
      => # {conditionally-supported-directive}
    => createElseMenuPlaceholder -> control-line ->
      => #include {preprocessing-token}... {new-line}
      => pp-import
      => #define {identifier} {replacement-list} {new-line}
      => #define {identifier} {lparen} [identifier]... ) [preprocessing-token]... {new-line}
      => #define {identifier} {lparen} ...) [preprocessing-token]... {new-line}
      => #define {identifier} {lparen} {identifier}... ,...) [preprocessing-token]... {new-line}
      => #undef {identifier} {new-line}
      => #line {preprocessing-token}... {new-line}
      => #error [preprocessing-token]... {new-line}
      => #warning [preprocessing-token]... {new-line}
      => #pragma [preprocessing-token]... {new-line}
      => # {new-line}
    => createElseNonTerminalPlaceholder -> if-section -> {if-group} [elif-groups] [else-group] {endif-line}
    => createElseMenuPlaceholder -> if-group ->
      => #if {constant-expression} {new-line} [group]
      => #ifdef {identifier} {new-line} [group]
      => #ifndef {identifier} {new-line} [group]
    => createElseMenuPlaceholder -> elif-groups ->
      => elif-group
      => {elif-groups} {elif-group}
    => createElseMenuPlaceholder -> elif-group ->
      => #elif {constant-expression} {new-line} [group]
      => #elifdef {identifier} {new-line} [group]
      => #elifndef {identifier} {new-line} [group]
    => createElseNonTerminalPlaceholder -> else-group -> #else {new-line} [group]
    => createElseNonTerminalPlaceholder -> endif-line -> #endif {new-line}
    => createElseNonTerminalPlaceholder -> text-line -> [preprocessing-token]... {new-line}
    => createElseNonTerminalPlaceholder -> conditionally-supported-directive -> {preprocessing-token}... {new-line}
    => createElseTerminalPlaceholder -> lparen
    => createElseTerminalPlaceholder -> new-line
    => createElseMenuPlaceholder -> defined-macro-expression ->
      => defined {identifier}
      => defined( {identifier} )
    => createElseMenuPlaceholder -> header-name-tokens ->
      => string-literal
      => < {h-preprocessing-token}... >
    => createElseMenuPlaceholder -> has-include-expression ->
      => __has_include( {header-name} )
      => __has_include( {header-name-tokens} )
    => createElseNonTerminalPlaceholder -> has-attribute-expression -> __has_cpp_attribute( {preprocessing-token}... )
    => createElseNonTerminalPlaceholder -> export -> export
    => createElseNonTerminalPlaceholder -> pp-module -> [export] module [preprocessing-token]... ; {new-line}
    => createElseMenuPlaceholder -> pp-import ->
      => [export] import {header-name} [preprocessing-token]... ; {new-line}
      => [export] import {header-name-tokens} [preprocessing-token]... ; {new-line}
      => [export] import {preprocessing-token}... ; {new-line}
    => createElseNonTerminalPlaceholder -> va-replacement -> __VA-OPT__( [preprocessing-token]... )
    => createElseMenuPlaceholder -> ms-call-modifier ->
      => __cdecl
      => __clrcall
      => __stdcall
      => __fastcall
      => __thiscall
      => __vectorcall
    => createElseNonTerminalPlaceholder -> ms-call-modifier-seq -> {ms-call-modifier} [ms-call-modifier-seq]
    => createElseMenuPlaceholder -> ms-pointer-modifier ->
      => __restrict
      => __uptr
      => __sptr
      => _unaligned
      => __unaligned
    => createElseNonTerminalPlaceholder -> ms-declspec-modifier -> __declspec( {identifier} )
---- quoteTerminals ------------------------------------------------------------------------------
'!'
'!='
'"'
'##'
'#'
'#define'
'#elif'
'#elifdef'
'#elifndef'
'#else'
'#endif'
'#error'
'#if'
'#ifdef'
'#ifndef'
'#include'
'#line'
'#pragma'
'#undef'
'#warning'
'%'
'%:%:'
'%:'
'%='
'%>'
'& ...'
'&&'
'&'
'&='
'('
'()'
'(...'
')'
')->'
');'
'*'
'*='
'*this'
'+'
'++'
'+='
', ...'
', }'
','
',...)'
'-'
'--'
'-='
'->'
'->*'
'->template'
'.'
'.*'
'... ['
'...'
'...)'
'...['
'.template'
'/'
'/='
'0'
'0B'
'0X'
'0b'
'0x'
'1'
'2'
'3'
'4'
'5'
'6'
'7'
'8'
'9'
': private;'
':'
':: inline'
'::'
':>'
';'
'<%'
'<'
'<:'
'<<'
'<<<Each non-whitespace character that cannot be one of the above.>>>'
'<<<Enter a ( character not immediately preceded by whitespace.>>>'
'<<<Enter a basic source character except the double-quote ", backslash \\, or new-line \\n character.>>>'
'<<<Enter a basic source character except the single-quote \', backslash \\, or new-line \\n character.>>>'
'<<<Enter a basic source character that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x.>>>'
'<<<Enter a h-char sequence, i.e. source characters except \\n and > characters.>>>'
'<<<Enter a hexadecimal digit, i.e. any number of hex characters [0-9a-fA-F].>>>'
'<<<Enter a n-char sequence, that is translation characters except of { or \\n.>>>'
'<<<Enter a q-char sequence, i.e. source characters except \\n and quotation mark " characters.>>>'
'<<<Enter a sequence of basic source characters except: space, the left parenthesis (, the right parenthesis ), the backslash \\, and the control characters representing horizontal tab, vertical tab, form feed, and newline.>>>'
'<<<Enter a sequence of source characters, except a right parenthesis ) followed by the initial d-char-sequence (which may be empty) followed by a double quote ".>>>'
'<<<Enter an element of the translation character set with the Unicode property XID-Continue.>>>'
'<<<Enter an element of the translation character set with the Unicode property XID-Start.>>>'
'<<<Enter any token other than a parenthesis (), a bracket [], or a brace {}.>>>'
'<<<Enter exactly eight hex number characters [0-9a-fA-F], i.e. NNNNNNNN.>>>'
'<<<Enter exactly four hex number characters [0-9a-fA-F], i.e. NNNN.>>>'
'<<<Enter the new-line \\n character.>>>'
'<<='
'<='
'<=>'
'= 0'
'= default;'
'= delete;'
'='
'=='
'>'
'>('
'>='
'>>'
'>>='
'?'
'A'
'B'
'BF16'
'C'
'D'
'E'
'F'
'F128'
'F16'
'F32'
'F64'
'G'
'H'
'I'
'J'
'K'
'L'
'LL'
'M'
'N'
'O'
'P'
'Q'
'R'
'S'
'T'
'U'
'V'
'W'
'X'
'Y'
'Z'
'['
'[['
'[]'
'\''
'\\'
'\\N{'
'\\U'
'\\o{'
'\\u'
'\\u{'
'\\x'
'\\x{'
']'
']]'
'^'
'^='
'_'
'__VA-OPT__('
'__cdecl'
'__clrcall'
'__declspec('
'__fastcall'
'__has_cpp_attribute('
'__has_include('
'__restrict'
'__sptr'
'__stdcall'
'__thiscall'
'__unaligned'
'__uptr'
'__vectorcall'
'_unaligned'
'a'
'alignas'
'alignas('
'alignof'
'alignof('
'and'
'and_eq'
'asm'
'asm('
'auto'
'b'
'bf16'
'bitand'
'bitor'
'bool'
'break'
'break;'
'c'
'case'
'catch'
'catch('
'char'
'char16_t'
'char32_t'
'char8_t'
'class'
'co_await'
'co_return'
'co_yield'
'compl'
'concept'
'const'
'const-cast<'
'const_cast'
'consteval'
'constexpr'
'constinit'
'continue'
'continue;'
'd'
'decltype'
'decltype('
'decltype(auto)'
'default'
'default:'
'defined'
'defined('
'delete'
'delete[]'
'do'
'double'
'dynamic-cast<'
'dynamic_cast'
'e'
'else'
'enum class'
'enum struct'
'enum'
'explicit'
'explicit('
'export {'
'export'
'extern'
'f'
'f128'
'f16'
'f32'
'f64'
'false'
'final'
'float'
'for'
'for('
'friend'
'g'
'goto'
'h'
'i'
'if !'
'if constexpr'
'if'
'import'
'inline'
'int'
'j'
'k'
'l'
'll'
'long'
'm'
'module : private;'
'module'
'module;'
'mutable'
'n'
'namespace'
'new'
'new[]'
'noexcept'
'noexcept('
'not'
'not_eq'
'nullptr'
'o'
'operator'
'or'
'or_eq'
'override'
'p'
'private'
'protected'
'public'
'q'
'r'
'register'
'reinterpret-cast<'
'reinterpret_cast'
'requires'
'return'
's'
'short'
'signed'
'sizeof'
'sizeof('
'sizeof...('
'static'
'static-assert('
'static-cast<'
'static_assert'
'static_cast'
'struct'
'switch'
'switch('
't'
'template'
'template<'
'template<>'
'this'
'thread_local'
'throw'
'true'
'try'
'typedef'
'typeid'
'typeid('
'typename'
'u'
'u8'
'union'
'unsigned'
'using enum'
'using namespace'
'using'
'v'
'virtual'
'void'
'volatile'
'w'
'wchar_t'
'while'
'while('
'x'
'xor'
'xor_eq'
'y'
'z'
'{'
'{}'
'|'
'|='
'||'
'}'
'~'
---- terminals -----------------------------------------------------------------------------------
---- lexerRuleSpec -------------------------------------------------------------------------------
---- quotedLexerRuleSpec -------------------------------------------------------------------------
---- unquotedLexerRuleSpec -----------------------------------------------------------------------
---- ruleSpec ------------------------------------------------------------------------------------
---- placeholders -------------------------------------------------------------------------------

-module-fragment
abstract-declarator
abstract-pack-declarator
access-specifier
additive-expression
alias-declaration
alignment-specifier
and-expression
and-three-dots
arrow-template
asm-declaration
assignment-expression
assignment-operator
attribute
attribute-argument-clause
attribute-declaration
attribute-list
attribute-namespace
attribute-scoped-token
attribute-specifier
attribute-token
attribute-using-prefix
await-expression
balanced-token
balanced-token-seq
base-clause
base-specifier
base-specifier-list
basic-c-char
basic-s-char
binary-digit
binary-exponent-part
binary-literal
block-declaration
boolean-literal
brace-or-equal-initializer
braced-init-list
c-char
capture
capture-default
capture-list
cast-expression
character-literal
class-head
class-head-name
class-key
class-name
class-or-decltype
class-specifier
class-virt-specifier
comma
compare-expression
compound-requirement
compound-statement
computed-type-specifier
concept-definition
concept-name
condition
conditional-escape-sequence
conditional-escape-sequence-char
conditional-expression
conditionally-supported-directive
constant-expression
constraint-expression
constraint-logical-and-expression
constraint-logical-or-expression
control-line
conversion-declarator
conversion-function-id
conversion-type-id
coroutine-return-statement
ctor-initializer
cv-qualifier
d-char
decimal-floating-point-literal
decimal-literal
decl-specifier
decl-specifier-seq
declaration
declaration-statement
declarator
declarator-id
decltype-specifier
deduction-guide
defined-macro-expression
defining-type-id
defining-type-specifier
defining-type-specifier-seq
delete-expression
designated-initializer-clause
designated-initializer-list
designator
digit
digit-sequence
dot-template
elaborated-type-specifier
elif-group
elif-groups
else-group
empty-declaration
enclosing-namespace-specifier
encoding-prefix
endif-line
enum-base
enum-head
enum-head-name
enum-key
enum-name
enum-specifier
enumerator
enumerator-definition
enumerator-list
equality-expression
escape-sequence
exception-declaration
exclusive-or-expression
explicit-instantiation
explicit-specialization
explicit-specifier
exponent-part
export
export-declaration
expr-or-braced-init-list
expression
expression-list
expression-statement
extern
floating-point-literal
floating-point-suffix
fold-expression
fold-operator
for-range-declaration
for-range-initializer
fractional-constant
function-body
function-definition
function-specifier
function-try-block
global-module-fragment
group
group-part
h-char
handler
handler-seq
has-attribute-expression
has-include-expression
header-name
header-name-tokens
hex-quad
hex-quad-quad
hexadecimal-digit
hexadecimal-digit-sequence
hexadecimal-escape-sequence
hexadecimal-floating-point-literal
hexadecimal-fractional-constant
hexadecimal-literal
hexadecimal-prefix
id-expression
identifier
identifier-continue
identifier-start
if-constexpr
if-exlamation-mark
if-group
if-section
inclusive-or-expression
init-capture
init-declarator
init-declarator-list
init-statement
initializer
initializer-clause
initializer-list
inline
integer-literal
integer-suffix
iteration-statement
jump-statement
keyword
label
labeled-statement
lambda-capture
lambda-declarator
lambda-expression
lambda-introducer
lambda-specifier
linkage-specification
literal
literal-operator-id
logical-and-expression
logical-or-expression
long-long-suffix
long-suffix
lparen
mem-initializer
mem-initializer-id
mem-initializer-list
member-declaration
member-declarator
member-declarator-list
member-specification
module-declaration
module-file
module-import-declaration
module-name
module-name-qualifier
module-partition
ms-call-modifier
ms-call-modifier-seq
ms-declspec-modifier
ms-pointer-modifier
multiplicative-expression
n-char
name-declaration
named-namespace-definition
named-universal-character
namespace-alias
namespace-alias-definition
namespace-body
namespace-definition
namespace-name
nested-inline
nested-name-specifier
nested-namespace-definition
nested-requirement
nesting-operator
new-declarator
new-expression
new-initializer
new-line
new-placement
new-type-id
nodeclspec-function-declaration
noexcept-expression
noexcept-specifier
non-whitespace-character-literal
non_balanced_token
nondigit
nonzero-digit
noptr-abstract-declarator
noptr-abstract-pack-declarator
noptr-declarator
noptr-new-declarator
numeric-escape-sequence
octal-digit
octal-escape-sequence
octal-literal
opaque-enum-declaration
operator
operator-function-id
operator-or-punctuator
pack-index-expression
pack-index-specifier
parameter-declaration
parameter-declaration-clause
parameter-declaration-list
parameters-and-qualifiers
placeholder-type-specifier
pm-expression
pointer-literal
postfix-expression
pp-global-module-fragment
pp-import
pp-module
pp-number
pp-private-module-fragment
preprocessing-file
preprocessing-op-or-punc
preprocessing-operator
preprocessing-token
primary-expression
ptr-abstract-declarator
ptr-declarator
ptr-operator
pure-specifier
q-char
qualified-id
qualified-namespace-specifier
r-char
raw-string
ref-qualifier
relational-expression
requirement
requirement-body
requirement-parameter-list
requires-clause
requires-expression
return-type-requirement
s-char
selection-statement
shift-expression
sign
simple-capture
simple-declaration
simple-escape-sequence
simple-escape-sequence-char
simple-quote-char
simple-requirement
simple-template-id
simple-type-specifier
size-suffix
special-declaration
statement
static-assert-declaration
storage-class-specifier
string-literal
template
template-argument
template-argument-list
template-declaration
template-head
template-id
template-name
template-parameter
template-parameter-list
text-line
this
three-dots
throw-expression
token
trailing-return-type
translation-character-xid-continue
translation-character-xid-start
translation-unit
try-block
type-constraint
type-id
type-name
type-parameter
type-parameter-key
type-requirement
type-specifier
type-specifier-seq
typedef-name
typename
typename-specifier
ud-suffix
unary-expression
unary-operator
universal-character-name
unnamed-namespace-definition
unqualified-id
unsigned-suffix
user-defined-character-literal
user-defined-floating-point-literal
user-defined-integer-literal
user-defined-literal
user-defined-string-literal
using-declaration
using-declarator
using-declarator-list
using-directive
using-enum-declaration
using-enum-declarator
va-replacement
virt-specifier
virt-specifier-seq
virtual
yield-expression

